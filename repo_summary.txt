РЕПОЗИТОРИЙ: C:\Users\noize\Documents\ceiling_calculator
================================================================================

СТРУКТУРА ПРОЕКТА:
----------------------------------------
ceiling_calculator/
├── .gitignore
├── buildozer.spec
├── ceiling_calculator.db
├── database.py
├── main.py
├── models.py
├── repo_to_text.py
├── .github/
│   ├── workflows/
│   │   ├── build-apk.yml
├── fonts/
│   ├── DejaVuSans.ttf
├── screens/
│   ├── __init__.py
│   ├── layout_screen.py
│   ├── main_screen.py
│   ├── projects_screen.py
│   ├── room_editor.py
│   ├── rooms_screen.py
├── utils/
│   ├── __init__.py
├── widgets/
│   ├── __init__.py
│   ├── grid_widget.py
│   ├── layout_widget.py

================================================================================


============================================================
ФАЙЛ: database.py
============================================================

# database.py
import sqlite3
import json
from datetime import datetime
from models import Project, Room

DB_NAME = "ceiling_calculator.db"


def init_db():
    """Инициализирует базу данных и создает таблицы."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()

    # Таблица для проектов
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS projects (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL
    )
    """)

    # Таблица для комнат
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS rooms (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_id INTEGER NOT NULL,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL,
        walls_json TEXT NOT NULL,
        last_position_json TEXT,
        grid_offset_x INTEGER DEFAULT 0,
        grid_offset_y INTEGER DEFAULT 0,
        FOREIGN KEY (project_id) REFERENCES projects (id)
    )
    """)

    # ← КРИТИЧНО: Миграция для старых БД
    try:
        cursor.execute(
            "ALTER TABLE rooms ADD COLUMN grid_offset_x INTEGER DEFAULT 0")
    except sqlite3.OperationalError:
        pass  # Колонка уже существует

    try:
        cursor.execute(
            "ALTER TABLE rooms ADD COLUMN grid_offset_y INTEGER DEFAULT 0")
    except sqlite3.OperationalError:
        pass  # Колонка уже существует

    conn.commit()
    conn.close()


def save_project(project):
    """Сохраняет проект (и его комнаты) в базу данных."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        if project.id is None:
            cursor.execute("""
            INSERT INTO projects (name, created_at) VALUES (?, ?)
            """, (project.name, project.created_at.isoformat()))
            project.id = cursor.lastrowid
        else:
            cursor.execute("""
            UPDATE projects SET name = ?, created_at = ?
            WHERE id = ?
            """, (project.name, project.created_at.isoformat(), project.id))

        cursor.execute("DELETE FROM rooms WHERE project_id = ?", (project.id,))

        for room in project.rooms:
            walls_json_str = json.dumps(room.walls)
            last_pos_json_str = json.dumps(room.last_position) if hasattr(
                room, 'last_position') and room.last_position else None
            grid_offset_x = getattr(room, 'grid_offset_x', 0)
            grid_offset_y = getattr(room, 'grid_offset_y', 0)
            cursor.execute("""
            INSERT INTO rooms (project_id, name, created_at, walls_json, last_position_json, grid_offset_x, grid_offset_y)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (project.id, room.name, room.created_at.isoformat(), walls_json_str, last_pos_json_str, grid_offset_x, grid_offset_y))

        conn.commit()
        print(f"Проект '{project.name}' успешно сохранен в базу данных.")
    except sqlite3.Error as e:
        print(f"Ошибка при сохранении проекта в базу данных: {e}")
        conn.rollback()
    finally:
        conn.close()


def load_project(project_id):
    """Загружает проект (и его комнаты) из базы данных по ID."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute(
            "SELECT id, name, created_at FROM projects WHERE id = ?", (project_id,))
        row = cursor.fetchone()
        if row is None:
            return None
        project = Project(row[1])
        project.id = row[0]
        project.created_at = datetime.fromisoformat(row[2])

        # ← КРИТИЧНО: Загружаем комнаты с всеми полями
        cursor.execute(
            "SELECT id, name, created_at, walls_json, last_position_json, grid_offset_x, grid_offset_y FROM rooms WHERE project_id = ?", (project_id,))
        for room_row in cursor.fetchall():
            room = Room(room_row[1])
            room.id = room_row[0]
            room.created_at = datetime.fromisoformat(room_row[2])
            room.walls = json.loads(room_row[3])
            if room_row[4]:
                room.last_position = json.loads(room_row[4])
            room.grid_offset_x = room_row[5] if room_row[5] else 0
            room.grid_offset_y = room_row[6] if room_row[6] else 0
            project.rooms.append(room)

        print(
            f"Проект '{project.name}' загружен. Комнат: {len(project.rooms)}")
        return project
    except sqlite3.Error as e:
        print(f"Ошибка при загрузке проекта: {e}")
        return None
    finally:
        conn.close()


def load_all_projects():
    """Загружает список всех проектов (без комнат)."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute(
            "SELECT id, name, created_at FROM projects ORDER BY created_at DESC")
        rows = cursor.fetchall()
        projects = []
        for row in rows:
            proj = Project(row[1])
            proj.id = row[0]
            proj.created_at = datetime.fromisoformat(row[2])
            projects.append(proj)
        return projects
    except sqlite3.Error as e:
        print(f"Ошибка при загрузке списка проектов: {e}")
        return []
    finally:
        conn.close()


def delete_project(project_id):
    """Удаляет проект и все его комнаты из базы данных."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute("DELETE FROM rooms WHERE project_id = ?", (project_id,))
        cursor.execute("DELETE FROM projects WHERE id = ?", (project_id,))
        conn.commit()
        print(f"Проект с ID {project_id} и его комнаты успешно удалены.")
        return True
    except sqlite3.Error as e:
        print(f"Ошибка при удалении проекта: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()


def delete_room_from_project(project_id, room_id):
    """Удаляет комнату из базы данных, связанной с проектом."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute(
            "DELETE FROM rooms WHERE id = ? AND project_id = ?", (room_id, project_id))
        conn.commit()
        if cursor.rowcount > 0:
            print(
                f"Комната с ID {room_id} из проекта с ID {project_id} успешно удалена.")
            return True
        else:
            print(
                f"Комната с ID {room_id} не найдена в проекте с ID {project_id}.")
            return False
    except sqlite3.Error as e:
        print(f"Ошибка при удалении комнаты: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()

============================================================
ФАЙЛ: main.py
============================================================

from kivy.app import App
from kivy.uix.screenmanager import ScreenManager
from kivy.core.window import Window
from kivy.utils import get_color_from_hex, platform  # ← ДОБАВЛЕН импорт platform
# Импортируем экраны
from screens.main_screen import MainScreen
from screens.projects_screen import ProjectsScreen
from screens.rooms_screen import RoomsScreen
from screens.room_editor import RoomEditorScreen
from screens.layout_screen import LayoutScreen
import os

# Это строка для отладки на Windows, на Android ломает рендеринг и координаты касаний, убрать перед сборкой
os.environ['KIVY_GL_BACKEND'] = 'angle_sdl2'

# Устанавливаем размер ТОЛЬКО для десктопа (на Android игнорируется и ломает координаты!)
if platform != 'android':
    Window.size = (320, 640)

Window.clearcolor = (1, 1, 1, 1)  # Белый фон


class CeilingCalculatorApp(App):
    def build(self):
        # ← КРИТИЧНО: настраиваем масштабирование ДО создания виджетов
        if platform == 'android':
            # Гарантируем полноэкранный режим с правильным масштабированием
            Window.softinput_mode = 'below_target'  # Клавиатура не закроет поля ввода
            
        # Создаем менеджер экранов
        sm = ScreenManager()
        sm.current_project = None
        sm.current_room = None

        # Добавляем экраны
        sm.add_widget(MainScreen(name='main'))
        sm.add_widget(ProjectsScreen(name='projects'))
        sm.add_widget(RoomsScreen(name='rooms'))
        sm.add_widget(RoomEditorScreen(name='room_editor'))
        sm.add_widget(LayoutScreen(name='layout'))
        
        # Применяем стиль
        Window.clearcolor = get_color_from_hex('#FFFFFF')
        self.theme_cls = type('Theme', (), {
            'primary_color': get_color_from_hex('#000000'),
            'text_color': get_color_from_hex('#000000')
        })

        return sm


if __name__ == '__main__':
    CeilingCalculatorApp().run()

============================================================
ФАЙЛ: models.py
============================================================

# models.py 
import json
from datetime import datetime
import math


class Project:
    """Класс проекта (здания/объекта)"""

    def __init__(self, name):
        self.id = None
        self.name = name
        self.created_at = datetime.now()
        self.rooms = []  # Список объектов Room

    def to_dict(self):
        """Конвертирует проект в словарь"""
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat(),
            'rooms': [room.to_dict() for room in self.rooms]
        }

    @classmethod
    def from_dict(cls, data):
        """Создает проект из словаря"""
        project = cls(data['name'])
        project.id = data['id']
        project.created_at = datetime.fromisoformat(data['created_at'])
        project.rooms = [Room.from_dict(room_data)
                         for room_data in data['rooms']]
        return project


class Room:
    """Класс комнаты"""

    def __init__(self, name):
        self.id = None
        self.name = name
        self.created_at = datetime.now()
        self.walls = []  # Список стен в формате [[x1, y1, x2, y2], ...]
        self.last_position = None  # Последняя позиция курсора в редакторе
        self.grid_offset_x = 0  # Сохранённое смещение сетки (критично!)
        self.grid_offset_y = 0  # Сохранённое смещение сетки (критично!)

    def to_dict(self):
        """Конвертирует комнату в словарь"""
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat(),
            'walls': self.walls,
            'last_position': self.last_position,
            'grid_offset_x': self.grid_offset_x,  # Новое поле
            'grid_offset_y': self.grid_offset_y   # Новое поле
        }

    @classmethod
    def from_dict(cls, data):
        """Создает комнату из словаря"""
        room = cls(data['name'])
        room.id = data['id']
        room.created_at = datetime.fromisoformat(data['created_at'])
        room.walls = data['walls']
        room.last_position = data.get('last_position')
        room.grid_offset_x = data.get('grid_offset_x', 0)  # Новое поле
        room.grid_offset_y = data.get('grid_offset_y', 0)  # Новое поле
        return room


class CeilingLayout:
    """Класс для расчета раскладки потолка 60×60 см"""
    TILE_SIZE = 60  # 60 см

    def __init__(self, room):
        self.room = room
        self.grid_offset_x = room.grid_offset_x if hasattr(
            room, 'grid_offset_x') else 0
        self.grid_offset_y = room.grid_offset_y if hasattr(
            room, 'grid_offset_y') else 0
        self.tiles = []
        self.full_tiles = 0
        self.cut_tiles = 0
        self.waste_percentage = 0
        self.room_polygon = self._build_room_polygon()
        self.room_bounds = self.get_room_bounds()
        self.room_area_sqm = 0.0
        self._area_calculated = False  # ← Флаг для кэширования

    def calculate_room_area(self):
        """Точный расчет площади комнаты с кэшированием"""
        # ← КРИТИЧНО: Возвращаем кэшированное значение если уже считали
        if self._area_calculated and self.room_area_sqm > 0:
            return self.room_area_sqm * 10000  # Возвращаем в см²

        if not self.room.walls or len(self.room.walls) < 3:
            return 0

        # Собираем точки полигона комнаты
        points = []
        if self.room.walls:
            points.append((self.room.walls[0][0], self.room.walls[0][1]))
            for wall in self.room.walls:
                points.append((wall[2], wall[3]))

        # Замыкаем полигон
        if points[0] != points[-1]:
            points.append(points[0])

        # Метод Гаусса для расчета площади полигона
        area = 0
        n = len(points) - 1
        for i in range(n):
            x1, y1 = points[i]
            x2, y2 = points[i + 1]
            area += x1 * y2 - x2 * y1

        area_sqcm = abs(area) / 2

        # ← Кэшируем результат
        self.room_area_sqm = area_sqcm / 10000.0
        self._area_calculated = True

        return area_sqcm

    def _build_room_polygon(self):
        """Предварительно строит полигон комнаты один раз"""
        if not self.room.walls:
            return []
        points = []
        for wall in self.room.walls:
            points.append((wall[0], wall[1]))
            points.append((wall[2], wall[3]))
        unique_points = []
        for point in points:
            if point not in unique_points:
                unique_points.append(point)
        if unique_points and unique_points[0] != unique_points[-1]:
            unique_points.append(unique_points[0])
        return unique_points

    def calculate_layout(self):
        """Рассчитывает раскладку для текущего смещения"""
        self.tiles = []
        self.full_tiles = 0
        self.cut_tiles = 0
        if not self.room.walls:
            self.calculate_statistics()
            return

        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        min_x, max_x = min(all_x), max(all_x)
        min_y, max_y = min(all_y), max(all_y)

        search_min_x = min_x - 60
        search_max_x = max_x + 60
        search_min_y = min_y - 60
        search_max_y = max_y + 60

        grid_start_x = math.floor((search_min_x - self.grid_offset_x) /
                                  self.TILE_SIZE) * self.TILE_SIZE + self.grid_offset_x
        grid_start_y = math.floor((search_min_y - self.grid_offset_y) /
                                  self.TILE_SIZE) * self.TILE_SIZE + self.grid_offset_y

        x = grid_start_x
        while x < search_max_x:
            y = grid_start_y
            while y < search_max_y:
                tile_x2 = x + self.TILE_SIZE
                tile_y2 = y + self.TILE_SIZE
                tile_info = self.analyze_tile(x, y, tile_x2, tile_y2)
                if tile_info['type'] != 'outside':
                    self.tiles.append(tile_info)
                    if tile_info['type'] == 'full':
                        self.full_tiles += 1
                    elif tile_info['type'] == 'cut':
                        self.cut_tiles += 1
                y += self.TILE_SIZE
            x += self.TILE_SIZE

        self.calculate_statistics()

    def analyze_tile(self, x1, y1, x2, y2):
        """Анализирует плитку с учетом реальной геометрии комнаты"""
        room_min_x, room_max_x, room_min_y, room_max_y = self.get_room_bounds()

        if x2 <= room_min_x or x1 >= room_max_x or y2 <= room_min_y or y1 >= room_max_y:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]
        corners_inside = sum(
            1 for corner in corners if self.is_point_inside_room(*corner))

        if corners_inside == 4:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'full', 'cut_x': 60, 'cut_y': 60}

        if corners_inside == 0:
            test_points = [
                ((x1 + x2) / 2, (y1 + y2) / 2),
                (x1 + 20, y1 + 20), (x2 - 20, y2 - 20),
                (x1 + 20, y2 - 20), (x2 - 20, y1 + 20)
            ]
            points_inside = sum(
                1 for point in test_points if self.is_point_inside_room(*point))
            if points_inside == 0:
                return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        useful_x, useful_y = self.calculate_cut_dimensions(x1, y1, x2, y2)

        if useful_x < 0.1 and useful_y < 0.1:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        return {
            'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2,
            'type': 'cut',
            'cut_x': max(0.1, useful_x),
            'cut_y': max(0.1, useful_y)
        }

    def get_room_bounds(self):
        """Возвращает границы комнаты для быстрой проверки"""
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        # ← КРИТИЧНО: обработка пустой комнаты
        if not all_x or not all_y:
            return 0, 0, 0, 0

        return min(all_x), max(all_x), min(all_y), max(all_y)

    def calculate_cut_dimensions(self, x1, y1, x2, y2):
        """Точный расчет полезных размеров плитки"""
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1_w, y1_w, x2_w, y2_w = wall
            all_x.extend([x1_w, x2_w])
            all_y.extend([y1_w, y2_w])

        if not all_x or not all_y:
            return 0.0, 0.0

        room_min_x = min(all_x)
        room_max_x = max(all_x)
        room_min_y = min(all_y)
        room_max_y = max(all_y)

        is_rectangular = False
        if len(self.room.walls) == 4:
            corners = set()
            for wall in self.room.walls:
                corners.add((wall[0], wall[1]))
                corners.add((wall[2], wall[3]))
            if len(corners) == 4:
                corner_x = sorted(set([p[0] for p in corners]))
                corner_y = sorted(set([p[1] for p in corners]))
                if (len(corner_x) == 2 and len(corner_y) == 2 and
                    room_min_x in corner_x and room_max_x in corner_x and
                        room_min_y in corner_y and room_max_y in corner_y):
                    is_rectangular = True

        if is_rectangular:
            intersect_x1 = max(x1, room_min_x)
            intersect_y1 = max(y1, room_min_y)
            intersect_x2 = min(x2, room_max_x)
            intersect_y2 = min(y2, room_max_y)
            if intersect_x1 >= intersect_x2 or intersect_y1 >= intersect_y2:
                return 0.0, 0.0
            useful_x = round(intersect_x2 - intersect_x1)
            useful_y = round(intersect_y2 - intersect_y1)
            return max(0.0, min(60.0, useful_x)), max(0.0, min(60.0, useful_y))
        else:
            corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]
            corners_inside = [
                p for p in corners if self.is_point_inside_room(*p)]

            if len(corners_inside) == 4:
                return 60.0, 60.0

            center = ((x1 + x2) / 2, (y1 + y2) / 2)
            if not corners_inside and not self.is_point_inside_room(*center):
                return 0.0, 0.0

            intersection_points = []
            for wall in self.room.walls:
                wx1, wy1, wx2, wy2 = wall
                for line in [
                    (x1, y1, x1, y2), (x2, y1, x2, y2),
                    (x1, y1, x2, y1), (x1, y2, x2, y2)
                ]:
                    inter = self.line_intersection(*line, wx1, wy1, wx2, wy2)
                    if inter:
                        intersection_points.append(inter)

            inside_points = corners_inside.copy()
            if intersection_points:
                inside_points.extend(intersection_points)
            else:
                key_points = [
                    (x1 + 20, y1 + 20), (x1 + 40, y1 + 20),
                    (x1 + 20, y1 + 40), (x1 + 40, y1 + 40),
                    (x1 + 30, y1 + 30)
                ]
                for px, py in key_points:
                    if self.is_point_inside_room(px, py):
                        inside_points.append((px, py))

            if not inside_points:
                return 0.0, 0.0

            min_x = min(p[0] for p in inside_points)
            max_x = max(p[0] for p in inside_points)
            min_y = min(p[1] for p in inside_points)
            max_y = max(p[1] for p in inside_points)

            useful_x = max(0.0, min(60.0, round(max_x - min_x)))
            useful_y = max(0.0, min(60.0, round(max_y - min_y)))
            return max(0.1, useful_x), max(0.1, useful_y)

    def line_intersection(self, x1, y1, x2, y2, x3, y3, x4, y4):
        """Находит точку пересечения двух отрезков"""
        denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
        if abs(denom) < 0.001:
            return None
        ua = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
        ub = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom
        if ua < 0 or ua > 1 or ub < 0 or ub > 1:
            return None
        x = x1 + ua * (x2-x1)
        y = y1 + ua * (y2-y1)
        if (min(x1, x2) - 1 <= x <= max(x1, x2) + 1 and
            min(y1, y2) - 1 <= y <= max(y1, y2) + 1 and
            min(x3, x4) - 1 <= x <= max(x3, x4) + 1 and
                min(y3, y4) - 1 <= y <= max(y3, y4) + 1):
            return (x, y)
        return None

    def point_to_line_distance(self, px, py, x1, y1, x2, y2):
        """Вычисляет расстояние от точки до линии"""
        if x1 == x2 and y1 == y2:
            return math.sqrt((px - x1)**2 + (py - y1)**2)
        line_vec_x = x2 - x1
        line_vec_y = y2 - y1
        point_vec_x = px - x1
        point_vec_y = py - y1
        line_len = math.sqrt(line_vec_x**2 + line_vec_y**2)
        if line_len > 0:
            line_vec_x /= line_len
            line_vec_y /= line_len
        projection_length = point_vec_x * line_vec_x + point_vec_y * line_vec_y
        projection_length = max(0, min(line_len, projection_length))
        closest_x = x1 + projection_length * line_vec_x
        closest_y = y1 + projection_length * line_vec_y
        return math.sqrt((px - closest_x)**2 + (py - closest_y)**2)

    def is_point_inside_room(self, px, py):
        """Проверка точки внутри комнаты (ray casting)"""
        if not self.room_polygon:
            return False
        min_x, max_x, min_y, max_y = self.room_bounds
        if px < min_x - 1 or px > max_x + 1 or py < min_y - 1 or py > max_y + 1:
            return False
        inside = False
        j = len(self.room_polygon) - 1
        for i in range(len(self.room_polygon)):
            xi, yi = self.room_polygon[i]
            xj, yj = self.room_polygon[j]
            if ((yi > py) != (yj > py)) and (px < (xj - xi) * (py - yi) / (yj - yi + 1e-10) + xi):
                inside = not inside
            j = i
        return inside

    # def calculate_room_area(self):
    #     """Точный расчет площади комнаты методом триангуляции для сложных форм"""
    #     # ← КРИТИЧНО: обработка пустой комнаты
    #     if not self.room.walls or len(self.room.walls) < 3:
    #         return 0

    #     # Собираем точки полигона комнаты
    #     points = []
    #     if self.room.walls:
    #         points.append((self.room.walls[0][0], self.room.walls[0][1]))
    #         for wall in self.room.walls:
    #             points.append((wall[2], wall[3]))

    #     # Замыкаем полигон
    #     if points[0] != points[-1]:
    #         points.append(points[0])

    #     # Метод Гаусса для расчета площади полигона
    #     area = 0
    #     n = len(points) - 1
    #     for i in range(n):
    #         x1, y1 = points[i]
    #         x2, y2 = points[i + 1]
    #         area += x1 * y2 - x2 * y1

    #     return abs(area) / 2

    def calculate_statistics(self):
        """Рассчитывает статистику раскладки"""
        if not self.room.walls:
            self.waste_percentage = 0
            self.room_area_sqm = 0.0
            return
        # 1. Точно считаем площадь комнаты в см²
        room_area_sqcm = self.calculate_room_area()

        # ← КРИТИЧНО: проверка на нулевую площадь
        if room_area_sqcm <= 0:
            self.room_area_sqm = 0.0
            self.waste_percentage = 0
            return
        # 2. Конвертируем площадь в м²
        self.room_area_sqm = room_area_sqcm / 10000.0

        full_area = self.full_tiles * (self.TILE_SIZE * self.TILE_SIZE)
        cut_area_total = 0
        for tile in self.tiles:
            if tile['type'] == 'cut':
                useful_x = tile.get('cut_x', 0)
                useful_y = tile.get('cut_y', 0)
                useful_area = useful_x * useful_y
                cut_area_total += useful_area
        useful_area_total = full_area + cut_area_total
        total_tiles_area = (self.full_tiles + self.cut_tiles) * \
            (self.TILE_SIZE * self.TILE_SIZE)
        waste_area = total_tiles_area - useful_area_total
        if room_area_sqcm > 0:
            waste_percent = (waste_area / room_area_sqcm) * 100
            self.waste_percentage = round(waste_percent, 1)
        else:
            self.waste_percentage = 0

    def move_grid(self, dx, dy):
        """Смещает сетку"""
        self.grid_offset_x = (self.grid_offset_x + dx) % self.TILE_SIZE
        self.grid_offset_y = (self.grid_offset_y + dy) % self.TILE_SIZE
        self.calculate_layout()


============================================================
ФАЙЛ: screens\__init__.py
============================================================



============================================================
ФАЙЛ: screens\layout_screen.py
============================================================

# screens/layout_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from widgets.layout_widget import LayoutWidget
from models import CeilingLayout
from database import save_project  # Импортируем функцию сохранения
from kivy.clock import Clock  # ← ДОБАВИТЬ импорт


class LayoutScreen(Screen):
    """Экран раскладки потолка 60×60 см"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.snap_mode = 0
        self.control_mode = 'grid'

        # ← КРИТИЧНО: Переменные для авто-повтора кнопок
        self.repeat_event = None
        self.repeat_dx = 0
        self.repeat_dy = 0

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))
        self.selected_corner = None

        # Панель инструментов
        toolbar = self.create_toolbar()

        # Область с раскладкой
        self.layout_widget = LayoutWidget(size_hint=(1, 1))

        # Панель управления
        control_panel = self.create_control_panel()

        # Панель статистики
        stats_panel = self.create_stats_panel()

        # Собираем в правильный порядок
        main_layout.add_widget(toolbar)
        main_layout.add_widget(self.layout_widget)
        main_layout.add_widget(control_panel)
        main_layout.add_widget(stats_panel)

        # Оборачиваем в FloatLayout для правильного z-ordering
        from kivy.uix.floatlayout import FloatLayout
        overlay = FloatLayout()
        overlay.add_widget(main_layout)
        self.add_widget(overlay)

    def toggle_dimensions(self, instance):
        """Переключает отображение размеров резаных плиток"""
        if not hasattr(self, 'layout_widget'):
            return

        # Инвертируем состояние
        self.layout_widget.show_dimensions = not self.layout_widget.show_dimensions

        # Меняем текст кнопки
        if self.layout_widget.show_dimensions:
            instance.text = 'Скрыть размеры плит'
            instance.background_color = (0.5, 0.5, 0.5, 1)
        else:
            instance.text = 'Показать размеры плит'
            instance.background_color = (0.3, 0.7, 0.3, 1)

        # Перерисовываем
        self.layout_widget.draw_layout()

    def toggle_wall_dimensions(self, instance):
        """← НОВОЕ: Переключает отображение размеров стен"""
        if not hasattr(self, 'layout_widget'):
            return

        # Инвертируем состояние
        self.layout_widget.show_wall_dimensions = not self.layout_widget.show_wall_dimensions

        # Меняем текст кнопки
        if self.layout_widget.show_wall_dimensions:
            instance.text = 'Скрыть размеры стен'
            instance.background_color = (0.5, 0.5, 0.5, 1)
        else:
            instance.text = 'Показать размеры стен'
            instance.background_color = (0.3, 0.7, 0.3, 1)

        # Перерисовываем
        self.layout_widget.draw_layout()

    def on_pre_enter(self):
        """Загружаем комнату при входе"""
        from kivy.clock import Clock
        Clock.schedule_once(self.load_room_data, 0.1)

    def load_room_data(self, dt):
        """Загружает данные комнаты с задержкой для правильной инициализации"""
        if not hasattr(self.manager, 'current_room') or not self.manager.current_room:
            print("Ошибка: current_room не установлен")
            return
        current_room = self.manager.current_room
        if current_room:
            print(f"Загрузка комнаты: {current_room.name}")
            print(f"Стены: {len(current_room.walls)}")

            # Устанавливаем стены в виджет
            self.layout_widget.set_room(current_room.walls)

            # Создаем расчет раскладки
            self.ceiling_layout = CeilingLayout(current_room)

            # ← КРИТИЧНО: загружаем сохранённое смещение из комнаты
            self.ceiling_layout.grid_offset_x = getattr(
                current_room, 'grid_offset_x', 0)
            self.ceiling_layout.grid_offset_y = getattr(
                current_room, 'grid_offset_y', 0)
            self.layout_widget.grid_offset_x = self.ceiling_layout.grid_offset_x
            self.layout_widget.grid_offset_y = self.ceiling_layout.grid_offset_y

            # Рассчитываем раскладку
            self.ceiling_layout.calculate_layout()

            # Передаем layout в виджет
            self.layout_widget.layout = self.ceiling_layout

            # Устанавливаем callback для обновления статистики при движении сетки
            self.layout_widget.on_grid_move = self.on_grid_moved

            # Обновляем статистику
            self.update_stats()

            # Явно перерисовываем
            self.layout_widget.draw_layout()

    def on_grid_moved(self):
        """Callback, вызываемый при изменении положения сетки"""
        # Получаем ТОЧНЫЕ значения смещения без округления
        if hasattr(self.layout_widget, 'grid_offset_x') and hasattr(self.layout_widget, 'grid_offset_y'):
            # Берем точные значения для расчета
            exact_offset_x = self.layout_widget.grid_offset_x
            exact_offset_y = self.layout_widget.grid_offset_y

            # Обновляем расчет раскладки с точными значениями
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = exact_offset_x
                self.ceiling_layout.grid_offset_y = exact_offset_y
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
                self.update_stats()  # Обновляем статистику при движении сетки

            # Округляем ТОЛЬКО для отображения в лейбле ПОСЛЕ расчета
            offset_x_display = int(round(exact_offset_x))
            offset_y_display = int(round(exact_offset_y))

            # Обновляем отображение СРАЗУ при любом изменении
            if hasattr(self, 'offset_label'):
                self.offset_label.text = f'Смещение: {offset_x_display}×{offset_y_display} см'

    def create_toolbar(self):
        """Создает панель инструментов с кнопкой режима"""
        toolbar = BoxLayout(
            size_hint=(1, 0.14),
            padding=dp(5),
            spacing=dp(5)  # ← КРИТИЧНО: отступ между кнопками
        )

        # Кнопка "Назад"
        btn_back = Button(
            text='Назад',
            font_size=dp(14),  # ← Чуть меньше шрифт
            size_hint=(0.2, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # Заголовок
        title = Label(
            text='Раскладка\n60×60 см',
            font_size=dp(14),
            size_hint=(0.3, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            max_lines=2,
            line_height=1.2
        )
        title.bind(size=title.setter('text_size'))

        # Кнопка режима управления
        self.mode_button = Button(
            text='Сетка',
            font_size=dp(14),
            size_hint=(0.25, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        self.mode_button.bind(on_press=self.toggle_control_mode)

        # Кнопка "Сброс"
        btn_reset = Button(
            text='Сброс',
            font_size=dp(14),
            size_hint=(0.25, 1),
            background_color=(0.9, 0.6, 0.2, 1),
            color=(1, 1, 1, 1)
        )
        btn_reset.bind(on_press=self.reset_view)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(title)
        toolbar.add_widget(self.mode_button)
        toolbar.add_widget(btn_reset)

        return toolbar

    def toggle_control_mode(self, instance):
        """Переключает режим управления"""
        if self.control_mode == 'grid':
            self.control_mode = 'pan_zoom'
            self.mode_button.text = 'Панорама'
            self.mode_button.background_color = (0.3, 0.7, 0.3, 1)
            # Отключаем перемещение сетки пальцем
            self.layout_widget.dragging_enabled = False
        else:
            self.control_mode = 'grid'
            self.mode_button.text = 'Сетка'
            self.mode_button.background_color = (0.2, 0.6, 1, 1)
            # Включаем перемещение сетки пальцем
            self.layout_widget.dragging_enabled = True

    def reset_view(self, instance):
        """Сбрасывает вид к первоначальному состоянию"""
        if self.control_mode == 'pan_zoom':
            # Центрируем комнату
            self.layout_widget.center_room()
        else:
            # Сбрасываем сетку
            self.layout_widget.grid_offset_x = 0
            self.layout_widget.grid_offset_y = 0
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = 0
                self.ceiling_layout.grid_offset_y = 0
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
                self.update_stats()
                self.layout_widget.draw_layout()

    def create_control_panel(self):
        """Создает панель управления сеткой (2 строки: стрелки + 2 кнопки)"""
        # Основной контейнер с вертикальной ориентацией (2 строки)
        control_panel = BoxLayout(
            orientation='vertical',
            size_hint=(1, 0.1),
            padding=dp(5),
            spacing=dp(5)
        )

        # === СТРОКА 1: кнопки смещения (с авто-повтором) ===
        row1 = BoxLayout(
            size_hint=(1, 0.5),
            spacing=dp(5)
        )

        # ← КРИТИЧНО: Кнопки с привязкой on_press и on_release для авто-повтора
        btn_left = Button(
            text='<-',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_left.bind(
            on_press=lambda x: self.start_repeat_move(-1, 0),
            on_release=lambda x: self.stop_repeat_move()
        )

        btn_up = Button(
            text='^',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_up.bind(
            on_press=lambda x: self.start_repeat_move(0, 1),
            on_release=lambda x: self.stop_repeat_move()
        )

        btn_down = Button(
            text='v',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_down.bind(
            on_press=lambda x: self.start_repeat_move(0, -1),
            on_release=lambda x: self.stop_repeat_move()
        )

        btn_right = Button(
            text='->',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_right.bind(
            on_press=lambda x: self.start_repeat_move(1, 0),
            on_release=lambda x: self.stop_repeat_move()
        )

        row1.add_widget(btn_left)
        row1.add_widget(btn_up)
        row1.add_widget(btn_down)
        row1.add_widget(btn_right)

        # === СТРОКА 2: ДВЕ кнопки переключения размеров (убрали "Сброс") ===
        row2 = BoxLayout(
            size_hint=(1, 0.6),
            spacing=dp(5),  # ← Отступ между кнопками
        )

        # Кнопка 1: Размеры плиток
        self.toggle_dims_btn = Button(
            text='Скрыть размеры плит',
            font_size=dp(12),
            size_hint=(0.5, 1),  # ← 50% ширины
            background_color=(0.5, 0.5, 0.5, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        self.toggle_dims_btn.bind(
            size=lambda instance, size: setattr(
                instance, 'text_size', (size[0] * 0.9, None))
        )
        self.toggle_dims_btn.bind(on_press=self.toggle_dimensions)

        # ← Кнопка 2: Размеры стен
        self.toggle_wall_dims_btn = Button(
            text='Скрыть размеры стен',
            font_size=dp(12),
            size_hint=(0.5, 1),  # ← 50% ширины
            background_color=(0.5, 0.5, 0.5, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        self.toggle_wall_dims_btn.bind(
            size=lambda instance, size: setattr(
                instance, 'text_size', (size[0] * 0.9, None))
        )
        self.toggle_wall_dims_btn.bind(on_press=self.toggle_wall_dimensions)

        row2.add_widget(self.toggle_dims_btn)
        row2.add_widget(self.toggle_wall_dims_btn)

        # Собираем обе строки в панель
        control_panel.add_widget(row1)
        control_panel.add_widget(row2)

        return control_panel

    # ← КРИТИЧНО: НОВЫЕ МЕТОДЫ для авто-повтора
    def start_repeat_move(self, dx, dy):
        """Запускает авто-повтор смещения сетки"""
        # Сначала делаем один сдвиг сразу
        self.move_grid(dx, dy)

        # Сохраняем направление
        self.repeat_dx = dx
        self.repeat_dy = dy

        # Параметры скорости
        initial_delay = 0.3  # 300мс перед первым повтором
        repeat_interval = 0.1  # 100мс между повторами

        # Планируем первый повтор через задержку
        from kivy.clock import Clock
        self.repeat_event = Clock.schedule_once(
            lambda dt: self._repeat_move_loop(repeat_interval),
            initial_delay
        )

    def _repeat_move_loop(self, interval):
        """Цикл авто-повтора"""
        # Делаем сдвиг
        self.move_grid(self.repeat_dx, self.repeat_dy)

        # Планируем следующий повтор
        from kivy.clock import Clock
        self.repeat_event = Clock.schedule_once(
            lambda dt: self._repeat_move_loop(interval),
            interval
        )

    def stop_repeat_move(self):
        """Останавливает авто-повтор"""
        if self.repeat_event:
            from kivy.clock import Clock
            Clock.unschedule(self.repeat_event)
            self.repeat_event = None
        self.repeat_dx = 0
        self.repeat_dy = 0

    def move_grid(self, dx, dy):
        """Смещает сетку на dx, dy сантиметров с немедленным отображением"""
        if hasattr(self.layout_widget, 'grid_offset_x'):
            # Устанавливаем ТОЧНОЕ смещение и округляем до целого
            self.layout_widget.grid_offset_x = round(
                self.layout_widget.grid_offset_x + dx)
            self.layout_widget.grid_offset_y = round(
                self.layout_widget.grid_offset_y + dy)

            # Немедленно обновляем расчет
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = self.layout_widget.grid_offset_x
                self.ceiling_layout.grid_offset_y = self.layout_widget.grid_offset_y
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout

                # Вызываем callback вручную для немедленного обновления
                self.on_grid_moved()

            # Перерисовываем
            self.layout_widget.draw_layout()

    def create_stats_panel(self):
        """Создает панель статистики"""
        stats_panel = BoxLayout(
            size_hint=(1, 0.05),
            padding=dp(10)
        )
        # Изменяем текст на площадь
        self.stats_label = Label(
            text='Целых: 0 | Резаных: 0 | Площадь: 0.0 м²',
            font_size=dp(14),
            color=(0, 0, 0, 1)
        )
        stats_panel.add_widget(self.stats_label)
        return stats_panel

    def reset_grid(self, instance):
        """Сбрасывает смещение сетки к (0, 0)"""
        self.layout_widget.grid_offset_x = 0
        self.layout_widget.grid_offset_y = 0
        if self.ceiling_layout:
            self.ceiling_layout.grid_offset_x = 0
            self.ceiling_layout.grid_offset_y = 0
            self.ceiling_layout.calculate_layout()
            self.layout_widget.layout = self.ceiling_layout
        self.update_stats()
        self.layout_widget.draw_layout()

    def update_stats(self):
        """Обновляет статистику раскладки"""
        if self.ceiling_layout:
            stats = self.ceiling_layout
            # Обновляем текст: вместо отходов показываем площадь
            self.stats_label.text = f'Целых: {stats.full_tiles} | Резаных: {stats.cut_tiles} | Площадь: {stats.room_area_sqm:.2f} м²'

    def go_back(self, instance):
        """Возврат в редактор"""
        # ← КРИТИЧНО: Сохраняем только если смещение изменилось
        if hasattr(self, 'ceiling_layout') and self.manager.current_room:
            current_room = self.manager.current_room

            # Проверяем, изменилось ли смещение
            old_offset_x = getattr(current_room, 'grid_offset_x', 0)
            old_offset_y = getattr(current_room, 'grid_offset_y', 0)
            new_offset_x = self.ceiling_layout.grid_offset_x
            new_offset_y = self.ceiling_layout.grid_offset_y

            # Сохраняем ТОЛЬКО если значения изменились
            if old_offset_x != new_offset_x or old_offset_y != new_offset_y:
                current_room.grid_offset_x = new_offset_x
                current_room.grid_offset_y = new_offset_y
                from database import save_project
                save_project(self.manager.current_project)
                print(
                    f"Смещение сетки сохранено: {new_offset_x}×{new_offset_y} см")
            else:
                print("Смещение сетки не изменилось, сохранение пропущено")

        # Возвращаемся в редактор
        self.manager.current = 'room_editor'

============================================================
ФАЙЛ: screens\main_screen.py
============================================================

from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.metrics import dp


class MainScreen(Screen):
    """Главный экран с выбором калькулятора"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Основной вертикальный контейнер
        main_layout = BoxLayout(
            orientation='vertical',
            padding=dp(20),
            spacing=dp(20)
        )

        # Заголовок приложения
        title = Label(
            text='Калькулятор потолков',
            font_size=dp(28),
            color=(0, 0, 0, 1),
            size_hint=(1, 0.2),
            bold=True
        )

        # Контейнер для кнопок
        buttons_layout = BoxLayout(
            orientation='vertical',
            spacing=dp(15),
            size_hint=(1, 0.8)
        )

        # Кнопка 1: Расчет раскладки потолка
        btn_calc1 = Button(
            text='Расчет раскладки потолка',
            font_size=dp(18),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            size_hint=(1, 0.45)
        )
        # Изменено: теперь идем в проекты
        btn_calc1.bind(on_press=self.go_to_projects)

        # Кнопка 2: Расчет материалов (заглушка)
        btn_calc2 = Button(
            text='Расчет материалов',
            font_size=dp(18),
            background_color=(0.3, 0.7, 0.3, 1),
            color=(1, 1, 1, 1),
            size_hint=(1, 0.45)
        )
        btn_calc2.bind(on_press=self.show_placeholder)

        # Собираем интерфейс
        buttons_layout.add_widget(btn_calc1)
        buttons_layout.add_widget(btn_calc2)

        main_layout.add_widget(title)
        main_layout.add_widget(buttons_layout)

        self.add_widget(main_layout)

    def go_to_projects(self, instance):  # Переименован метод
        """Переход к экрану проектов"""
        print("Переход к экрану проектов")
        self.manager.current = 'projects'

    def show_placeholder(self, instance):
        """Заглушка для второго калькулятора"""
        instance.text = "В разработке!"
        from kivy.clock import Clock
        Clock.schedule_once(lambda dt: setattr(
            instance, 'text', 'Расчет материалов'), 1)

============================================================
ФАЙЛ: screens\projects_screen.py
============================================================

# screens/projects_screen.py

from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.clock import Clock
from database import init_db, load_all_projects, save_project, delete_project, load_project
from kivy.uix.relativelayout import RelativeLayout


class ProjectsScreen(Screen):
    """Экран со списком проектов (плиточный интерфейс)"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Инициализируем БД при запуске приложения
        init_db()

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # Заголовок
        toolbar = self.create_toolbar()

        # Основная область с проектами
        content_area = self.create_content_area()

        main_layout.add_widget(toolbar)
        main_layout.add_widget(content_area)
        self.add_widget(main_layout)

        self.bind(size=self.on_size)

        # ← КРИТИЧНО: Инициализируем пустым списком
        self.projects = []

        # ← КРИТИЧНО: Убираем загрузку из __init__ - будем грузить только в on_pre_enter
        # Clock.schedule_once(lambda dt: self.load_projects(), 0.1)  # УДАЛИТЬ ЭТУ СТРОКУ

    def on_pre_enter(self):
        """← КРИТИЧНО: Загружаем проекты КАЖДЫЙ раз при входе на экран"""
        # Отменяем предыдущие запланированные загрузки чтобы избежать дублей
        Clock.unschedule(lambda dt: self.load_projects())
        Clock.schedule_once(lambda dt: self.load_projects(), 0.1)

    def on_size(self, *args):
        """Обновляет размеры плиток при изменении размера окна"""
        if hasattr(self, 'projects_container'):
            # ← КРИТИЧНО: Отменяем предыдущие вызовы чтобы избежать множественных обновлений
            Clock.unschedule(lambda dt: self.update_projects_grid())
            Clock.schedule_once(lambda dt: self.update_projects_grid(), 0.1)

    def create_toolbar(self):
        """Создает панель инструментов"""
        toolbar = BoxLayout(
            size_hint=(1, 0.15),
            padding=dp(10),
            spacing=dp(10)
        )

        # Кнопка "Назад" на главный экран
        btn_back = Button(
            text='← Назад',
            font_size=dp(16),
            size_hint=(0.3, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # Заголовок
        title = Label(
            text='Мои проекты',
            font_size=dp(20),
            size_hint=(0.4, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle'
        )
        title.bind(size=title.setter('text_size'))

        # Кнопка "Добавить проект" с переносом текста
        btn_add = Button(
            text='+ Новый\nпроект',
            font_size=dp(14),
            size_hint=(0.3, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        btn_add.bind(on_press=self.show_add_project_dialog)

        def update_btn_text(instance, size):
            instance.text_size = (size[0] - dp(10), None)
        btn_add.bind(size=update_btn_text)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(title)
        toolbar.add_widget(btn_add)

        return toolbar

    def create_content_area(self):
        """Создает область с плитками проектов"""
        self.projects_container = GridLayout(
            cols=2,
            spacing=dp(10),
            padding=dp(10),
            size_hint_y=None
        )
        self.projects_container.bind(
            minimum_height=self.projects_container.setter('height'))

        scroll = ScrollView()
        scroll.add_widget(self.projects_container)

        return scroll

    def load_projects(self):
        """Загружает проекты из базы данных"""
        # ← КРИТИЧНО: Очищаем список перед загрузкой
        self.projects = []

        db_projects = load_all_projects()
        if db_projects:
            self.projects = db_projects

        # ← КРИТИЧНО: Обновляем сетку
        self.update_projects_grid()

    def update_projects_grid(self):
        """Обновляет сетку проектов"""
        # ← КРИТИЧНО: Очищаем контейнер ПЕРЕД добавлением новых виджетов
        if hasattr(self, 'projects_container'):
            self.projects_container.clear_widgets()

        # Устанавливаем параметры сетки
        if hasattr(self, 'projects_container'):
            self.projects_container.cols = 2
            self.projects_container.spacing = dp(10)
            self.projects_container.padding = dp(10)

        # Добавляем плитки проектов
        for project in self.projects:
            project_tile = self.create_project_tile(project)
            if hasattr(self, 'projects_container'):
                self.projects_container.add_widget(project_tile)

        # Автоматически устанавливаем высоту контейнера
        if hasattr(self, 'projects_container'):
            self.projects_container.height = self.projects_container.minimum_height

        # Если проектов нет
        if not self.projects and hasattr(self, 'projects_container'):
            empty_label = Label(
                text='Нет проектов\nНажмите "+ Новый проект"',
                font_size=dp(16),
                color=(0.5, 0.5, 0.5, 1),
                halign='center',
                valign='middle',
                size_hint_y=None
            )
            empty_label.bind(size=empty_label.setter('text_size'))
            empty_label.height = self.height * 0.3
            self.projects_container.add_widget(empty_label)
            self.projects_container.height = self.projects_container.minimum_height

    def create_project_tile(self, project):
        """Создает плитку для проекта с кнопкой удаления"""
        container_width = self.projects_container.width if self.projects_container.width > 0 else self.width
        tile_width = (container_width - dp(30)) / \
            2 if container_width > 0 else dp(150)

        tile_layout = RelativeLayout(
            size_hint=(None, None),
            size=(tile_width, tile_width)
        )

        # ← КРИТИЧНО: Загружаем проект с комнатами для расчета площади
        from models import CeilingLayout
        total_area = 0.0

        full_project = load_project(project.id) if project.id else None
        if full_project:
            for room in full_project.rooms:
                try:
                    if room.walls and len(room.walls) >= 3:
                        temp_layout = CeilingLayout(room)
                        temp_layout.calculate_layout()  # ← Вызываем для расчета площади!
                        total_area += temp_layout.room_area_sqm if hasattr(
                            temp_layout, 'room_area_sqm') else 0.0
                except Exception as e:
                    print(f"Ошибка расчета площади: {e}")
                    continue

        # Форматирование текста
        if total_area > 0:
            button_text = f"{project.name}\n{total_area:.1f} м²"
        else:
            button_text = project.name

        tile_button = Button(
            background_color=(0.95, 0.95, 0.95, 1),
            background_normal='',
            text=button_text,
            font_size=dp(16),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            text_size=(tile_width - dp(20), tile_width - dp(20)),
            shorten=False,
            max_lines=2
        )
        tile_button.bind(on_press=lambda instance,
                         p=project: self.open_project(p))

        # Кнопка удаления
        delete_container = BoxLayout(
            size_hint=(None, None),
            size=(dp(25), dp(25)),
            pos_hint={'right': 1, 'top': 1}
        )
        delete_button = Button(
            text='X',
            font_size=dp(12),
            size_hint=(1, 1),
            background_color=(0.8, 0.2, 0.2, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        delete_button.bind(on_press=lambda instance,
                           p_id=project.id: self.confirm_delete_project(p_id))
        delete_container.add_widget(delete_button)

        tile_layout.add_widget(tile_button)
        tile_layout.add_widget(delete_container)

        return tile_layout

    def confirm_delete_project(self, project_id):
        """Показывает диалог подтверждения удаления проекта."""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(10))
        message = Label(text='Вы точно хотите удалить?', font_size=dp(16))
        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.3))

        def do_delete(dt):
            success = delete_project(project_id)
            if success:
                self.load_projects()  # ← Перезагружаем список
                popup.dismiss()

        def cancel_delete(dt):
            popup.dismiss()

        btn_delete = Button(text='Удалить', background_color=(
            0.8, 0.2, 0.2, 1), color=(1, 1, 1, 1))
        btn_cancel = Button(text='Отмена')

        btn_delete.bind(on_press=do_delete)
        btn_cancel.bind(on_press=cancel_delete)

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_delete)
        content.add_widget(message)
        content.add_widget(btn_layout)

        popup = Popup(title='Подтверждение удаления',
                      content=content, size_hint=(0.6, 0.4))
        popup.open()

    def show_add_project_dialog(self, instance):
        """Показывает диалог добавления проекта"""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(20))
        label = Label(text='Название проекта:', font_size=dp(16))
        name_input = TextInput(
            multiline=False, font_size=dp(18), size_hint=(1, 0.4))
        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.4))

        btn_confirm = Button(text='Создать', background_color=(
            0.2, 0.6, 1, 1), color=(1, 1, 1, 1))
        btn_cancel = Button(text='Отмена')

        def create_project(inst):
            name = name_input.text.strip()
            if name:
                from models import Project
                project = Project(name)
                save_project(project)
                self.load_projects()  # ← Перезагружаем список
                popup.dismiss()

        btn_confirm.bind(on_press=create_project)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)
        content.add_widget(label)
        content.add_widget(name_input)
        content.add_widget(btn_layout)

        popup = Popup(title='Новый проект',
                      content=content, size_hint=(0.8, 0.4))
        popup.open()

    def open_project(self, project):
        """Открывает проект (переход к экрану комнат)"""
        self.manager.current_project = project
        self.manager.current = 'rooms'

    def go_back(self, instance):
        """Возврат на главный экран"""
        self.manager.current = 'main'

============================================================
ФАЙЛ: screens\room_editor.py
============================================================

# screens/room_editor.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from widgets.grid_widget import GridWidget
from database import save_project


class RoomEditorScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Основной контейнер
        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # Панель инструментов (8% высоты)
        toolbar = self.create_toolbar()

        # Область рисования (занимает всё доступное место)
        self.grid_widget = GridWidget(size_hint=(1, 1))
        self.grid_widget.scale = 0.5

        # Панель информации (7% высоты)
        info_panel = self.create_info_panel()

        # Собираем основной layout
        main_layout.add_widget(toolbar)
        main_layout.add_widget(self.grid_widget)
        main_layout.add_widget(info_panel)

        # Контейнер для масштабирования (поверх основного)
        scale_panel = self.create_scale_panel()

        # FloatLayout для наложения scale_panel поверх
        overlay = FloatLayout()
        overlay.add_widget(main_layout)
        overlay.add_widget(scale_panel)

        self.add_widget(overlay)
        self.update_info()

    def on_pre_enter(self):
        """Вызывается перед входом на экран - загружаем комнату"""
        current_room = self.manager.current_room
        if current_room:
            self.grid_widget.walls = current_room.walls.copy()
            if current_room.walls:
                last_wall = current_room.walls[-1]
                self.grid_widget.current_pos_cm = [last_wall[2], last_wall[3]]
                if hasattr(current_room, 'last_position') and current_room.last_position:
                    self.grid_widget.current_pos_cm = current_room.last_position
            else:
                self.grid_widget.current_pos_cm = [0, 0]
            self.grid_widget.canvas.clear()
            self.grid_widget.draw_editor()
            self.update_info()

    def create_toolbar(self):
        """Создает панель инструментов"""
        toolbar = BoxLayout(
            size_hint=(1, 0.14),
            spacing=dp(2),  # ← КРИТИЧНО: отступ между кнопками
            padding=dp(2)   # ← КРИТИЧНО: отступ по краям
        )

        # Стрелки (контейнер)
        self.arrows_container = BoxLayout(
            size_hint=(0.35, 1),  # ← Чуть уменьшили ширину
            spacing=dp(3),        # ← Отступ между стрелками
            padding=dp(3)
        )
        self.create_arrow_buttons()

        # Назад/Вперед
        undo_redo_container = BoxLayout(
            orientation='vertical',
            size_hint=(0.2, 1),
            spacing=dp(3),  # ← Отступ между кнопками
            padding=dp(2)
        )
        self.btn_undo = Button(
            text='Назад',
            font_size=dp(12),  # ← Чуть меньше шрифт
            size_hint=(1, 0.5),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        self.btn_undo.bind(on_press=self.undo_action)
        self.btn_redo = Button(
            text='Вперед',
            font_size=dp(12),
            size_hint=(1, 0.5),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        self.btn_redo.bind(on_press=self.redo_action)
        undo_redo_container.add_widget(self.btn_undo)
        undo_redo_container.add_widget(self.btn_redo)

        # Действия
        actions_container = BoxLayout(
            orientation='vertical',
            size_hint=(0.35, 1),  # ← Чуть уменьшили ширину
            spacing=dp(3),
            padding=dp(2)
        )
        btn_layout = Button(
            text='Раскладка',
            font_size=dp(12),
            size_hint=(1, 0.5)
        )
        btn_layout.bind(on_press=self.show_layout)
        btn_exit = Button(
            text='Выход',
            font_size=dp(12),
            size_hint=(1, 0.5)
        )
        btn_exit.bind(on_press=self.exit_editor)
        actions_container.add_widget(btn_layout)
        actions_container.add_widget(btn_exit)

        toolbar.add_widget(self.arrows_container)
        toolbar.add_widget(undo_redo_container)
        toolbar.add_widget(actions_container)

        return toolbar

    def create_scale_panel(self):
        scale_panel = BoxLayout(orientation='vertical', size_hint=(None, None), size=(
            dp(60), dp(120)), pos_hint={'right': 1, 'top': 0.85}, spacing=dp(5), padding=dp(5))
        btn_zoom_in = Button(text='+', font_size=dp(24), size_hint=(1, 0.5))
        btn_zoom_in.bind(on_press=self.zoom_in)
        btn_zoom_out = Button(text='-', font_size=dp(24), size_hint=(1, 0.5))
        btn_zoom_out.bind(on_press=self.zoom_out)
        scale_panel.add_widget(btn_zoom_in)
        scale_panel.add_widget(btn_zoom_out)
        return scale_panel

    def create_info_panel(self):
        info_panel = BoxLayout(size_hint=(1, 0.07), padding=dp(10))
        self.info_label = Label(
            text='Точка: (0, 0) см | Стены: 0 | Площадь: —',
            font_size=dp(12),
            color=(0, 0, 0, 1)
        )
        info_panel.add_widget(self.info_label)
        return info_panel

    def create_arrow_buttons(self):
        grid = GridLayout(cols=3, rows=3, spacing=dp(2))
        arrows = [
            ('↖', 'up_left'), ('^', 'up'), ('↗', 'up_right'),
            ('<-', 'left'), ('•', 'center'), ('->', 'right'),
            ('↙', 'down_left'), ('v', 'down'), ('↘', 'down_right')
        ]
        for symbol, direction in arrows:
            if direction == 'center':
                btn = Button(text=symbol, font_size=dp(
                    20), background_color=(0.8, 0.8, 0.8, 1), disabled=True)
            else:
                btn = Button(text=symbol, font_size=dp(
                    20), on_press=lambda instance, d=direction: self.start_add_wall(d))
            grid.add_widget(btn)
        self.arrows_container.clear_widgets()
        self.arrows_container.add_widget(grid)

    def start_add_wall(self, direction):
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(10))
        label = Label(text=f"Длина стены (см) в направлении {direction}:")
        length_input = TextInput(
            multiline=False, input_filter='int', text='100')
        btn_layout = BoxLayout(spacing=dp(10))
        btn_confirm = Button(text='Подтвердить')
        btn_cancel = Button(text='Отмена')

        def confirm(instance):
            try:
                length = int(length_input.text)
                if length > 0:
                    self.grid_widget.add_wall(direction, length)
                    self.update_info()
                    popup.dismiss()
            except ValueError:
                pass
        btn_confirm.bind(on_press=confirm)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())
        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)
        content.add_widget(label)
        content.add_widget(length_input)
        content.add_widget(btn_layout)
        popup = Popup(title='Ввод длины стены',
                      content=content, size_hint=(0.8, 0.3))
        popup.open()

    def update_info(self):
        """Обновляет информационную панель с площадью"""
        x, y = self.grid_widget.current_pos_cm
        walls_count = len(self.grid_widget.walls)

        # ← КРИТИЧНО: Расчет площади только если комната замкнута (3+ стены)
        room_area = 0.0
        if walls_count >= 3:
            try:
                from models import CeilingLayout, Room
                temp_room = Room("temp")
                temp_room.walls = self.grid_widget.walls.copy()
                temp_layout = CeilingLayout(temp_room)
                # ← КРИТИЧНО: Вызываем calculate_layout() для расчета площади!
                temp_layout.calculate_layout()
                room_area = temp_layout.room_area_sqm if hasattr(
                    temp_layout, 'room_area_sqm') else 0.0
            except Exception as e:
                print(f"Ошибка расчета площади: {e}")
                room_area = 0.0

        if room_area > 0:
            self.info_label.text = f'Точка: ({int(x)}, {int(y)}) см | Стены: {walls_count} | Площадь: {room_area:.1f} м²'
        else:
            self.info_label.text = f'Точка: ({int(x)}, {int(y)}) см | Стены: {walls_count} | Площадь: —'

    def undo_action(self, instance):
        if self.grid_widget.undo():
            self.update_info()
            # Активируем кнопку "Вперед" если есть что восстанавливать
            if self.grid_widget.redo_stack:
                self.btn_redo.disabled = False
                self.btn_redo.background_color = (0.2, 0.6, 1, 1)
            else:
                self.btn_redo.disabled = True
                self.btn_redo.background_color = (0.8, 0.8, 0.8, 1)

    def redo_action(self, instance):
        if self.grid_widget.redo():
            self.update_info()
            # Деактивируем кнопку "Вперед" если стек пуст
            if not self.grid_widget.redo_stack:
                self.btn_redo.disabled = True
                self.btn_redo.background_color = (0.8, 0.8, 0.8, 1)

    def zoom_in(self, instance):
        self.grid_widget.scale = min(1.0, self.grid_widget.scale + 0.1)
        self.grid_widget.canvas.clear()
        self.grid_widget.draw_editor()
        self.update_info()

    def zoom_out(self, instance):
        self.grid_widget.scale = max(0.1, self.grid_widget.scale - 0.1)
        self.grid_widget.canvas.clear()
        self.grid_widget.draw_editor()
        self.update_info()

    def show_layout(self, instance):
        current_room = self.manager.current_room
        if current_room:
            current_room.walls = self.grid_widget.walls.copy()
            current_room.last_position = self.grid_widget.current_pos_cm.copy()
            save_project(self.manager.current_project)
        self.manager.current = 'layout'

    def exit_editor(self, instance):
        current_room = self.manager.current_room
        if current_room:
            current_room.walls = self.grid_widget.walls.copy()
            current_room.last_position = self.grid_widget.current_pos_cm.copy()
            save_project(self.manager.current_project)
        self.manager.current = 'rooms'

============================================================
ФАЙЛ: screens\rooms_screen.py
============================================================

# screens/rooms_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.graphics import Color, Rectangle, Line
from kivy.clock import Clock
# Импортируем delete_room_from_project и load_project
from database import save_project, delete_room_from_project, load_project
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.relativelayout import RelativeLayout


class RoomsScreen(Screen):
    """Экран со списком комнат в проекте"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.title_label = None

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # Панель инструментов
        toolbar = self.create_toolbar()

        # Основная область с комнатами
        content_area = self.create_content_area()

        main_layout.add_widget(toolbar)
        main_layout.add_widget(content_area)
        self.add_widget(main_layout)
        self.bind(size=self.on_size)

    def on_size(self, *args):
        """Обновляет размеры плиток при изменении размера окна"""
        if hasattr(self, 'rooms_container') and len(self.rooms_container.children) > 0:
            # Пересчитываем размеры плиток при изменении размера окна
            Clock.schedule_once(lambda dt: self.update_rooms_grid(), 0.1)

    def on_pre_enter(self):
        """Вызывается перед входом на экран - перезагружаем проект и обновляем сетку."""
        if hasattr(self.manager, 'current_project') and self.manager.current_project:
            project_id = self.manager.current_project.id
            if project_id:
                from database import load_project
                loaded_project = load_project(project_id)
                if loaded_project:
                    self.manager.current_project = loaded_project
                    # ← КРИТИЧНО: Очищаем кэш площадей в проектах
                    if hasattr(self.manager, 'current_project') and self.manager.current_project:
                        for project in getattr(self.manager, '_all_projects', []):
                            if hasattr(project, '_cached_area'):
                                delattr(project, '_cached_area')
                    self.update_rooms_grid()

    def create_toolbar(self):
        """Создает панель инструментов"""
        toolbar = BoxLayout(
            size_hint=(1, 0.15),
            padding=dp(10),
            spacing=dp(10)  # ← КРИТИЧНО: отступ между кнопками
        )

        # Кнопка "Назад" к проектам
        btn_back = Button(
            text='← Назад',
            font_size=dp(14),
            size_hint=(0.3, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # Заголовок (будет обновляться)
        self.title_label = Label(
            text='Комнаты',
            font_size=dp(16),
            size_hint=(0.4, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle'
        )
        self.title_label.bind(size=self.title_label.setter('text_size'))

        # Кнопка "Добавить комнату" с переносом текста
        btn_add = Button(
            text='+ Новая\nкомната',
            font_size=dp(12),
            size_hint=(0.3, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        btn_add.bind(on_press=self.show_add_room_dialog)

        # Настраиваем перенос текста для кнопки
        def update_btn_text(instance, size):
            instance.text_size = (size[0] - dp(10), None)
        btn_add.bind(size=update_btn_text)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(self.title_label)
        toolbar.add_widget(btn_add)

        return toolbar

    def create_content_area(self):
        """Создает область с плитками комнат"""
        # Контейнер для сетки комнат
        self.rooms_container = GridLayout(
            cols=2,
            spacing=dp(10),
            padding=dp(10),
            size_hint_y=None
        )
        self.rooms_container.bind(
            minimum_height=self.rooms_container.setter('height'))

        # Скролл для контейнера
        scroll = ScrollView()
        scroll.add_widget(self.rooms_container)

        return scroll

    def update_rooms_grid(self):
        """Обновляет сетку комнат"""
        self.rooms_container.clear_widgets()
        project = self.manager.current_project
        
        if project:
            # ← КРИТИЧНО: Расчет общей площади для тулбара
            from models import CeilingLayout
            total_area = 0.0
            for room in project.rooms:
                try:
                    if room.walls and len(room.walls) >= 3:
                        temp_layout = CeilingLayout(room)
                        # ← КРИТИЧНО: Вызываем calculate_layout() для расчета площади!
                        temp_layout.calculate_layout()
                        total_area += temp_layout.room_area_sqm if hasattr(temp_layout, 'room_area_sqm') else 0.0
                except Exception as e:
                    print(f"Ошибка расчета площади: {e}")
                    continue
            
            # ← КРИТИЧНО: правильное форматирование заголовка
            if total_area > 0:
                self.title_label.text = f'Комнаты:\n{project.name}\n{total_area:.1f} м²'
            else:
                self.title_label.text = f'Комнаты:\n{project.name}'
            
            self.title_label.font_size = dp(14)
            self.title_label.halign = 'center'
            self.title_label.valign = 'middle'
            self.title_label.max_lines = 3
            self.title_label.text_size = (self.title_label.width, self.title_label.height * 3)
            
            # Параметры сетки
            self.rooms_container.cols = 2
            self.rooms_container.spacing = dp(10)
            self.rooms_container.padding = dp(10)
            
            # Добавляем плитки комнат
            for room in project.rooms:
                room_tile = self.create_room_tile(room)
                self.rooms_container.add_widget(room_tile)
            
            self.rooms_container.height = self.rooms_container.minimum_height
            
            # Если комнат нет
            if not project.rooms:
                empty_label = Label(
                    text='Нет комнат\nНажмите "+ Новая комната"',
                    font_size=dp(16),
                    color=(0.5, 0.5, 0.5, 1),
                    halign='center',
                    valign='middle',
                    size_hint_y=None
                )
                empty_label.bind(size=empty_label.setter('text_size'))
                empty_label.height = self.height * 0.3
                self.rooms_container.add_widget(empty_label)
                self.rooms_container.height = self.rooms_container.minimum_height

    def create_room_tile(self, room):
        """Создает плитку для комнаты с кнопкой удаления"""
        container_width = self.rooms_container.width if self.rooms_container.width > 0 else self.width
        tile_width = (container_width - dp(30)) / 2 if container_width > 0 else dp(150)
        
        tile_layout = RelativeLayout(
            size_hint=(None, None),
            size=(tile_width, tile_width)
        )
        
        # ← КРИТИЧНО: безопасный расчет площади комнаты
        from models import CeilingLayout
        room_area = 0.0
        if room.walls and len(room.walls) >= 3:
            try:
                temp_layout = CeilingLayout(room)
                # ← КРИТИЧНО: Вызываем calculate_layout() для расчета площади!
                temp_layout.calculate_layout()
                room_area = temp_layout.room_area_sqm if hasattr(temp_layout, 'room_area_sqm') else 0.0
            except Exception as e:
                print(f"Ошибка расчета площади: {e}")
                room_area = 0.0
        
        # ← КРИТИЧНО: правильное форматирование текста
        if room_area > 0:
            button_text = f"{room.name}\n{room_area:.1f} м²"
        else:
            button_text = room.name
        
        tile_button = Button(
            background_color=(0.95, 0.95, 0.95, 1),
            background_normal='',
            text=button_text,
            font_size=dp(16),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            text_size=(tile_width - dp(20), tile_width - dp(20)),
            shorten=False,
            max_lines=2
        )
        tile_button.bind(on_press=lambda instance, r=room: self.open_room_editor(r))
        
        # Кнопка удаления
        delete_container = BoxLayout(
            size_hint=(None, None),
            size=(dp(25), dp(25)),
            pos_hint={'right': 1, 'top': 1}
        )
        delete_button = Button(
            text='X',
            font_size=dp(12),
            size_hint=(1, 1),
            background_color=(0.8, 0.2, 0.2, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        delete_button.bind(on_press=lambda instance, r_id=room.id: self.confirm_delete_room(r_id))
        delete_container.add_widget(delete_button)
        
        tile_layout.add_widget(tile_button)
        tile_layout.add_widget(delete_container)
        return tile_layout

    def open_room_editor(self, room):
        """Открывает редактор комнаты"""
        self.manager.current_room = room
        # ← КРИТИЧНО: если комната уже имеет стены, пропускаем редактор
        if room.walls and len(room.walls) >= 3:
            self.manager.current = 'layout'
        else:
            self.manager.current = 'room_editor'

    def confirm_delete_room(self, room_id):
        """Показывает диалог подтверждения удаления комнаты."""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(10))
        message = Label(text='Вы точно хотите удалить?', font_size=dp(16))

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.3))

        def do_delete(dt):
            # Найдем комнату в списке объектов и удалим её
            room_to_remove = None
            for r in self.manager.current_project.rooms:
                if r.id == room_id:
                    room_to_remove = r
                    break
            if room_to_remove:
                self.manager.current_project.rooms.remove(room_to_remove)
                # Сохраняем проект (это удалит комнату из БД)
                save_project(self.manager.current_project)

                # КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ: перезагружаем проект из БД для актуализации данных
                if self.manager.current_project.id:
                    updated_project = load_project(
                        self.manager.current_project.id)
                    if updated_project:
                        self.manager.current_project = updated_project

                print(
                    f"Комната с ID {room_id} удалена из проекта и сохранена в БД.")
                # Обновляем сетку
                self.update_rooms_grid()
                popup.dismiss()  # <-- ВАЖНО: добавлено закрытие popup
            else:
                print(
                    f"Комната с ID {room_id} не найдена в локальном списке проекта для удаления.")
                popup.dismiss()  # <-- ВАЖНО: добавлено закрытие popup

        def cancel_delete(dt):
            popup.dismiss()

        btn_delete = Button(text='Удалить', background_color=(
            0.8, 0.2, 0.2, 1), color=(1, 1, 1, 1))
        btn_cancel = Button(text='Отмена')

        btn_delete.bind(on_press=do_delete)
        btn_cancel.bind(on_press=cancel_delete)

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_delete)

        content.add_widget(message)
        content.add_widget(btn_layout)

        popup = Popup(title='Подтверждение удаления',
                      content=content,
                      size_hint=(0.6, 0.4))
        popup.open()

    def show_add_room_dialog(self, instance):
        """Показывает диалог добавления комнаты"""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(20))

        label = Label(text='Название комнаты:', font_size=dp(16))
        name_input = TextInput(
            multiline=False,
            font_size=dp(18),
            size_hint=(1, 0.4)
        )

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.4))

        btn_confirm = Button(
            text='Создать',
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        btn_cancel = Button(text='Отмена')

        def create_room(inst):
            name = name_input.text.strip()
            if name:
                from models import Room
                room = Room(name)
                # Добавляем комнату в текущий проект
                self.manager.current_project.rooms.append(room)
                # Сохраняем проект в БД после добавления комнаты
                save_project(self.manager.current_project)

                # КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ: перезагружаем проект из БД, чтобы получить актуальные ID комнат
                if self.manager.current_project.id:
                    updated_project = load_project(
                        self.manager.current_project.id)
                    if updated_project:
                        self.manager.current_project = updated_project

                # Обновляем сетку
                self.update_rooms_grid()
                popup.dismiss()

        btn_confirm.bind(on_press=create_room)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)

        content.add_widget(label)
        content.add_widget(name_input)
        content.add_widget(btn_layout)

        popup = Popup(
            title='Новая комната',
            content=content,
            size_hint=(0.8, 0.4)
        )
        popup.open()

    def go_back(self, instance):
        """Возврат к проектам"""
        # Сохраняем проект при выходе с экрана комнат (если нужно)
        # save_project(self.manager.current_project)
        self.manager.current = 'projects'

============================================================
ФАЙЛ: utils\__init__.py
============================================================



============================================================
ФАЙЛ: widgets\__init__.py
============================================================



============================================================
ФАЙЛ: widgets\grid_widget.py
============================================================

from kivy.uix.widget import Widget
from kivy.graphics import Color, Line, Rectangle, Ellipse, Mesh
from kivy.properties import NumericProperty, ListProperty, BooleanProperty  # ← Добавили BooleanProperty
from kivy.metrics import dp
import math


class GridWidget(Widget):
    """Виджет для отображения масштабируемой сетки"""
    scale = NumericProperty(0.2)
    offset_x = NumericProperty(0)
    offset_y = NumericProperty(0)
    room_points = ListProperty([])
    room_closed = BooleanProperty(False)  # ← НОВОЕ: Флаг замкнутости комнаты
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Текущая позиция (в сантиметрах)
        self.current_pos_cm = [0, 0]
        # Список стен
        self.walls = []
        # История для отмены
        self.undo_stack = []
        self.redo_stack = []
        # ← КРИТИЧНО: Флаг чтобы избежать двойного сохранения
        self._saving_state = False
        # Для перетаскивания (panning)
        self.dragging = False
        self.last_touch_pos = None
        self.touches = {}
        self.pinch_start_distance = None
        self.pinch_start_scale = None
        self.pinch_center = None
        # Для обработки клика на линию-доводчик
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []
        # Цвета
        self.bg_color = (0.12, 0.13, 0.13, 1)
        self.wall_color = (0.94, 0.96, 0.98, 1)
        self.point_color = (0.94, 0.96, 0.98, 1)
        self.room_color = (0.32, 0.38, 0.42, 1)
        self.closing_line_color = (0.79, 0.84, 0.87, 1)
        # Центрируем камеру
        self.center_camera()
        # Сначала рисуем
        self.draw_editor()
        # Привязываем обновление при изменении размера
        self.bind(size=self._update_canvas)
        # ← КРИТИЧНО: Сохраняем начальное состояние
        self.save_state()

    def center_camera(self):
        """Центрирует камеру на точке (0,0)"""
        if self.width > 0 and self.height > 0:
            self.offset_x = self.width / 2
            self.offset_y = self.height / 2

    def _update_canvas(self, *args):
        # Центрируем камеру при первом изменении размера
        if self.offset_x == 0 and self.offset_y == 0:
            self.center_camera()
        self.canvas.clear()
        self.draw_editor()

    def cm_to_px(self, cm_x, cm_y):
        """Конвертирует сантиметры в пиксели"""
        px_x = self.offset_x + cm_x * self.scale
        px_y = self.offset_y + cm_y * self.scale
        return px_x, px_y

    def draw_editor(self):
        """Рисует редактор комнаты"""
        self.canvas.clear()
        with self.canvas:
            # Темный фон
            Color(*self.bg_color)
            Rectangle(pos=self.pos, size=self.size)
            # ← КРИТИЧНО: Рисуем заливку ТОЛЬКО если комната замкнута
            if len(self.walls) >= 3 and self.room_closed:
                self.draw_room_fill()
            # Рисуем стены
            self.draw_walls()
            # Рисуем размеры стен
            self.draw_wall_dimensions()
            # Рисуем текущую точку
            self.draw_current_point()
            # Рисуем линию-доводчик
            if len(self.walls) >= 3 and not self.room_closed:
                self.draw_closing_line()

    def draw_closing_line(self):
        """Рисует линию, соединяющую первую и последнюю точку"""
        if len(self.walls) < 3:
            return

        # Берем первую точку первой стены и последнюю точку последней стены
        first_wall = self.walls[0]
        last_wall = self.walls[-1]

        # Первая точка: начало первой стены
        x1, y1 = first_wall[0], first_wall[1]
        # Последняя точка: конец последней стены
        x2, y2 = last_wall[2], last_wall[3]

        # Проверяем, не совпадают ли точки (если комната уже замкнута)
        if abs(x1 - x2) < 0.1 and abs(y1 - y2) < 0.1:
            return

        # Сохраняем координаты линии-доводчика для обработки кликов
        self.closing_line_start = (x1, y1)
        self.closing_line_end = (x2, y2)

        # Преобразуем в пиксели для отрисовки
        px1 = self.cm_to_px(x1, y1)
        px2 = self.cm_to_px(x2, y2)

        # Сохраняем точки линии в пикселях
        self.closing_line_points = [px1[0], px1[1], px2[0], px2[1]]

        # Цвет для линии соединения
        Color(*self.closing_line_color)

        # Рисуем пунктирную линию
        Line(points=self.closing_line_points,
             width=2, dash_length=10, dash_offset=5)

    def point_to_line_distance(self, px, py, x1, y1, x2, y2):
        """Вычисляет расстояние от точки до линии"""
        # Если линия вырождена в точку
        if x1 == x2 and y1 == y2:
            return math.sqrt((px - x1)**2 + (py - y1)**2)

        # Вектор линии
        line_vec_x = x2 - x1
        line_vec_y = y2 - y1

        # Вектор от начала линии до точки
        point_vec_x = px - x1
        point_vec_y = py - y1

        # Длина линии
        line_len = math.sqrt(line_vec_x**2 + line_vec_y**2)

        # Единичный вектор линии
        if line_len > 0:
            line_vec_x /= line_len
            line_vec_y /= line_len

        # Проекция вектора точки на линию
        projection_length = point_vec_x * line_vec_x + point_vec_y * line_vec_y

        # Ограничиваем проекцию длиной линии
        projection_length = max(0, min(line_len, projection_length))

        # Ближайшая точка на линии
        closest_x = x1 + projection_length * line_vec_x
        closest_y = y1 + projection_length * line_vec_y

        # Расстояние от точки до ближайшей точки на линии
        return math.sqrt((px - closest_x)**2 + (py - closest_y)**2)

    def draw_room_fill(self):
        """Правильная заливка внутренней области комнаты (только для замкнутых)"""
        if len(self.walls) < 3 or not self.room_closed:
            return
        # Собираем точки в правильном порядке
        points = []
        if self.walls:
            points.append((self.walls[0][0], self.walls[0][1]))
            for wall in self.walls:
                points.append((wall[2], wall[3]))
        # Замыкаем полигон
        if points[-1] != points[0]:
            points.append(points[0])
        if len(points) < 4:
            return
        # Преобразуем точки в экранные координаты
        screen_points = []
        for x, y in points:
            px = self.cm_to_px(x, y)
            screen_points.extend([px[0], px[1]])
        if len(screen_points) < 8:
            return
        with self.canvas:
            Color(*self.room_color)
            # ← КРИТИЧНО: Триангуляция "веером" от первой точки
            vertices = []
            indices = []
            anchor_x = screen_points[0]
            anchor_y = screen_points[1]
            for i in range(2, len(screen_points) - 2, 2):
                vertices.extend([anchor_x, anchor_y, 0, 0])
                vertices.extend([screen_points[i], screen_points[i+1], 0, 0])
                vertices.extend([screen_points[i+2], screen_points[i+3], 0, 0])
            indices = list(range(len(vertices) // 4))
            if vertices:
                Mesh(vertices=vertices, indices=indices, mode='triangles')

    def draw_walls(self):
        """Рисует стены комнаты"""
        if not self.walls:
            return

        Color(*self.wall_color)
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            Line(points=[px1[0], px1[1], px2[0], px2[1]], width=3)

    def draw_current_point(self):
        """Рисует текущую точку"""
        x, y = self.current_pos_cm
        px_x, px_y = self.cm_to_px(x, y)

        Color(*self.point_color)
        Ellipse(pos=(px_x - 6, px_y - 6), size=(12, 12))

    def save_state(self):
        """Сохраняет текущее состояние для отмены"""
        # ← КРИТИЧНО: Защита от двойного сохранения
        if self._saving_state:
            return
        self._saving_state = True
        state = {
            'walls': [w[:] for w in self.walls],
            'current_pos': self.current_pos_cm[:],
            'room_closed': self.room_closed  # ← Сохраняем флаг замкнутости
        }
        self.undo_stack.append(state)
        # При новом действии очищаем стек повторения
        self.redo_stack = []
        self._saving_state = False

    def restore_state(self, index):
        """Восстанавливает состояние из истории"""
        if 0 <= index < len(self.history):
            state = self.history[index]
            self.walls = [w[:] for w in state['walls']]
            self.current_pos_cm = state['current_pos'][:]
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def undo(self):
        """Отменяет последнее действие"""
        # ← КРИТИЧНО: Нужно минимум 2 состояния (текущее + предыдущее)
        if len(self.undo_stack) > 1:
            # Сохраняем текущее состояние для redo
            current_state = self.undo_stack.pop()
            self.redo_stack.append(current_state)
            # Восстанавливаем предыдущее состояние
            prev_state = self.undo_stack[-1]
            self.walls = [w[:] for w in prev_state['walls']]
            self.current_pos_cm = prev_state['current_pos'][:]
            # ← КРИТИЧНО: Восстанавливаем флаг замкнутости
            self.room_closed = prev_state.get('room_closed', False)
            # Перерисовываем
            self.canvas.clear()
            self.draw_editor()
            return True
        return False
    
    def redo(self):
        """Повторяет отмененное действие"""
        if self.redo_stack:
            # Берем состояние для повтора
            state = self.redo_stack.pop()
            self.undo_stack.append(state)
            # Восстанавливаем состояние
            self.walls = [w[:] for w in state['walls']]
            self.current_pos_cm = state['current_pos'][:]
            # ← КРИТИЧНО: Восстанавливаем флаг замкнутости
            self.room_closed = state.get('room_closed', False)
            # Перерисовываем
            self.canvas.clear()
            self.draw_editor()
            return True
        return False
    
    
    def add_wall(self, direction, length_cm):
        """Добавляет стену в указанном направлении"""
        # ← КРИТИЧНО: Сохраняем состояние ПЕРЕД изменением (только один раз!)
        self.save_state()
        # ← КРИТИЧНО: Если комната была замкнута, размыкаем её при добавлении стены
        self.room_closed = False
        # Очищаем линию-доводчик
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []
        x1, y1 = self.current_pos_cm
        # Для диагональных направлений корректируем длину
        if direction in ['up_left', 'up_right', 'down_left', 'down_right']:
            component_length = length_cm / math.sqrt(2)
        else:
            component_length = length_cm
        if direction == 'up':
            x2, y2 = x1, y1 + component_length
        elif direction == 'down':
            x2, y2 = x1, y1 - component_length
        elif direction == 'left':
            x2, y2 = x1 - component_length, y1
        elif direction == 'right':
            x2, y2 = x1 + component_length, y1
        elif direction == 'up_left':
            x2, y2 = x1 - component_length, y1 + component_length
        elif direction == 'up_right':
            x2, y2 = x1 + component_length, y1 + component_length
        elif direction == 'down_left':
            x2, y2 = x1 - component_length, y1 - component_length
        elif direction == 'down_right':
            x2, y2 = x1 + component_length, y1 - component_length
        else:
            self.undo_stack.pop()
            return
        self.walls.append([x1, y1, x2, y2])
        self.current_pos_cm = [x2, y2]
        self.canvas.clear()
        self.draw_editor()
        return (x2, y2)

    def reset(self):
        """Сбрасывает редактор"""
        self.current_pos_cm = [0, 0]
        self.walls = []
        self.history = []
        self.history_index = -1
        self.saved_for_redo = []
        self.save_state()
        self.canvas.clear()
        self.draw_editor()

    def add_closing_wall(self):
        """Добавляет стену, замыкающую комнату"""
        if len(self.walls) < 3 or not self.closing_line_start or not self.closing_line_end:
            return
        # ← КРИТИЧНО: Сохраняем состояние ПЕРЕД изменением
        self.save_state()
        # Добавляем стену от последней точки к первой
        x1, y1 = self.closing_line_end
        x2, y2 = self.closing_line_start
        self.walls.append([x1, y1, x2, y2])
        self.current_pos_cm = [x2, y2]
        # ← КРИТИЧНО: Помечаем комнату как замкнутую
        self.room_closed = True
        # Очищаем линию-доводчик
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []
        # Перерисовываем
        self.canvas.clear()
        self.draw_editor()
    

    def get_distance(self, touch1, touch2):
        """Расстояние между двумя точками касания"""
        return ((touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2) ** 0.5

    def get_center(self, touch1, touch2):
        """Центр между двумя точками касания"""
        return ((touch1.x + touch2.x) / 2, (touch1.y + touch2.y) / 2)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            if self.is_touch_on_closing_line(touch):
                self.add_closing_wall()
                return True  # Обработка завершена

            # Колесо мыши (оставляем для десктопа)
            if touch.is_mouse_scrolling:
                if touch.button == 'scrolldown':
                    self.scale = max(0.1, self.scale - 0.05)
                elif touch.button == 'scrollup':
                    # Увеличен макс. масштаб до 3.0
                    self.scale = min(3.0, self.scale + 0.05)
                self.canvas.clear()
                self.draw_editor()
                return True

            # Начало пинч-жеста (2 пальца)
            self.touches[touch.id] = touch
            if len(self.touches) == 2:
                touches = list(self.touches.values())
                self.pinch_start_distance = self.get_distance(
                    touches[0], touches[1])
                self.pinch_start_scale = self.scale
                self.pinch_center = self.get_center(touches[0], touches[1])
                return True

            # Одиночное касание — панорамирование
            self.dragging = True
            self.last_touch_pos = (touch.x, touch.y)
            return True
        return super().on_touch_down(touch)

    def is_touch_on_closing_line(self, touch, tolerance=dp(10)):
        """Проверяет, находится ли касание рядом с линией-доводчиком."""
        if not self.closing_line_points or len(self.closing_line_points) != 4:
            return False

        x1, y1, x2, y2 = self.closing_line_points
        px, py = touch.pos

        # Вычисляем расстояние от точки до линии
        dist = self.point_to_line_distance(px, py, x1, y1, x2, y2)
        return dist < tolerance

    def on_touch_move(self, touch):
        if touch.id in self.touches and len(self.touches) == 2:
            # Пинч-масштабирование
            touches = list(self.touches.values())
            current_distance = self.get_distance(touches[0], touches[1])

            if self.pinch_start_distance:
                scale_factor = current_distance / self.pinch_start_distance
                new_scale = self.pinch_start_scale * scale_factor
                # Ограничение масштаба
                new_scale = max(0.1, min(3.0, new_scale))

                # Пересчитываем смещение относительно центра жеста
                if self.pinch_center:
                    old_center_x = (
                        self.pinch_center[0] - self.offset_x) / self.scale
                    old_center_y = (
                        self.pinch_center[1] - self.offset_y) / self.scale

                    self.scale = new_scale
                    self.offset_x = self.pinch_center[0] - \
                        old_center_x * self.scale
                    self.offset_y = self.pinch_center[1] - \
                        old_center_y * self.scale

                self.canvas.clear()
                self.draw_editor()
                return True

        # Обработка панорамирования (один палец)
        if self.dragging and self.last_touch_pos:
            dx = touch.x - self.last_touch_pos[0]
            dy = touch.y - self.last_touch_pos[1]
            self.offset_x += dx
            self.offset_y += dy
            self.last_touch_pos = (touch.x, touch.y)
            self.canvas.clear()
            self.draw_editor()
            return True

        return super().on_touch_move(touch)

    def on_touch_up(self, touch):
        self.touches.pop(touch.id, None)
        self.pinch_start_distance = None
        self.pinch_center = None
        self.dragging = False
        self.last_touch_pos = None
        return super().on_touch_up(touch)

    def format_dimension(self, length_cm):
        """Форматирует размер с пробелом как разделителем тысяч"""
        return f"{int(length_cm):,}".replace(",", " ")

    def draw_wall_dimensions(self):
        """Рисует размеры стен с адаптивным шрифтом (как в раскладке)"""
        if not self.walls:
            return

        from kivy.core.text import Label as CoreLabel
        from kivy.graphics import Color, Rectangle
        import math

        for wall in self.walls:
            x1, y1, x2, y2 = wall
            length = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            dx = x2 - x1
            dy = y2 - y1
            length_wall = math.sqrt(dx**2 + dy**2)

            if length_wall > 0:
                nx = -dy / length_wall
                ny = dx / length_wall
                offset = 10
                text_x = mid_x + nx * offset
                text_y = mid_y + ny * offset
                px_x, px_y = self.cm_to_px(text_x, text_y)
                text = self.format_dimension(length) + " см"

                # ← КРИТИЧНО: Адаптивный размер шрифта как в layout_widget.py
                # Базовый размер = 60 см (как плитка) * масштаб
                base_font_px = 60 * self.scale
                # ← Коэффициент (можно настроить)
                font_size = base_font_px * 0.75

                # ← Ограничения для читаемости (как в раскладке)
                font_size = max(8, min(30, font_size))

                label = CoreLabel(
                    text=text,
                    font_size=font_size,  # ← Адаптивный!
                    color=(0, 0, 0, 1)
                )
                label.refresh()

                padding = 2
                Color(1, 1, 1, 0.7)
                Rectangle(
                    pos=(px_x - label.texture.size[0]/2 - padding,
                         px_y - label.texture.size[1]/2 - padding),
                    size=(label.texture.size[0] + padding*2,
                          label.texture.size[1] + padding*2)
                )

                Color(0, 0, 0, 1)
                Rectangle(
                    texture=label.texture,
                    pos=(px_x - label.texture.size[0]/2,
                         px_y - label.texture.size[1]/2),
                    size=label.texture.size
                )

============================================================
ФАЙЛ: widgets\layout_widget.py
============================================================

from kivy.uix.widget import Widget
from kivy.graphics import Color, Line, Rectangle, Mesh
from kivy.properties import NumericProperty, ObjectProperty, BooleanProperty
from kivy.metrics import dp
from kivy.core.text import Label as CoreLabel
from kivy.clock import Clock
from functools import partial
import math

class LayoutWidget(Widget):
    """Виджет для отображения раскладки 60×60 см"""

    scale = NumericProperty(0.3)
    offset_x = NumericProperty(0)
    offset_y = NumericProperty(0)
    grid_offset_x = NumericProperty(0)  # Смещение сетки (0-59 см)
    grid_offset_y = NumericProperty(0)
    on_grid_move = ObjectProperty(None)  # Callback для обновления статистики
    dragging_enabled = BooleanProperty(True)
    show_dimensions = BooleanProperty(True)
    show_wall_dimensions = BooleanProperty(True)  # ← НОВОЕ: Размеры стен

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Данные комнаты
        self.walls = []
        self.layout = None
        self.room_bounds = None  # Границы комнаты
        self.is_rotated = False  # Флаг поворота
        self.rotation_angle = 0  # Угол поворота
        self.redraw_scheduled = False
        self.last_redraw_time = 0
        self.dragging_enabled = True
        self.panning = False  # Для режима панорамирования
        self.last_pan_pos = None

        # Для перетаскивания
        self.dragging = False
        self.last_touch_pos = None

        self.touches = {}
        self.pinch_start_distance = None
        self.pinch_start_scale = None
        self.pinch_center = None

        # Цвета согласно редактору
        self.bg_color = (0.12, 0.13, 0.13, 1)      # #1e2022 - темный фон
        self.wall_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - светлые стены
        # #52616b - серый для заполненной комнаты
        self.room_color = (0.32, 0.38, 0.42, 1)
        self.grid_color = (0.79, 0.84, 0.87, 0.7)  # #c9d6df - цвет сетки
        self.full_tile_color = (0.9, 0.9, 0.9, 0.3)  # Цвет целых плиток
        self.cut_tile_color = (0.7, 0.7, 0.7, 0.3)   # Цвет резаных плиток
        self.text_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - цвет текста

        self.bind(size=self._update_canvas)

    def _update_canvas(self, *args):
        """Обновляет канвас при изменении размера виджета"""
        try:
            if hasattr(self, 'room_bounds') and self.room_bounds:
                # Пересчитываем позицию при изменении размера
                self.center_room()

            if hasattr(self, 'draw_layout'):
                self.draw_layout()
        except Exception as e:
            print(f"Ошибка при обновлении канваса: {e}")

    def set_room(self, walls):
        """Устанавливает стены комнаты и центрирует ее на экране"""
        self.walls = walls
        if not walls:
            return

        # Находим границы комнаты
        all_x = []
        all_y = []
        for wall in walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        if not all_x or not all_y:
            return

        self.room_bounds = {
            'min_x': min(all_x), 'max_x': max(all_x),
            'min_y': min(all_y), 'max_y': max(all_y)
        }

        # Центрируем комнату
        self.center_room()

        # Сбрасываем смещение сетки в 0 для правильного начала
        self.grid_offset_x = 0
        self.grid_offset_y = 0

        self.draw_layout()

    def center_room(self):
        """Центрирует комнату в рабочей области с учетом тулбаров"""
        if not self.room_bounds:
            return

        min_x, max_x = self.room_bounds['min_x'], self.room_bounds['max_x']
        min_y, max_y = self.room_bounds['min_y'], self.room_bounds['max_y']

        room_width = max_x - min_x
        room_height = max_y - min_y

        # Защита от нулевых размеров
        if room_width <= 0:
            room_width = 10
        if room_height <= 0:
            room_height = 10

        # Вычисляем масштаб с учетом отступов
        # Учитываем, что верхний тулбар = 10%, нижние панели = 10% (итого 80% доступно)
        # 12% сверху (дополнительный отступ для верхнего тулбара)
        padding_top = 0.12
        padding_bottom = 0.12  # 8% снизу (меньше, чем сверху)
        padding_sides = 0.10  # 10% с каждой стороны

        available_height = self.height * (1 - padding_top - padding_bottom)
        available_width = self.width * (1 - 2 * padding_sides)

        scale_x = available_width / room_width if room_width > 0 else 0.3
        scale_y = available_height / room_height if room_height > 0 else 0.3

        # Используем минимальный масштаб для вписывания
        self.scale = min(scale_x, scale_y)

        # Ограничиваем масштаб
        self.scale = max(0.1, min(self.scale, 1.0))

        # Центрируем комнату с учетом отступов
        room_center_x = (min_x + max_x) / 2
        room_center_y = (min_y + max_y) / 2

        widget_center_x = self.width / 2
        widget_center_y = self.height / 2

        self.offset_x = widget_center_x - room_center_x * self.scale
        self.offset_y = widget_center_y - room_center_y * self.scale

        # Корректируем по Y, чтобы учесть разные отступы сверху и снизу
        bottom_bound = self.offset_y + min_y * self.scale
        top_bound = self.offset_y + max_y * self.scale

        # Устанавливаем минимальные отступы от границ
        min_top_padding = self.height * padding_top
        min_bottom_padding = self.height * padding_bottom

        # Если комната выходит за верхний отступ
        if top_bound > self.height - min_top_padding:
            self.offset_y -= (top_bound - (self.height - min_top_padding))

        # Если комната выходит за нижний отступ
        if bottom_bound < min_bottom_padding:
            self.offset_y += (min_bottom_padding - bottom_bound)

    def cm_to_px(self, cm_x, cm_y):
        """Конвертирует сантиметры в пиксели"""
        # БЕЗ ПОВОРОТА - просто масштабирование и смещение
        px_x = self.offset_x + cm_x * self.scale
        px_y = self.offset_y + cm_y * self.scale
        return px_x, px_y

    def draw_layout(self):
        self.canvas.clear()
        
        with self.canvas:
            # Темный фон
            Color(*self.bg_color)
            Rectangle(pos=self.pos, size=self.size)
            
            # 1. Рисуем заполнение комнаты
            self.draw_room_fill()
            
            # 2. Рисуем плитки сетки 60×60
            self.draw_grid_tiles()
            
            # 3. Рисуем стены комнаты поверх
            self.draw_walls()
            
            # ← 4. Рисуем размеры стен (ОТДЕЛЬНЫЙ флаг!)
            if self.show_wall_dimensions:
                self.draw_wall_dimensions()
            
            # 5. Рисуем цифры ТОЛЬКО если включено
            if self.show_dimensions:
                self.draw_all_cut_dimensions()

    def draw_wall_dimensions(self):
        """Рисует размеры стен с отступом 1 метр и поворотом параллельно стене"""
        if not self.walls:
            return
        
        from kivy.graphics import PushMatrix, PopMatrix, Rotate
        
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            
            # Вычисляем длину стены
            length = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            
            # Середина стены
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            
            # ← Вычисляем угол стены в градусах
            dx = x2 - x1
            dy = y2 - y1
            angle_degrees = math.degrees(math.atan2(dy, dx))
            
            # ← Нормализуем угол для читаемости текста
            if angle_degrees > 90 or angle_degrees < -90:
                angle_degrees += 180
            
            # Нормаль к стене (перпендикуляр для отступа)
            length_wall = math.sqrt(dx**2 + dy**2)
            
            if length_wall > 0:
                # Нормализованный перпендикуляр
                nx = -dy / length_wall
                ny = dx / length_wall
                
                # ← Отступ 1 метр (100 см)
                offset = 100
                text_x = mid_x + nx * offset
                text_y = mid_y + ny * offset
                
                # Конвертируем в пиксели
                px_x, px_y = self.cm_to_px(text_x, text_y)
                
                # Форматируем текст с пробелом как разделителем тысяч
                text = f"{int(length):,}".replace(",", " ") + " см"
                
                # ← Адаптивный размер шрифта
                base_font_px = 60 * self.scale
                font_size = base_font_px * 0.75
                font_size = max(8, min(30, font_size))
                
                # Создаём метку с нормализованным углом
                label = CoreLabel(
                    text=text,
                    font_size=font_size,
                    color=(0, 0, 0, 1),
                    angle=angle_degrees  # ← Поворот параллельно стене!
                )
                label.refresh()
                
                # Полупрозрачный фон для читаемости
                padding = 4
                Color(1, 1, 1, 0.85)
                
                # Сохраняем матрицу трансформации
                PushMatrix()
                
                # Поворачиваем вокруг центра текста
                Rotate(
                    angle=angle_degrees,
                    origin=(px_x, px_y, 0)
                )
                
                # Рисуем фон (уже повернутый)
                Rectangle(
                    pos=(px_x - label.texture.size[0]/2 - padding,
                         px_y - label.texture.size[1]/2 - padding),
                    size=(label.texture.size[0] + padding*2,
                          label.texture.size[1] + padding*2)
                )
                
                # Текст поверх фона
                Color(0, 0, 0, 1)
                Rectangle(
                    texture=label.texture,
                    pos=(px_x - label.texture.size[0]/2,
                         px_y - label.texture.size[1]/2),
                    size=label.texture.size
                )
                
                # Восстанавливаем матрицу
                PopMatrix()

    def draw_all_cut_dimensions(self):
        """Рисуем размеры резаных плиток с центрированием и адаптивным масштабированием"""
        if not self.layout or not self.layout.tiles:
            return

        for tile in self.layout.tiles:
            if tile['type'] != 'cut':
                continue

            remaining_x = tile.get('cut_x', 60.0)
            remaining_y = tile.get('cut_y', 60.0)

            # Показываем только обрезанные стороны
            texts = []
            if remaining_x < 59.5:
                texts.append(f"{int(round(remaining_x))}")
            if remaining_y < 59.5:
                texts.append(f"{int(round(remaining_y))}")
            if not texts:
                continue

            text = f"{texts[0]}×{texts[1]}" if len(texts) == 2 else texts[0]

            # Центр плитки
            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            center_x = (x1 + x2) / 2
            center_y = (y1 + y2) / 2
            px_center = self.cm_to_px(center_x, center_y)

            # 🔑 КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: адаптивный размер шрифта в зависимости от длины текста
            tile_height_px = 60 * self.scale  # Высота плитки в пикселях

            # Для одиночных цифр — крупнее (70% высоты плитки)
            # Для двойных цифр ("45×36") — мельче (50% высоты плитки)
            # Это даёт визуально одинаковое заполнение пространства
            if '×' in text:
                font_scale = 0.30  # Двойные цифры — меньше шрифт
            else:
                font_scale = 0.50  # Одиночные цифры — крупнее

            font_size = tile_height_px * font_scale

            # Ограничиваем для читаемости и предотвращения перекрытия
            # 8px минимум, 30px максимум
            font_size = max(8, min(30, font_size))

            # Создаём текст
            label = CoreLabel(
                text=text,
                font_size=font_size,  # ← ЧИСЛО, не строка!
                color=self.text_color,
                bold=True
            )
            label.refresh()

            # Центрируем текст
            pos_x = px_center[0] - label.texture.size[0] / 2
            pos_y = px_center[1] - label.texture.size[1] / 2

            # 🔑 УМЕНЬШЕННЫЕ отступы фона (5% вместо 8%) — чтобы не выходил за границы плитки
            padding_x = label.texture.size[0] * 0.05
            padding_y = label.texture.size[1] * 0.05

            # Полупрозрачный фон с минимальными отступами
            Color(0, 0, 0, 0.3)
            Rectangle(
                pos=(pos_x - padding_x, pos_y - padding_y),
                size=(label.texture.size[0] + padding_x * 2,
                      label.texture.size[1] + padding_y * 2)
            )

            # Текст поверх фона
            Color(*self.text_color)
            Rectangle(
                texture=label.texture,
                pos=(pos_x, pos_y),
                size=label.texture.size
            )

    def draw_room_fill(self):
        """Правильная заливка внутренней области комнаты (Mesh вместо Stencil)"""
        if len(self.walls) < 3:
            return
        
        # Собираем точки в правильном порядке
        points = []
        if self.walls:
            points.append((self.walls[0][0], self.walls[0][1]))
            for wall in self.walls:
                points.append((wall[2], wall[3]))
        
        if points[-1] != points[0]:
            points.append(points[0])
        
        if len(points) < 4:
            return
        
        # Преобразуем точки в экранные координаты
        screen_points = []
        for x, y in points:
            px = self.cm_to_px(x, y)
            screen_points.extend([px[0], px[1]])
        
        if len(screen_points) < 8:
            return
        
        with self.canvas:
            Color(*self.room_color)
            
            # ← КРИТИЧНО: Используем Mesh с триангуляцией "веером" от первой точки
            vertices = []
            indices = []
            
            # Первая точка полигона (якорь)
            anchor_x = screen_points[0]
            anchor_y = screen_points[1]
            
            # Создаем треугольники от первой точки к каждой паре соседних точек
            for i in range(2, len(screen_points) - 2, 2):
                # Якорь (первая точка)
                vertices.extend([anchor_x, anchor_y, 0, 0])
                # Текущая точка
                vertices.extend([screen_points[i], screen_points[i+1], 0, 0])
                # Следующая точка
                vertices.extend([screen_points[i+2], screen_points[i+3], 0, 0])
            
            # Создаем индексы для треугольников
            indices = list(range(len(vertices) // 4))
            
            if vertices:
                Mesh(vertices=vertices, indices=indices, mode='triangles')
            
            # Рисуем контур поверх заливки
            Color(*self.wall_color)
            Line(points=screen_points, close=True, width=2)

    def draw_walls(self):
        """Рисует стены комнаты"""
        if not self.walls:
            return

        Color(*self.wall_color)
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            Line(points=[px1[0], px1[1], px2[0], px2[1]], width=3)

    def draw_grid_tiles(self):
        """Рисует сетку 60×60 в виде плиток (только внутри комнаты)"""
        if not self.layout or not self.layout.tiles:
            return

        # Рисуем заливку плиток
        for tile in self.layout.tiles:
            # Пропускаем плитки полностью вне комнаты
            if tile['type'] == 'outside':
                continue

            # Дополнительная проверка для резаных плиток: пропускаем если оба размера меньше 1 см
            if tile['type'] == 'cut':
                cut_x = tile.get('cut_x', 0)
                cut_y = tile.get('cut_y', 0)
                if cut_x < 1.0 and cut_y < 1.0:
                    continue

            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            # Рисуем заливку плитки
            if tile['type'] == 'full':
                Color(*self.full_tile_color)
                Rectangle(pos=px1, size=(px2[0]-px1[0], px2[1]-px1[1]))
            else:  # cut
                Color(*self.cut_tile_color)
                Rectangle(pos=px1, size=(px2[0]-px1[0], px2[1]-px1[1]))

        # Рисуем контуры плиток
        Color(*self.grid_color)
        for tile in self.layout.tiles:
            if tile['type'] == 'outside':
                continue
            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            # Рисуем контур плитки
            Line(rectangle=(px1[0], px1[1], px2[0] -
                 px1[0], px2[1] - px1[1]), width=1)

    # Добавляем новый метод для расчета процента отходов:

    def schedule_redraw(self):
        """Планирует перерисовку с задержкой"""
        if not self.redraw_scheduled:
            self.redraw_scheduled = True
            Clock.schedule_once(self.redraw_now, 0.05)  # 20 FPS

    def redraw_now(self, dt):
        """Выполняет перерисовку"""
        self.redraw_scheduled = False
        self.draw_layout()

    def move_grid(self, dx_cm, dy_cm):
        """Смещает сетку на указанное количество см"""
        self.grid_offset_x = (self.grid_offset_x + dx_cm) % 60
        self.grid_offset_y = (self.grid_offset_y + dy_cm) % 60

        # Вызываем callback для обновления статистики
        if self.on_grid_move:
            self.on_grid_move(self.grid_offset_x, self.grid_offset_y)

        # Используем оптимизированную перерисовку
        self.schedule_redraw()

    def zoom_at_center(self, zoom_in=True):
        """Масштабирует относительно центра виджета"""
        # Запоминаем центр виджета в мировых координатах
        center_world_x = (self.width / 2 - self.offset_x) / self.scale
        center_world_y = (self.height / 2 - self.offset_y) / self.scale

        # Изменяем масштаб
        if zoom_in:
            # Максимальный масштаб увеличен до 3.0x
            new_scale = min(3.0, self.scale + 0.05)
        else:
            new_scale = max(0.1, self.scale - 0.05)

        # Пересчитываем смещение, чтобы центр остался на месте
        new_offset_x = self.width / 2 - center_world_x * new_scale
        new_offset_y = self.height / 2 - center_world_y * new_scale

        # Применяем изменения
        self.scale = new_scale
        self.offset_x = new_offset_x
        self.offset_y = new_offset_y

        # Обновляем отображение
        self.apply_bounds_protection()
        self.canvas.clear()
        if hasattr(self, 'draw_editor'):
            self.draw_editor()
        else:
            self.draw_layout()

    def apply_bounds_protection(self):
        """Защищает от выхода комнаты за границы виджета"""
        if not self.room_bounds:
            return

        min_x = self.room_bounds['min_x']
        max_x = self.room_bounds['max_x']
        min_y = self.room_bounds['min_y']
        max_y = self.room_bounds['max_y']

        # Рассчитываем границы видимой области
        visible_min_x = (0 - self.offset_x) / self.scale
        visible_max_x = (self.width - self.offset_x) / self.scale
        visible_min_y = (0 - self.offset_y) / self.scale
        visible_max_y = (self.height - self.offset_y) / self.scale

        # Если комната выходит за левую границу
        if max_x < visible_min_x:
            self.offset_x += (visible_min_x - max_x) * self.scale
        # Если комната выходит за правую границу
        if min_x > visible_max_x:
            self.offset_x -= (min_x - visible_max_x) * self.scale
        # Если комната выходит за нижнюю границу
        if max_y < visible_min_y:
            self.offset_y += (visible_min_y - max_y) * self.scale
        # Если комната выходит за верхнюю границу
        if min_y > visible_max_y:
            self.offset_y -= (min_y - visible_max_y) * self.scale

    def get_distance(self, touch1, touch2):
        return ((touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2) ** 0.5

    def get_center(self, touch1, touch2):
        return ((touch1.x + touch2.x) / 2, (touch1.y + touch2.y) / 2)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            # Колесо мыши (оставляем для десктопа)
            if touch.is_mouse_scrolling:
                if touch.button == 'scrolldown':
                    self.scale = max(0.1, self.scale - 0.05)
                elif touch.button == 'scrollup':
                    self.scale = min(1.0, self.scale + 0.05)
                self.draw_layout()
                return True

            # Начало пинча
            self.touches[touch.id] = touch
            if len(self.touches) == 2:
                touches = list(self.touches.values())
                self.pinch_start_distance = self.get_distance(
                    touches[0], touches[1])
                self.pinch_start_scale = self.scale
                self.pinch_center = self.get_center(touches[0], touches[1])
                return True

            # Одиночное касание — перетаскивание или перемещение сетки
            if self.dragging_enabled:
                self.dragging = True
                self.last_touch_pos = touch.pos
            else:
                self.panning = True
                self.last_pan_pos = touch.pos
            return True

        return super().on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.id in self.touches and len(self.touches) == 2:
            # Пинч-масштабирование
            touches = list(self.touches.values())
            current_distance = self.get_distance(touches[0], touches[1])
            if self.pinch_start_distance:
                scale_factor = current_distance / self.pinch_start_distance
                new_scale = self.pinch_start_scale * scale_factor
                new_scale = max(0.1, min(2.0, new_scale))
                if self.pinch_center:
                    old_center_x = (
                        self.pinch_center[0] - self.offset_x) / self.scale
                    old_center_y = (
                        self.pinch_center[1] - self.offset_y) / self.scale
                    self.scale = new_scale
                    self.offset_x = self.pinch_center[0] - \
                        old_center_x * self.scale
                    self.offset_y = self.pinch_center[1] - \
                        old_center_y * self.scale
                    self.draw_layout()
            return True

        # Обработка перетаскивания (один палец)
        if self.dragging and self.dragging_enabled:
            dx_px = touch.x - self.last_touch_pos[0]
            dy_px = touch.y - self.last_touch_pos[1]
            # --- ИЗМЕНЕНИЕ ---
            # Округляем смещение до целых сантиметров перед добавлением
            dx_cm = round(dx_px / self.scale)
            dy_cm = round(dy_px / self.scale)
            # ---
            self.grid_offset_x += dx_cm
            self.grid_offset_y += dy_cm
            self.last_touch_pos = touch.pos
            if self.on_grid_move:
                self.on_grid_move()  # Вызов callback для обновления
            self.draw_layout()
            return True

        if self.panning and not self.dragging_enabled:
            dx = touch.x - self.last_pan_pos[0]
            dy = touch.y - self.last_pan_pos[1]
            self.offset_x += dx
            self.offset_y += dy
            self.last_pan_pos = touch.pos
            self.draw_layout()
            return True

        return super().on_touch_move(touch)

    def on_touch_up(self, touch):
        self.touches.pop(touch.id, None)
        self.pinch_start_distance = None
        self.pinch_center = None
        self.dragging = False
        self.panning = False
        self.last_touch_pos = None
        self.last_pan_pos = None
        return super().on_touch_up(touch)
