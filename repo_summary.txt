–†–ï–ü–û–ó–ò–¢–û–†–ò–ô: C:\Users\noize\Documents\ceiling_calculator
================================================================================

–°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–ê:
----------------------------------------
ceiling_calculator/
‚îú‚îÄ‚îÄ ceiling_calculator.db
‚îú‚îÄ‚îÄ database.py
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ models.py
‚îú‚îÄ‚îÄ repo_to_text.py
‚îú‚îÄ‚îÄ fonts/
‚îÇ   ‚îú‚îÄ‚îÄ DejaVuSans.ttf
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ layout_screen.py
‚îÇ   ‚îú‚îÄ‚îÄ main_screen.py
‚îÇ   ‚îú‚îÄ‚îÄ projects_screen.py
‚îÇ   ‚îú‚îÄ‚îÄ room_editor.py
‚îÇ   ‚îú‚îÄ‚îÄ rooms_screen.py
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ grid_widget.py
‚îÇ   ‚îú‚îÄ‚îÄ layout_widget.py

================================================================================


============================================================
–§–ê–ô–õ: main.py
============================================================

# main.py
from kivy.app import App
from kivy.uix.screenmanager import ScreenManager
from kivy.core.window import Window
from kivy.utils import get_color_from_hex
# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —ç–∫—Ä–∞–Ω—ã
from screens.main_screen import MainScreen
from screens.projects_screen import ProjectsScreen
from screens.rooms_screen import RoomsScreen
from screens.room_editor import RoomEditorScreen
from screens.layout_screen import LayoutScreen

import os
os.environ['KIVY_GL_BACKEND'] = 'angle_sdl2'

# –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∫–∞–∫ —É —Ç–µ–ª–µ—Ñ–æ–Ω–∞
Window.size = (360, 640)
Window.clearcolor = (1, 1, 1, 1)  # –ë–µ–ª—ã–π —Ñ–æ–Ω


class CeilingCalculatorApp(App):
    def build(self):
        # –°–æ–∑–¥–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä —ç–∫—Ä–∞–Ω–æ–≤ —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ —Å–≤–æ–π—Å—Ç–≤–∞–º–∏
        sm = ScreenManager()

        # –î–æ–±–∞–≤–ª—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–µ–∫—Ç –∏ –∫–æ–º–Ω–∞—Ç—É
        sm.current_project = None
        sm.current_room = None

        # –î–æ–±–∞–≤–ª—è–µ–º —ç–∫—Ä–∞–Ω—ã
        sm.add_widget(MainScreen(name='main'))
        sm.add_widget(ProjectsScreen(name='projects'))
        sm.add_widget(RoomsScreen(name='rooms'))
        sm.add_widget(RoomEditorScreen(name='room_editor'))
        sm.add_widget(LayoutScreen(name='layout'))  # –î–æ–±–∞–≤–ª—è–µ–º —ç–∫—Ä–∞–Ω —Ä–∞—Å–∫–ª–∞–¥–∫–∏
        Window.clearcolor = get_color_from_hex('#FFFFFF')
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∏–ª—å –¥–ª—è –∫–Ω–æ–ø–æ–∫
        self.theme_cls = type('Theme', (), {
            'primary_color': get_color_from_hex('#000000'),
            'text_color': get_color_from_hex('#000000')
        })

        return sm


if __name__ == '__main__':
    CeilingCalculatorApp().run()

============================================================
–§–ê–ô–õ: models.py
============================================================

# models.py (–∏–∑–º–µ–Ω–∏–º –∫–ª–∞—Å—Å Room)
import json
from datetime import datetime
import math

class Project:
    """–ö–ª–∞—Å—Å –ø—Ä–æ–µ–∫—Ç–∞ (–∑–¥–∞–Ω–∏—è/–æ–±—ä–µ–∫—Ç–∞)"""
    def __init__(self, name):
        self.id = None
        self.name = name
        self.created_at = datetime.now()
        self.rooms = []  # –°–ø–∏—Å–æ–∫ –æ–±—ä–µ–∫—Ç–æ–≤ Room

    def to_dict(self):
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –ø—Ä–æ–µ–∫—Ç –≤ —Å–ª–æ–≤–∞—Ä—å"""
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat(),
            'rooms': [room.to_dict() for room in self.rooms]
        }

    @classmethod
    def from_dict(cls, data):
        """–°–æ–∑–¥–∞–µ—Ç –ø—Ä–æ–µ–∫—Ç –∏–∑ —Å–ª–æ–≤–∞—Ä—è"""
        project = cls(data['name'])
        project.id = data['id']
        project.created_at = datetime.fromisoformat(data['created_at'])
        project.rooms = [Room.from_dict(room_data)
                         for room_data in data['rooms']]
        return project

class Room:
    """–ö–ª–∞—Å—Å –∫–æ–º–Ω–∞—Ç—ã"""
    def __init__(self, name):
        self.id = None
        self.name = name
        self.created_at = datetime.now()
        self.walls = []  # –°–ø–∏—Å–æ–∫ —Å—Ç–µ–Ω –≤ —Ñ–æ—Ä–º–∞—Ç–µ [[x1, y1, x2, y2], ...]
        self.last_position = None # –î–æ–±–∞–≤–ª–µ–Ω–æ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ

    def to_dict(self):
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç –∫–æ–º–Ω–∞—Ç—É –≤ —Å–ª–æ–≤–∞—Ä—å"""
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat(),
            'walls': self.walls,
            'last_position': self.last_position # –î–æ–±–∞–≤–ª–µ–Ω–æ
        }

    @classmethod
    def from_dict(cls, data):
        """–°–æ–∑–¥–∞–µ—Ç –∫–æ–º–Ω–∞—Ç—É –∏–∑ —Å–ª–æ–≤–∞—Ä—è"""
        room = cls(data['name'])
        room.id = data['id']
        room.created_at = datetime.fromisoformat(data['created_at'])
        room.walls = data['walls']
        room.last_position = data.get('last_position') # –î–æ–±–∞–≤–ª–µ–Ω–æ
        return room

# --- –û—Å—Ç–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å models.py –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ---
# (–ö–ª–∞—Å—Å CeilingLayout –∏ –µ–≥–æ –º–µ—Ç–æ–¥—ã)
class CeilingLayout:
    """–ö–ª–∞—Å—Å –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –ø–æ—Ç–æ–ª–∫–∞ 60√ó60 —Å–º"""
    TILE_SIZE = 60  # 60 —Å–º

    def __init__(self, room):
        self.room = room
        self.grid_offset_x = 0  # –°–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –ø–æ X (0-59 —Å–º)
        self.grid_offset_y = 0  # –°–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –ø–æ Y (0-59 —Å–º)
        self.tiles = []  # –°–ø–∏—Å–æ–∫ –ø–ª–∏—Ç–æ–∫
        self.full_tiles = 0
        self.cut_tiles = 0
        self.waste_percentage = 0 # –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç—Ö–æ–¥–æ–≤
        self.room_polygon = self._build_room_polygon()
        self.room_bounds = self.get_room_bounds()
        self.room_area_sqm = 0.0 # –ù–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è –ø–ª–æ—â–∞–¥–∏ –≤ –º¬≤

    def _build_room_polygon(self):
        """–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ —Å—Ç—Ä–æ–∏—Ç –ø–æ–ª–∏–≥–æ–Ω –∫–æ–º–Ω–∞—Ç—ã –æ–¥–∏–Ω —Ä–∞–∑"""
        if not self.room.walls:
            return []
        points = []
        for wall in self.room.walls:
            points.append((wall[0], wall[1]))
            points.append((wall[2], wall[3]))

        # –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ –∑–∞–º—ã–∫–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω
        unique_points = []
        for point in points:
            if point not in unique_points:
                unique_points.append(point)
        if unique_points and unique_points[0] != unique_points[-1]:
            unique_points.append(unique_points[0])
        return unique_points

    def calculate_layout(self):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫—É –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Å–º–µ—â–µ–Ω–∏—è —Å —É—á–µ—Ç–æ–º —Ä–µ–∞–ª—å–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∫–æ–º–Ω–∞—Ç—ã"""
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        self.tiles = []
        self.full_tiles = 0
        self.cut_tiles = 0
        if not self.room.walls:
            self.calculate_statistics()
            return

        # 1. –ù–∞—Ö–æ–¥–∏–º –í–°–ï –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø–ª–∏—Ç–∫–∏ –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π bounding box –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤—Å–µ—Ö –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏—Ö—Å—è –ø–ª–∏—Ç–æ–∫
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        min_x, max_x = min(all_x), max(all_x)
        min_y, max_y = min(all_y), max(all_y)

        # –†–∞—Å—à–∏—Ä—è–µ–º –ø–æ–∏—Å–∫ –Ω–∞ 60 —Å–º –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã
        search_min_x = min_x - 60
        search_max_x = max_x + 60
        search_min_y = min_y - 60
        search_max_y = max_y + 60

        # 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã —Å–µ—Ç–∫–∏
        grid_start_x = math.floor((search_min_x - self.grid_offset_x) /
                                  self.TILE_SIZE) * self.TILE_SIZE + self.grid_offset_x
        grid_start_y = math.floor((search_min_y - self.grid_offset_y) /
                                  self.TILE_SIZE) * self.TILE_SIZE + self.grid_offset_y

        # 3. –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–º –ø–ª–∏—Ç–∫–∞–º
        x = grid_start_x
        while x < search_max_x:
            y = grid_start_y
            while y < search_max_y:
                tile_x2 = x + self.TILE_SIZE
                tile_y2 = y + self.TILE_SIZE

                # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–ª–∏—Ç–∫—É —Å —É—á–µ—Ç–æ–º —Ä–µ–∞–ª—å–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏
                tile_info = self.analyze_tile(x, y, tile_x2, tile_y2)
                if tile_info['type'] != 'outside':
                    self.tiles.append(tile_info)
                    if tile_info['type'] == 'full':
                        self.full_tiles += 1
                    elif tile_info['type'] == 'cut':
                        self.cut_tiles += 1
                y += self.TILE_SIZE
            x += self.TILE_SIZE

        # 4. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        self.calculate_statistics()

    def analyze_tile(self, x1, y1, x2, y2):
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø–ª–∏—Ç–∫—É —Å —É—á–µ—Ç–æ–º —Ä–µ–∞–ª—å–Ω–æ–π –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∫–æ–º–Ω–∞—Ç—ã"""
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –±—ã—Å—Ç—Ä—ã–π –≤—ã—Ö–æ–¥ –ø–æ bounding box
        room_min_x, room_max_x, room_min_y, room_max_y = self.get_room_bounds()

        # –ï—Å–ª–∏ –ø–ª–∏—Ç–∫–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω–µ bounding box –∫–æ–º–Ω–∞—Ç—ã
        if x2 <= room_min_x or x1 >= room_max_x or y2 <= room_min_y or y1 >= room_max_y:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ª–Ω–æ—Å—Ç—å—é –ª–∏ –ø–ª–∏—Ç–∫–∞ –≤–Ω—É—Ç—Ä–∏ –∫–æ–º–Ω–∞—Ç—ã
        corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]
        corners_inside = sum(
            1 for corner in corners if self.is_point_inside_room(*corner))
        if corners_inside == 4:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'full', 'cut_x': 60, 'cut_y': 60}

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ª–Ω–æ—Å—Ç—å—é –ª–∏ –ø–ª–∏—Ç–∫–∞ —Å–Ω–∞—Ä—É–∂–∏ (–¥–∞–∂–µ –µ—Å–ª–∏ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç bounding box)
        if corners_inside == 0:
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–Ω—Ç—Ä–∞ –∏ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ç–æ—á–µ–∫
            test_points = [
                ((x1 + x2) / 2, (y1 + y2) / 2),  # –¶–µ–Ω—Ç—Ä
                (x1 + 20, y1 + 20), (x2 - 20, y2 - 20),  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
                (x1 + 20, y2 - 20), (x2 - 20, y1 + 20)
            ]
            points_inside = sum(
                1 for point in test_points if self.is_point_inside_room(*point))
            if points_inside == 0:
                return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–ª–µ–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è —Ä–µ–∑–∞–Ω–æ–π –ø–ª–∏—Ç–∫–∏
        useful_x, useful_y = self.calculate_cut_dimensions(x1, y1, x2, y2)

        # –ï—Å–ª–∏ –æ–±–∞ —Ä–∞–∑–º–µ—Ä–∞ –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–µ, —Å—á–∏—Ç–∞–µ–º –ø–ª–∏—Ç–∫—É —Å–Ω–∞—Ä—É–∂–∏
        if useful_x < 0.1 and useful_y < 0.1:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        return {
            'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2,
            'type': 'cut',
            'cut_x': max(0.1, useful_x),
            'cut_y': max(0.1, useful_y)
        }

    def get_room_bounds(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–º–Ω–∞—Ç—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏"""
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])
        return min(all_x), max(all_x), min(all_y), max(all_y)

    def calculate_cut_dimensions(self, x1, y1, x2, y2):
        """–¢–æ—á–Ω—ã–π —Ä–∞—Å—á–µ—Ç –ø–æ–ª–µ–∑–Ω—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ –ø–ª–∏—Ç–∫–∏ –¥–ª—è –ª—é–±—ã—Ö —Ñ–æ—Ä–º –∫–æ–º–Ω–∞—Ç"""
        # 1. –°–Ω–∞—á–∞–ª–∞ —Å–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Å—Ç–µ–Ω
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1_w, y1_w, x2_w, y2_w = wall
            all_x.extend([x1_w, x2_w])
            all_y.extend([y1_w, y2_w])

        if not all_x or not all_y:
            return 0.0, 0.0

        # 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–º–Ω–∞—Ç—ã
        room_min_x = min(all_x)
        room_max_x = max(all_x)
        room_min_y = min(all_y)
        room_max_y = max(all_y)

        # 3. –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–π (4 —Å—Ç–µ–Ω—ã —Å –ø—Ä—è–º—ã–º–∏ —É–≥–ª–∞–º–∏)
        is_rectangular = False
        if len(self.room.walls) == 4:
            corners = set()
            for wall in self.room.walls:
                corners.add((wall[0], wall[1]))
                corners.add((wall[2], wall[3]))
            if len(corners) == 4:
                corner_x = sorted(set([p[0] for p in corners]))
                corner_y = sorted(set([p[1] for p in corners]))
                if (len(corner_x) == 2 and len(corner_y) == 2 and
                    room_min_x in corner_x and room_max_x in corner_x and
                    room_min_y in corner_y and room_max_y in corner_y):
                    is_rectangular = True

        if is_rectangular:
            # –î–ª—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω—ã—Ö –∫–æ–º–Ω–∞—Ç –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—á–Ω—ã–π –º–µ—Ç–æ–¥ –∫–∞–∫ –≤ —Å—Ç–∞—Ä–æ–π –≤–µ—Ä—Å–∏–∏
            intersect_x1 = max(x1, room_min_x)
            intersect_y1 = max(y1, room_min_y)
            intersect_x2 = min(x2, room_max_x)
            intersect_y2 = min(y2, room_max_y)

            if intersect_x1 >= intersect_x2 or intersect_y1 >= intersect_y2:
                return 0.0, 0.0

            # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ —Ü–µ–ª—ã—Ö —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–æ–≤ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –Ω–µ—Ç–æ—á–Ω–æ—Å—Ç–µ–π
            useful_x = round(intersect_x2 - intersect_x1)
            useful_y = round(intersect_y2 - intersect_y1)
            return max(0.0, min(60.0, useful_x)), max(0.0, min(60.0, useful_y))
        else:
            # === –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –ú–ï–¢–û–î –î–õ–Ø –°–õ–û–ñ–ù–´–• –§–û–†–ú ===
            # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —É–≥–ª—ã –ø–ª–∏—Ç–∫–∏
            corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]
            corners_inside = [
                p for p in corners if self.is_point_inside_room(*p)]

            # –ï—Å–ª–∏ –≤—Å–µ —É–≥–ª—ã –≤–Ω—É—Ç—Ä–∏ - —ç—Ç–æ –Ω–µ —Ä–µ–∑–∞–Ω–∞—è –ø–ª–∏—Ç–∫–∞ (–¥–æ–ª–∂–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è –≤—ã—à–µ)
            if len(corners_inside) == 4:
                return 60.0, 60.0

            # –ï—Å–ª–∏ –Ω–∏ –æ–¥–Ω–æ–≥–æ —É–≥–ª–∞ –≤–Ω—É—Ç—Ä–∏, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–Ω—Ç—Ä
            center = ((x1 + x2) / 2, (y1 + y2) / 2)
            if not corners_inside and not self.is_point_inside_room(*center):
                return 0.0, 0.0

            # 2. –ù–∞—Ö–æ–¥–∏–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –∫–æ–º–Ω–∞—Ç—ã - –û–°–ù–û–í–ù–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø
            intersection_points = []

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∫–∞–∂–¥–æ–π —Å—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã —Å –≥—Ä–∞–Ω–∏—Ü–∞–º–∏ –ø–ª–∏—Ç–∫–∏
            for wall in self.room.walls:
                wx1, wy1, wx2, wy2 = wall
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π –ø–ª–∏—Ç–∫–∏
                # –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ –ø–ª–∏—Ç–∫–∏ (x1, y1-y2)
                inter = self.line_intersection(
                    x1, y1, x1, y2, wx1, wy1, wx2, wy2)
                if inter:
                    intersection_points.append(inter)
                # –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ –ø–ª–∏—Ç–∫–∏ (x2, y1-y2)
                inter = self.line_intersection(
                    x2, y1, x2, y2, wx1, wy1, wx2, wy2)
                if inter:
                    intersection_points.append(inter)
                # –í–µ—Ä—Ö–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞ –ø–ª–∏—Ç–∫–∏ (x1-x2, y1)
                inter = self.line_intersection(
                    x1, y1, x2, y1, wx1, wy1, wx2, wy2)
                if inter:
                    intersection_points.append(inter)
                # –ù–∏–∂–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞ –ø–ª–∏—Ç–∫–∏ (x1-x2, y2)
                inter = self.line_intersection(
                    x1, y2, x2, y2, wx1, wy1, wx2, wy2)
                if inter:
                    intersection_points.append(inter)

            # 3. –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–Ω—É—Ç—Ä–∏ –∫–æ–º–Ω–∞—Ç—ã
            inside_points = corners_inside.copy()
            if intersection_points:
                # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                inside_points.extend(intersection_points)
            else:
                # –ï—Å–ª–∏ –Ω–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π, –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–ª—é—á–µ–≤—ã—Ö —Ç–æ—á–µ–∫ –≤–Ω—É—Ç—Ä–∏ –ø–ª–∏—Ç–∫–∏
                key_points = [
                    (x1 + 20, y1 + 20), (x1 + 40, y1 + 20),
                    (x1 + 20, y1 + 40), (x1 + 40, y1 + 40),
                    (x1 + 30, y1 + 30)  # —Ü–µ–Ω—Ç—Ä
                ]
                for px, py in key_points:
                    if self.is_point_inside_room(px, py):
                        inside_points.append((px, py))

            if not inside_points:
                return 0.0, 0.0

            # 4. –ù–∞—Ö–æ–¥–∏–º —Ä–µ–∞–ª—å–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ –≤—Å–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–º —Ç–æ—á–∫–∞–º
            min_x = min(p[0] for p in inside_points)
            max_x = max(p[0] for p in inside_points)
            min_y = min(p[1] for p in inside_points)
            max_y = max(p[1] for p in inside_points)

            # 5. –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏ –≤ 1 —Å–º
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ —Å—Ä–µ–∑—ã —Å —à–∞–≥–æ–º 10 —Å–º –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –≥—Ä–∞–Ω–∏—Ü
            for test_x in [x1 + 10, x1 + 20, x1 + 30, x1 + 40, x1 + 50]:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Ö–Ω—é—é –∏ –Ω–∏–∂–Ω—é—é —Ç–æ—á–∫–∏ –Ω–∞ —ç—Ç–æ–π –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
                if self.is_point_inside_room(test_x, y1 + 1) and test_x < max_x:
                    min_x = min(min_x, test_x)
                if self.is_point_inside_room(test_x, y2 - 1) and test_x > min_x:
                    max_x = max(max_x, test_x)
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å—Ä–µ–∑—ã —Å —à–∞–≥–æ–º 10 —Å–º
            for test_y in [y1 + 10, y1 + 20, y1 + 30, y1 + 40, y1 + 50]:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–µ–≤—É—é –∏ –ø—Ä–∞–≤—É—é —Ç–æ—á–∫–∏ –Ω–∞ —ç—Ç–æ–π –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏
                if self.is_point_inside_room(x1 + 1, test_y) and test_y < max_y:
                    min_y = min(min_y, test_y)
                if self.is_point_inside_room(x2 - 1, test_y) and test_y > min_y:
                    max_y = max(max_y, test_y)

            # 6. –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–ª–µ–∑–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ 1 —Å–º
            useful_x = max(0.0, min(60.0, round(max_x - min_x)))
            useful_y = max(0.0, min(60.0, round(max_y - min_y)))

            # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä 0.1 —Å–º –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
            return max(0.1, useful_x), max(0.1, useful_y)

    def line_intersection(self, x1, y1, x2, y2, x3, y3, x4, y4):
        """–ù–∞—Ö–æ–¥–∏—Ç —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –¥–≤—É—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤ –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç None"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ª–∏ –ª–∏–Ω–∏–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–º–∏
        denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
        if abs(denom) < 0.001:  # –ø–æ—á—Ç–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã
            return None

        ua = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
        ub = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–µ—Ä–µ—Å–µ–∫–∞—é—Ç—Å—è –ª–∏ –æ—Ç—Ä–µ–∑–∫–∏
        if ua < 0 or ua > 1 or ub < 0 or ub > 1:
            return None

        # –í—ã—á–∏—Å–ª—è–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        x = x1 + ua * (x2-x1)
        y = y1 + ua * (y2-y1)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–æ—á–∫–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–±–æ–∏—Ö –æ—Ç—Ä–µ–∑–∫–æ–≤
        if (min(x1, x2) - 1 <= x <= max(x1, x2) + 1 and
            min(y1, y2) - 1 <= y <= max(y1, y2) + 1 and
            min(x3, x4) - 1 <= x <= max(x3, x4) + 1 and
            min(y3, y4) - 1 <= y <= max(y3, y4) + 1):
            return (x, y)
        return None

    def point_to_line_distance(self, px, py, x1, y1, x2, y2):
        """–í—ã—á–∏—Å–ª—è–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –ª–∏–Ω–∏–∏"""
        # –ï—Å–ª–∏ –ª–∏–Ω–∏—è –≤—ã—Ä–æ–∂–¥–µ–Ω–∞ –≤ —Ç–æ—á–∫—É
        if x1 == x2 and y1 == y2:
            return math.sqrt((px - x1)**2 + (py - y1)**2)

        # –í–µ–∫—Ç–æ—Ä –ª–∏–Ω–∏–∏
        line_vec_x = x2 - x1
        line_vec_y = y2 - y1
        # –í–µ–∫—Ç–æ—Ä –æ—Ç –Ω–∞—á–∞–ª–∞ –ª–∏–Ω–∏–∏ –¥–æ —Ç–æ—á–∫–∏
        point_vec_x = px - x1
        point_vec_y = py - y1
        # –î–ª–∏–Ω–∞ –ª–∏–Ω–∏–∏
        line_len = math.sqrt(line_vec_x**2 + line_vec_y**2)
        # –ï–¥–∏–Ω–∏—á–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –ª–∏–Ω–∏–∏
        if line_len > 0:
            line_vec_x /= line_len
            line_vec_y /= line_len
        # –ü—Ä–æ–µ–∫—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ —Ç–æ—á–∫–∏ –Ω–∞ –ª–∏–Ω–∏—é
        projection_length = point_vec_x * line_vec_x + point_vec_y * line_vec_y
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–µ–∫—Ü–∏—é –¥–ª–∏–Ω–æ–π –ª–∏–Ω–∏–∏
        projection_length = max(0, min(line_len, projection_length))
        # –ë–ª–∏–∂–∞–π—à–∞—è —Ç–æ—á–∫–∞ –Ω–∞ –ª–∏–Ω–∏–∏
        closest_x = x1 + projection_length * line_vec_x
        closest_y = y1 + projection_length * line_vec_y
        # –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ –Ω–∞ –ª–∏–Ω–∏–∏
        return math.sqrt((px - closest_x)**2 + (py - closest_y)**2)

    def is_point_on_wall(self, px, py, tolerance=0.5):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ª–µ–∂–∏—Ç –ª–∏ —Ç–æ—á–∫–∞ –Ω–∞ –∫–∞–∫–æ–π-–ª–∏–±–æ —Å—Ç–µ–Ω–µ –∫–æ–º–Ω–∞—Ç—ã"""
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            distance = self.point_to_line_distance(px, py, x1, y1, x2, y2)
            if distance < tolerance:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —Ç–æ—á–∫–∞ –≤ –ø—Ä–µ–¥–µ–ª—ã –æ—Ç—Ä–µ–∑–∫–∞
                min_x, max_x = min(x1, x2), max(x1, x2)
                min_y, max_y = min(y1, y2), max(y1, y2)
                if (min_x - tolerance <= px <= max_x + tolerance and
                    min_y - tolerance <= py <= max_y + tolerance):
                    return True
        return False

    def is_point_inside_room(self, px, py):
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª–∏–≥–æ–Ω–∞"""
        if not self.room_polygon:
            return False

        # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ bounding box
        min_x, max_x, min_y, max_y = self.room_bounds
        if px < min_x - 1 or px > max_x + 1 or py < min_y - 1 or py > max_y + 1:
            return False

        # –ê–ª–≥–æ—Ä–∏—Ç–º ray casting —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –ø–æ–ª–∏–≥–æ–Ω–æ–º
        inside = False
        j = len(self.room_polygon) - 1
        for i in range(len(self.room_polygon)):
            xi, yi = self.room_polygon[i]
            xj, yj = self.room_polygon[j]
            if ((yi > py) != (yj > py)) and (px < (xj - xi) * (py - yi) / (yj - yi + 1e-10) + xi):
                inside = not inside
            j = i
        return inside

    def calculate_room_area(self):
        """–¢–æ—á–Ω—ã–π —Ä–∞—Å—á–µ—Ç –ø–ª–æ—â–∞–¥–∏ –∫–æ–º–Ω–∞—Ç—ã –º–µ—Ç–æ–¥–æ–º —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏–∏ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º"""
        if not self.room.walls or len(self.room.walls) < 3:
            return 0

        # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ—á–∫–∏ –ø–æ–ª–∏–≥–æ–Ω–∞ –∫–æ–º–Ω–∞—Ç—ã
        points = []
        if self.room.walls:
            points.append((self.room.walls[0][0], self.room.walls[0][1]))
            for wall in self.room.walls:
                points.append((wall[2], wall[3]))
        # –ó–∞–º—ã–∫–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω
        if points[0] != points[-1]:
            points.append(points[0])

        # –ú–µ—Ç–æ–¥ –ì–∞—É—Å—Å–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø–ª–æ—â–∞–¥–∏ –ø–æ–ª–∏–≥–æ–Ω–∞
        area = 0
        n = len(points) - 1  # –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–µ—Ä–≤–æ–π
        for i in range(n):
            x1, y1 = points[i]
            x2, y2 = points[i + 1]
            area += x1 * y2 - x2 * y1
        return abs(area) / 2

    def calculate_statistics(self):
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–∞—Å–∫–ª–∞–¥–∫–∏ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —É—á–µ—Ç–æ–º –ø–ª–æ—â–∞–¥–∏ –∫–æ–º–Ω–∞—Ç—ã"""
        if not self.room.walls:
            self.waste_percentage = 0
            self.room_area_sqm = 0.0
            return

        # 1. –¢–æ—á–Ω–æ —Å—á–∏—Ç–∞–µ–º –ø–ª–æ—â–∞–¥—å –∫–æ–º–Ω–∞—Ç—ã –≤ —Å–º¬≤
        room_area_sqcm = self.calculate_room_area()
        # 2. –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ø–ª–æ—â–∞–¥—å –≤ –º¬≤
        self.room_area_sqm = room_area_sqcm / 10000.0 # 1 –º¬≤ = 10000 —Å–º¬≤

        # 3. –ü–ª–æ—â–∞–¥—å —Ü–µ–ª—ã—Ö –ø–ª–∏—Ç–æ–∫
        full_area = self.full_tiles * (self.TILE_SIZE * self.TILE_SIZE)
        # 4. –ü–ª–æ—â–∞–¥—å –ø–æ–ª–µ–∑–Ω–æ–π —á–∞—Å—Ç–∏ —Ä–µ–∑–∞–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫
        cut_area_total = 0
        for tile in self.tiles:
            if tile['type'] == 'cut':
                useful_x = tile.get('cut_x', 0)
                useful_y = tile.get('cut_y', 0)
                useful_area = useful_x * useful_y
                cut_area_total += useful_area

        # 5. –û–±—â–∞—è –ø–æ–ª–µ–∑–Ω–∞—è –ø–ª–æ—â–∞–¥—å
        useful_area_total = full_area + cut_area_total
        # 6. –û–±—â–∞—è –ø–ª–æ—â–∞–¥—å –≤—Å–µ—Ö –ø–ª–∏—Ç–æ–∫ (–≤–∫–ª—é—á–∞—è –æ—Ç—Ö–æ–¥—ã)
        total_tiles_area = (self.full_tiles + self.cut_tiles) * \
                           (self.TILE_SIZE * self.TILE_SIZE)
        # 7. –û—Ç—Ö–æ–¥—ã = –≤—Å—è –ø–ª–æ—â–∞–¥—å –ø–ª–∏—Ç–æ–∫ - –ø–æ–ª–µ–∑–Ω–∞—è –ø–ª–æ—â–∞–¥—å
        waste_area = total_tiles_area - useful_area_total
        # 8. –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç—Ö–æ–¥–æ–≤ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–ª–æ—â–∞–¥–∏ –∫–æ–º–Ω–∞—Ç—ã
        if room_area_sqcm > 0: # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
            waste_percent = (waste_area / room_area_sqcm) * 100
            self.waste_percentage = round(waste_percent, 1)
        else:
            self.waste_percentage = 0

    def move_grid(self, dx, dy):
        """–°–º–µ—â–∞–µ—Ç —Å–µ—Ç–∫—É"""
        self.grid_offset_x = (self.grid_offset_x + dx) % self.TILE_SIZE
        self.grid_offset_y = (self.grid_offset_y + dy) % self.TILE_SIZE
        self.calculate_layout()

============================================================
–§–ê–ô–õ: screens\__init__.py
============================================================



============================================================
–§–ê–ô–õ: screens\layout_screen.py
============================================================

# screens/layout_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from widgets.layout_widget import LayoutWidget
from models import CeilingLayout
from database import save_project # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è

class LayoutScreen(Screen):
    """–≠–∫—Ä–∞–Ω —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –ø–æ—Ç–æ–ª–∫–∞ 60√ó60 —Å–º"""
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.snap_mode = 0
        self.control_mode = 'grid'  # 'grid' –∏–ª–∏ 'pan_zoom'

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))
        self.selected_corner = None

        # –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        toolbar = self.create_toolbar()

        # –û–±–ª–∞—Å—Ç—å —Å —Ä–∞—Å–∫–ª–∞–¥–∫–æ–π
        self.layout_widget = LayoutWidget(size_hint=(1, 0.8))

        # –ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        control_panel = self.create_control_panel()

        # –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è)
        stats_panel = self.create_stats_panel()

        main_layout.add_widget(toolbar)
        main_layout.add_widget(self.layout_widget)
        main_layout.add_widget(control_panel)
        main_layout.add_widget(stats_panel)

        self.add_widget(main_layout)

    def on_pre_enter(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–º–Ω–∞—Ç—É –ø—Ä–∏ –≤—Ö–æ–¥–µ"""
        from kivy.clock import Clock
        Clock.schedule_once(self.load_room_data, 0.1)

    def load_room_data(self, dt):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∫–æ–º–Ω–∞—Ç—ã —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏"""
        if not hasattr(self.manager, 'current_room') or not self.manager.current_room:
            print("–û—à–∏–±–∫–∞: current_room –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            return

        current_room = self.manager.current_room
        if current_room:
            print(f"–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–Ω–∞—Ç—ã: {current_room.name}")
            print(f"–°—Ç–µ–Ω—ã: {len(current_room.walls)}")
            # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—Ç–µ–Ω–∞—Ö
            for i, wall in enumerate(current_room.walls):
                print(f"  –°—Ç–µ–Ω–∞ {i}: {wall}")

            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–µ–Ω—ã –≤ –≤–∏–¥–∂–µ—Ç
            self.layout_widget.set_room(current_room.walls)

            # –°–æ–∑–¥–∞–µ–º —Ä–∞—Å—á–µ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫–∏
            self.ceiling_layout = CeilingLayout(current_room)

            # –í–ê–ñ–ù–û: –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –≤ 0, –∞ –Ω–µ –±–µ—Ä–µ–º –∏–∑ –≤–∏–¥–∂–µ—Ç–∞
            self.ceiling_layout.grid_offset_x = 0
            self.ceiling_layout.grid_offset_y = 0

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞—Å–∫–ª–∞–¥–∫—É
            self.ceiling_layout.calculate_layout()

            # –ü–µ—Ä–µ–¥–∞–µ–º layout –≤ –≤–∏–¥–∂–µ—Ç
            self.layout_widget.layout = self.ceiling_layout

            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º callback –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ —Å–µ—Ç–∫–∏
            self.layout_widget.on_grid_move = self.on_grid_moved

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            self.update_stats()

            # –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è
            self.update_offset_label()

            # –Ø–≤–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
            self.layout_widget.draw_layout()

    def on_grid_moved(self):
        """Callback, –≤—ã–∑—ã–≤–∞–µ–º—ã–π –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–æ–ª–æ–∂–µ–Ω–∏—è —Å–µ—Ç–∫–∏"""
        # –ü–æ–ª—É—á–∞–µ–º –¢–û–ß–ù–´–ï –∑–Ω–∞—á–µ–Ω–∏—è —Å–º–µ—â–µ–Ω–∏—è –±–µ–∑ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
        if hasattr(self.layout_widget, 'grid_offset_x') and hasattr(self.layout_widget, 'grid_offset_y'):
            # –ë–µ—Ä–µ–º —Ç–æ—á–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏ –æ–∫—Ä—É–≥–ª—è–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            offset_x = round(self.layout_widget.grid_offset_x,
                             1)  # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ 0.1 —Å–º
            offset_y = round(self.layout_widget.grid_offset_y, 1)

            # –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –°–†–ê–ó–£ –ø—Ä–∏ –ª—é–±–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏
            if hasattr(self, 'offset_label'):
                self.offset_label.text = f'–°–º–µ—â–µ–Ω–∏–µ: {int(round(offset_x))}√ó{int(round(offset_y))} —Å–º'

            # –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞—Å—á–µ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫–∏
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = offset_x
                self.ceiling_layout.grid_offset_y = offset_y
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
                self.update_stats() # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ —Å–µ—Ç–∫–∏

    def create_toolbar(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å –∫–Ω–æ–ø–∫–æ–π —Ä–µ–∂–∏–º–∞"""
        toolbar = BoxLayout(
            size_hint=(1, 0.1),
            padding=dp(10),
            spacing=dp(10)
        )

        # –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥"
        btn_back = Button(
            text='–ù–∞–∑–∞–¥',
            font_size=dp(16),
            size_hint=(0.2, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        title = Label(
            text='–†–∞—Å–∫–ª–∞–¥–∫–∞\n60√ó60 —Å–º',
            font_size=dp(16),
            size_hint=(0.3, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            max_lines=2,
            line_height=1.2
        )
        title.bind(size=title.setter('text_size'))

        # –ö–Ω–æ–ø–∫–∞ —Ä–µ–∂–∏–º–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        self.mode_button = Button(
            text='–°–µ—Ç–∫–∞',  # –ò–∫–æ–Ω–∫–∞ –∏ —Ç–µ–∫—Å—Ç
            font_size=dp(14),
            size_hint=(0.25, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        self.mode_button.bind(on_press=self.toggle_control_mode)

        # –ö–Ω–æ–ø–∫–∞ "–°–±—Ä–æ—Å"
        btn_reset = Button(
            text='–°–±—Ä–æ—Å',
            font_size=dp(14),
            size_hint=(0.25, 1),
            background_color=(0.9, 0.6, 0.2, 1),
            color=(1, 1, 1, 1)
        )
        btn_reset.bind(on_press=self.reset_view)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(title)
        toolbar.add_widget(self.mode_button)
        toolbar.add_widget(btn_reset)

        return toolbar

    def toggle_control_mode(self, instance):
        """–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ä–µ–∂–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è"""
        if self.control_mode == 'grid':
            self.control_mode = 'pan_zoom'
            self.mode_button.text = 'üëÜ –ü–∞–Ω–æ—Ä–∞–º–∞'
            self.mode_button.background_color = (0.3, 0.7, 0.3, 1)
            # –û—Ç–∫–ª—é—á–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –ø–∞–ª—å—Ü–µ–º
            self.layout_widget.dragging_enabled = False
        else:
            self.control_mode = 'grid'
            self.mode_button.text = '–°–µ—Ç–∫–∞'
            self.mode_button.background_color = (0.2, 0.6, 1, 1)
            # –í–∫–ª—é—á–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –ø–∞–ª—å—Ü–µ–º
            self.layout_widget.dragging_enabled = True

    def reset_view(self, instance):
        """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç –≤–∏–¥ –∫ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é"""
        if self.control_mode == 'pan_zoom':
            # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–Ω–∞—Ç—É
            self.layout_widget.center_room()
        else:
            # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–µ—Ç–∫—É
            self.layout_widget.grid_offset_x = 0
            self.layout_widget.grid_offset_y = 0
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = 0
                self.ceiling_layout.grid_offset_y = 0
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
                self.update_stats()
                self.update_offset_label()
                self.layout_widget.draw_layout()

    def create_control_panel(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ç–∫–æ–π"""
        control_panel = BoxLayout(
            size_hint=(1, 0.05),
            padding=dp(5),
            spacing=dp(5)
        )

        # –ö–Ω–æ–ø–∫–∏ —Å–º–µ—â–µ–Ω–∏—è —Å–µ—Ç–∫–∏ —Å —à–∞–≥–æ–º 1 —Å–º
        btn_left = Button(
            text='<-',
            font_size=dp(20),
            size_hint=(0.15, 1)
        )
        btn_left.bind(on_press=lambda x: self.move_grid(-1, 0))
        btn_up = Button(
            text='^',
            font_size=dp(20),
            size_hint=(0.15, 1)
        )
        btn_up.bind(on_press=lambda x: self.move_grid(0, 1))
        btn_down = Button(
            text='v',
            font_size=dp(20),
            size_hint=(0.15, 1)
        )
        btn_down.bind(on_press=lambda x: self.move_grid(0, -1))
        btn_right = Button(
            text='->',
            font_size=dp(20),
            size_hint=(0.15, 1)
        )
        btn_right.bind(on_press=lambda x: self.move_grid(1, 0))

        # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Å–º–µ—â–µ–Ω–∏—è
        self.offset_label = Label(
            text='–°–º–µ—â–µ–Ω–∏–µ: 0√ó0 —Å–º',
            font_size=dp(14),
            size_hint=(0.4, 1),
            color=(0, 0, 0, 1)
        )

        control_panel.add_widget(btn_left)
        control_panel.add_widget(btn_up)
        control_panel.add_widget(btn_down)
        control_panel.add_widget(btn_right)
        control_panel.add_widget(self.offset_label)

        return control_panel

    def create_stats_panel(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø–∞–Ω–µ–ª—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        stats_panel = BoxLayout(
            size_hint=(1, 0.05),
            padding=dp(10)
        )
        # –ò–∑–º–µ–Ω—è–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –ø–ª–æ—â–∞–¥—å
        self.stats_label = Label(
            text='–¶–µ–ª—ã—Ö: 0 | –†–µ–∑–∞–Ω—ã—Ö: 0 | –ü–ª–æ—â–∞–¥—å: 0.0 –º¬≤',
            font_size=dp(14),
            color=(0, 0, 0, 1)
        )
        stats_panel.add_widget(self.stats_label)
        return stats_panel

    def move_grid(self, dx, dy):
        """–°–º–µ—â–∞–µ—Ç —Å–µ—Ç–∫—É –Ω–∞ dx, dy —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–æ–≤ —Å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º"""
        if hasattr(self.layout_widget, 'grid_offset_x'):
            # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¢–û–ß–ù–û–ï —Å–º–µ—â–µ–Ω–∏–µ
            self.layout_widget.grid_offset_x += dx
            self.layout_widget.grid_offset_y += dy

            # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ä–∞—Å—á–µ—Ç
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = self.layout_widget.grid_offset_x
                self.ceiling_layout.grid_offset_y = self.layout_widget.grid_offset_y
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout

            # –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: –≤—ã–∑—ã–≤–∞–µ–º callback –≤—Ä—É—á–Ω—É—é –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
            self.on_grid_moved()

            # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
            self.layout_widget.draw_layout()

    def update_offset_label(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å–º–µ—â–µ–Ω–∏—è —Å–µ—Ç–∫–∏"""
        ox = self.layout_widget.grid_offset_x
        oy = self.layout_widget.grid_offset_y
        self.offset_label.text = f'–°–º–µ—â–µ–Ω–∏–µ: {int(ox)}√ó{int(oy)} —Å–º'

    def reset_grid(self, instance):
        """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Å–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –∫ (0, 0)"""
        self.layout_widget.grid_offset_x = 0
        self.layout_widget.grid_offset_y = 0
        if self.ceiling_layout:
            self.ceiling_layout.grid_offset_x = 0
            self.ceiling_layout.grid_offset_y = 0
            self.ceiling_layout.calculate_layout()
            self.layout_widget.layout = self.ceiling_layout
            self.update_stats()
            self.update_offset_label()
            self.layout_widget.draw_layout()

    def update_stats(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ä–∞—Å–∫–ª–∞–¥–∫–∏"""
        if self.ceiling_layout:
            stats = self.ceiling_layout
            # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç: –≤–º–µ—Å—Ç–æ –æ—Ç—Ö–æ–¥–æ–≤ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–ª–æ—â–∞–¥—å
            self.stats_label.text = f'–¶–µ–ª—ã—Ö: {stats.full_tiles} | –†–µ–∑–∞–Ω—ã—Ö: {stats.cut_tiles} | –ü–ª–æ—â–∞–¥—å: {stats.room_area_sqm:.2f} –º¬≤'

    def go_back(self, instance):
        """–í–æ–∑–≤—Ä–∞—Ç –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä"""
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–µ–∫—Ç –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ —Å —ç–∫—Ä–∞–Ω–∞ —Ä–∞—Å–∫–ª–∞–¥–∫–∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
        # save_project(self.manager.current_project)
        self.manager.current = 'room_editor'

============================================================
–§–ê–ô–õ: screens\main_screen.py
============================================================

from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.metrics import dp


class MainScreen(Screen):
    """–ì–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω —Å –≤—ã–±–æ—Ä–æ–º –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # –û—Å–Ω–æ–≤–Ω–æ–π –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        main_layout = BoxLayout(
            orientation='vertical',
            padding=dp(20),
            spacing=dp(20)
        )

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        title = Label(
            text='–ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –ø–æ—Ç–æ–ª–∫–æ–≤',
            font_size=dp(28),
            color=(0, 0, 0, 1),
            size_hint=(1, 0.2),
            bold=True
        )

        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–æ–∫
        buttons_layout = BoxLayout(
            orientation='vertical',
            spacing=dp(15),
            size_hint=(1, 0.8)
        )

        # –ö–Ω–æ–ø–∫–∞ 1: –†–∞—Å—á–µ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –ø–æ—Ç–æ–ª–∫–∞
        btn_calc1 = Button(
            text='–†–∞—Å—á–µ—Ç —Ä–∞—Å–∫–ª–∞–¥–∫–∏ –ø–æ—Ç–æ–ª–∫–∞',
            font_size=dp(18),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            size_hint=(1, 0.45)
        )
        # –ò–∑–º–µ–Ω–µ–Ω–æ: —Ç–µ–ø–µ—Ä—å –∏–¥–µ–º –≤ –ø—Ä–æ–µ–∫—Ç—ã
        btn_calc1.bind(on_press=self.go_to_projects)

        # –ö–Ω–æ–ø–∫–∞ 2: –†–∞—Å—á–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤ (–∑–∞–≥–ª—É—à–∫–∞)
        btn_calc2 = Button(
            text='–†–∞—Å—á–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤',
            font_size=dp(18),
            background_color=(0.3, 0.7, 0.3, 1),
            color=(1, 1, 1, 1),
            size_hint=(1, 0.45)
        )
        btn_calc2.bind(on_press=self.show_placeholder)

        # –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        buttons_layout.add_widget(btn_calc1)
        buttons_layout.add_widget(btn_calc2)

        main_layout.add_widget(title)
        main_layout.add_widget(buttons_layout)

        self.add_widget(main_layout)

    def go_to_projects(self, instance):  # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω –º–µ—Ç–æ–¥
        """–ü–µ—Ä–µ—Ö–æ–¥ –∫ —ç–∫—Ä–∞–Ω—É –ø—Ä–æ–µ–∫—Ç–æ–≤"""
        print("–ü–µ—Ä–µ—Ö–æ–¥ –∫ —ç–∫—Ä–∞–Ω—É –ø—Ä–æ–µ–∫—Ç–æ–≤")
        self.manager.current = 'projects'

    def show_placeholder(self, instance):
        """–ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –≤—Ç–æ—Ä–æ–≥–æ –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä–∞"""
        instance.text = "–í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ!"
        from kivy.clock import Clock
        Clock.schedule_once(lambda dt: setattr(
            instance, 'text', '–†–∞—Å—á–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤'), 1)

============================================================
–§–ê–ô–õ: screens\projects_screen.py
============================================================

# screens/projects_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.graphics import Color, Rectangle, Line
from kivy.clock import Clock
from database import init_db, load_all_projects, save_project, delete_project, load_project
# –î–æ–±–∞–≤–∏–º BoxLayout –¥–ª—è –∫–æ–º–ø–æ–Ω–æ–≤–∫–∏ –∫–Ω–æ–ø–∫–∏ X
from kivy.uix.boxlayout import BoxLayout
# –ò—Å–ø–æ–ª—å–∑—É–µ–º AnchorLayout –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è X
from kivy.uix.relativelayout import RelativeLayout


class ProjectsScreen(Screen):
    """–≠–∫—Ä–∞–Ω —Å–æ —Å–ø–∏—Å–∫–æ–º –ø—Ä–æ–µ–∫—Ç–æ–≤ (–ø–ª–∏—Ç–æ—á–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å)"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ë–î –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        init_db()

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        toolbar = self.create_toolbar()

        # –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å —Å –ø—Ä–æ–µ–∫—Ç–∞–º–∏
        content_area = self.create_content_area()

        main_layout.add_widget(toolbar)
        main_layout.add_widget(content_area)
        self.add_widget(main_layout)
        self.bind(size=self.on_size)

        # –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–Ω—ã
        self.projects = []
        # –û—Ç–ª–æ–∂–µ–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–µ–∫—Ç–æ–≤ –∏–∑ –ë–î
        Clock.schedule_once(lambda dt: self.load_projects(), 0.1)

    def on_size(self, *args):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Ä–∞–∑–º–µ—Ä—ã –ø–ª–∏—Ç–æ–∫ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞"""
        if hasattr(self, 'projects_container'):
            Clock.schedule_once(lambda dt: self.update_projects_grid(), 0.1)

    def create_toolbar(self):
        """–°–æ–∑–¥–∞–µ—Ç –ø–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
        toolbar = BoxLayout(
            size_hint=(1, 0.15),
            padding=dp(10),
            spacing=dp(10)
        )

        # –ö–Ω–æ–ø–∫–∞ "–ù–∞–∑–∞–¥" –Ω–∞ –≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω
        btn_back = Button(
            text='‚Üê –ù–∞–∑–∞–¥',
            font_size=dp(16),
            size_hint=(0.3, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        title = Label(
            text='–ú–æ–∏ –ø—Ä–æ–µ–∫—Ç—ã',
            font_size=dp(20),
            size_hint=(0.4, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle'
        )
        title.bind(size=title.setter('text_size'))

        # –ö–Ω–æ–ø–∫–∞ "–î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–µ–∫—Ç" —Å –ø–µ—Ä–µ–Ω–æ—Å–æ–º —Ç–µ–∫—Å—Ç–∞
        btn_add = Button(
            text='+ –ù–æ–≤—ã–π\n–ø—Ä–æ–µ–∫—Ç',  # –ü–µ—Ä–µ–Ω–æ—Å –Ω–∞ –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É
            font_size=dp(14),
            size_hint=(0.3, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        btn_add.bind(on_press=self.show_add_project_dialog)

        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–µ—Ä–µ–Ω–æ—Å —Ç–µ–∫—Å—Ç–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏
        def update_btn_text(instance, size):
            instance.text_size = (size[0] - dp(10), None)
        btn_add.bind(size=update_btn_text)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(title)
        toolbar.add_widget(btn_add)

        return toolbar

    def create_content_area(self):
        """–°–æ–∑–¥–∞–µ—Ç –æ–±–ª–∞—Å—Ç—å —Å –ø–ª–∏—Ç–∫–∞–º–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤"""
        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Å–µ—Ç–∫–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤
        self.projects_container = GridLayout(
            cols=2,
            spacing=dp(10),
            padding=dp(10),
            size_hint_y=None
        )
        self.projects_container.bind(
            minimum_height=self.projects_container.setter('height'))

        # –°–∫—Ä–æ–ª–ª –¥–ª—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        scroll = ScrollView()
        scroll.add_widget(self.projects_container)

        return scroll

    def load_projects(self):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–æ–µ–∫—Ç—ã –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        self.projects = []
        db_projects = load_all_projects()
        if db_projects:
            self.projects = db_projects
        self.update_projects_grid()  # <-- –í—ã–∑—ã–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

    def update_projects_grid(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å–µ—Ç–∫—É –ø—Ä–æ–µ–∫—Ç–æ–≤"""
        self.projects_container.clear_widgets()
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–µ—Ç–∫–∏
        self.projects_container.cols = 2
        self.projects_container.spacing = dp(10)
        self.projects_container.padding = dp(10)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–ª–∏—Ç–∫–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤
        for project in self.projects:
            project_tile = self.create_project_tile(project)
            self.projects_container.add_widget(project_tile)
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã—Å–æ—Ç—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
        self.projects_container.height = self.projects_container.minimum_height
        
        # –ï—Å–ª–∏ –ø—Ä–æ–µ–∫—Ç–æ–≤ –Ω–µ—Ç
        if not self.projects:
            empty_label = Label(
                text='–ù–µ—Ç –ø—Ä–æ–µ–∫—Ç–æ–≤\n–ù–∞–∂–º–∏—Ç–µ "+ –ù–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç"',
                font_size=dp(16),
                color=(0.5, 0.5, 0.5, 1),
                halign='center',
                valign='middle',
                size_hint_y=None
            )
            empty_label.bind(size=empty_label.setter('text_size'))
            empty_label.height = self.height * 0.3
            self.projects_container.add_widget(empty_label)
            self.projects_container.height = self.projects_container.minimum_height

    def create_project_tile(self, project):
        """–°–æ–∑–¥–∞–µ—Ç –ø–ª–∏—Ç–∫—É –¥–ª—è –ø—Ä–æ–µ–∫—Ç–∞ —Å –∫–Ω–æ–ø–∫–æ–π —É–¥–∞–ª–µ–Ω–∏—è"""
        # –í—ã—á–∏—Å–ª—è–µ–º —à–∏—Ä–∏–Ω—É –ø–ª–∏—Ç–∫–∏
        container_width = self.projects_container.width if self.projects_container.width > 0 else self.width
        tile_width = (container_width - dp(30)) / 2 if container_width > 0 else dp(150)
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º RelativeLayout –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        tile_layout = RelativeLayout(
            size_hint=(None, None),
            size=(tile_width, tile_width)
        )
        
        # –û—Å–Ω–æ–≤–Ω–∞—è –ø–ª–∏—Ç–∫–∞ - –∫–Ω–æ–ø–∫–∞ —Å —Ñ–æ–Ω–æ–º
        tile_button = Button(
            background_color=(0.95, 0.95, 0.95, 1),
            background_normal='',
            text=project.name,
            font_size=dp(16),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            text_size=(tile_width - dp(20), None),
            shorten=True,
            max_lines=2
        )
        tile_button.bind(size=tile_button.setter('text_size'))
        tile_button.bind(on_press=lambda instance, p=project: self.open_project(p))
        
        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–Ω–æ–ø–∫–∏ —É–¥–∞–ª–µ–Ω–∏—è (—Ç–æ—á–Ω–æ –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É)
        delete_container = BoxLayout(
            size_hint=(None, None),
            size=(dp(25), dp(25)),
            pos_hint={'right': 1, 'top': 1}  # –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É
        )
        
        delete_button = Button(
            text='X',
            font_size=dp(12),
            size_hint=(1, 1),
            background_color=(0.8, 0.2, 0.2, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        delete_button.bind(on_press=lambda instance, p_id=project.id: self.confirm_delete_project(p_id))
        
        delete_container.add_widget(delete_button)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –≤ RelativeLayout
        tile_layout.add_widget(tile_button)  # –û—Å–Ω–æ–≤–Ω–∞—è –∫–Ω–æ–ø–∫–∞ —Å–Ω–∏–∑—É
        tile_layout.add_widget(delete_container)  # –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–æ–≤–µ—Ä—Ö
        
        return tile_layout
    
    def confirm_delete_project(self, project_id):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —É–¥–∞–ª–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞."""
        content = BoxLayout(orientation='vertical', spacing=dp(10), padding=dp(10))
        message = Label(text='–í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å?', font_size=dp(16))

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.3))

        def do_delete(dt):
            success = delete_project(project_id)
            if success:
                # –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–µ–∫—Ç–æ–≤
                self.load_projects()
            popup.dismiss()

        def cancel_delete(dt):
            popup.dismiss()

        btn_delete = Button(text='–£–¥–∞–ª–∏—Ç—å', background_color=(0.8, 0.2, 0.2, 1), color=(1, 1, 1, 1))
        btn_cancel = Button(text='–û—Ç–º–µ–Ω–∞')

        btn_delete.bind(on_press=do_delete)
        btn_cancel.bind(on_press=cancel_delete)

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_delete)

        content.add_widget(message)
        content.add_widget(btn_layout)

        popup = Popup(title='–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è',
                      content=content,
                      size_hint=(0.6, 0.4))
        popup.open()

    def show_add_project_dialog(self, instance):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞"""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(20))

        label = Label(text='–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞:', font_size=dp(16))
        name_input = TextInput(
            multiline=False,
            font_size=dp(18),
            size_hint=(1, 0.4)
        )

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.4))

        btn_confirm = Button(
            text='–°–æ–∑–¥–∞—Ç—å',
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        btn_cancel = Button(text='–û—Ç–º–µ–Ω–∞')

        def create_project(inst):
            name = name_input.text.strip()
            if name:
                from models import Project
                project = Project(name)
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–µ–∫—Ç –≤ –ë–î
                save_project(project)
                # –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–æ–µ–∫—Ç—ã –∏–∑ –ë–î –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                self.projects = load_all_projects()
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å–µ—Ç–∫—É
                self.update_projects_grid()
                popup.dismiss()

        btn_confirm.bind(on_press=create_project)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)

        content.add_widget(label)
        content.add_widget(name_input)
        content.add_widget(btn_layout)

        popup = Popup(
            title='–ù–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç',
            content=content,
            size_hint=(0.8, 0.4)
        )
        popup.open()

    def open_project(self, project):
        """–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø—Ä–æ–µ–∫—Ç (–ø–µ—Ä–µ—Ö–æ–¥ –∫ —ç–∫—Ä–∞–Ω—É –∫–æ–º–Ω–∞—Ç)"""
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–µ–∫—Ç –≤ –º–µ–Ω–µ–¥–∂–µ—Ä–µ —ç–∫—Ä–∞–Ω–æ–≤
        self.manager.current_project = project
        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —ç–∫—Ä–∞–Ω—É –∫–æ–º–Ω–∞—Ç
        self.manager.current = 'rooms'

    def go_back(self, instance):
        """–í–æ–∑–≤—Ä–∞—Ç –Ω–∞ –≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω"""
        self.manager.current = 'main'

============================================================
–§–ê–ô–õ: utils\__init__.py
============================================================



============================================================
–§–ê–ô–õ: widgets\__init__.py
============================================================



============================================================
–§–ê–ô–õ: widgets\grid_widget.py
============================================================

from kivy.uix.widget import Widget
from kivy.graphics import Color, Line, Rectangle, Ellipse, Mesh
from kivy.properties import NumericProperty, ListProperty
from kivy.metrics import dp
import math
from kivy.graphics.stencil_instructions import StencilPush, StencilUse, StencilUnUse, StencilPop


class GridWidget(Widget):
    """–í–∏–¥–∂–µ—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ–π —Å–µ—Ç–∫–∏"""

    scale = NumericProperty(0.2)
    offset_x = NumericProperty(0)
    offset_y = NumericProperty(0)

    # –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–æ–π—Å—Ç–≤–æ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ—á–µ–∫ –∫–æ–º–Ω–∞—Ç—ã
    room_points = ListProperty([])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # –¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è (–≤ —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä–∞—Ö)
        self.current_pos_cm = [0, 0]

        # –°–ø–∏—Å–æ–∫ —Å—Ç–µ–Ω
        self.walls = []

        # –ò—Å—Ç–æ—Ä–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã
        self.undo_stack = []
        self.redo_stack = []

        # –î–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è (panning)
        self.dragging = False
        self.last_touch_pos = None

        # –î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∏–∫–∞ –Ω–∞ –ª–∏–Ω–∏—é-–¥–æ–≤–æ–¥—á–∏–∫
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []

        # –¶–≤–µ—Ç–∞ —Å–æ–≥–ª–∞—Å–Ω–æ –¢–ó
        self.bg_color = (0.12, 0.13, 0.13, 1)      # #1e2022 - —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω
        self.wall_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - —Å–≤–µ—Ç–ª—ã–µ —Å—Ç–µ–Ω—ã
        self.point_color = (0.94, 0.96, 0.98, 1)   # #f0f5f9 - —Å–≤–µ—Ç–ª–∞—è —Ç–æ—á–∫–∞
        # #52616b - —Å–µ—Ä—ã–π –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
        self.room_color = (0.32, 0.38, 0.42, 1)
        # #c9d6df - —Ü–≤–µ—Ç –ª–∏–Ω–∏–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        self.closing_line_color = (0.79, 0.84, 0.87, 1)

        # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –Ω–∞ —Ç–æ—á–∫–µ (0,0)
        self.center_camera()

        # –°–Ω–∞—á–∞–ª–∞ —Ä–∏—Å—É–µ–º
        self.draw_editor()

        # –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
        self.bind(size=self._update_canvas)

    def center_camera(self):
        """–¶–µ–Ω—Ç—Ä–∏—Ä—É–µ—Ç –∫–∞–º–µ—Ä—É –Ω–∞ —Ç–æ—á–∫–µ (0,0)"""
        if self.width > 0 and self.height > 0:
            self.offset_x = self.width / 2
            self.offset_y = self.height / 2

    def _update_canvas(self, *args):
        # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
        if self.offset_x == 0 and self.offset_y == 0:
            self.center_camera()
        self.canvas.clear()
        self.draw_editor()

    def cm_to_px(self, cm_x, cm_y):
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä—ã –≤ –ø–∏–∫—Å–µ–ª–∏"""
        px_x = self.offset_x + cm_x * self.scale
        px_y = self.offset_y + cm_y * self.scale
        return px_x, px_y

    def draw_editor(self):
        """–†–∏—Å—É–µ—Ç —Ä–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–º–Ω–∞—Ç—ã"""
        with self.canvas:
            # –¢–µ–º–Ω—ã–π —Ñ–æ–Ω
            Color(*self.bg_color)
            Rectangle(pos=self.pos, size=self.size)

            # –†–∏—Å—É–µ–º –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—É—é –æ–±–ª–∞—Å—Ç—å –∫–æ–º–Ω–∞—Ç—ã (–µ—Å–ª–∏ –µ—Å—Ç—å —Å—Ç–µ–Ω—ã)
            if len(self.walls) >= 3:
                self.draw_room_fill()

            # –†–∏—Å—É–µ–º —Å—Ç–µ–Ω—ã
            self.draw_walls()

            # –†–∏—Å—É–µ–º —Ç–µ–∫—É—â—É—é —Ç–æ—á–∫—É
            self.draw_current_point()

            # –†–∏—Å—É–µ–º –ª–∏–Ω–∏—é, —Å–æ–µ–¥–∏–Ω—è—é—â—É—é –ø–µ—Ä–≤—É—é –∏ –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É (–µ—Å–ª–∏ –µ—Å—Ç—å 3+ —Å—Ç–µ–Ω—ã)
            if len(self.walls) >= 3:
                self.draw_closing_line()

    def draw_closing_line(self):
        """–†–∏—Å—É–µ—Ç –ª–∏–Ω–∏—é, —Å–æ–µ–¥–∏–Ω—è—é—â—É—é –ø–µ—Ä–≤—É—é –∏ –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É"""
        if len(self.walls) < 3:
            return

        # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é —Ç–æ—á–∫—É –ø–µ—Ä–≤–æ–π —Å—Ç–µ–Ω—ã –∏ –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç–µ–Ω—ã
        first_wall = self.walls[0]
        last_wall = self.walls[-1]

        # –ü–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞: –Ω–∞—á–∞–ª–æ –ø–µ—Ä–≤–æ–π —Å—Ç–µ–Ω—ã
        x1, y1 = first_wall[0], first_wall[1]
        # –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞: –∫–æ–Ω–µ—Ü –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç–µ–Ω—ã
        x2, y2 = last_wall[2], last_wall[3]

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç –ª–∏ —Ç–æ—á–∫–∏ (–µ—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ —É–∂–µ –∑–∞–º–∫–Ω—É—Ç–∞)
        if abs(x1 - x2) < 0.1 and abs(y1 - y2) < 0.1:
            return

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ª–∏–Ω–∏–∏-–¥–æ–≤–æ–¥—á–∏–∫–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∏–∫–æ–≤
        self.closing_line_start = (x1, y1)
        self.closing_line_end = (x2, y2)

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø–∏–∫—Å–µ–ª–∏ –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
        px1 = self.cm_to_px(x1, y1)
        px2 = self.cm_to_px(x2, y2)

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ—á–∫–∏ –ª–∏–Ω–∏–∏ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
        self.closing_line_points = [px1[0], px1[1], px2[0], px2[1]]

        # –¶–≤–µ—Ç –¥–ª—è –ª–∏–Ω–∏–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        Color(*self.closing_line_color)

        # –†–∏—Å—É–µ–º –ø—É–Ω–∫—Ç–∏—Ä–Ω—É—é –ª–∏–Ω–∏—é
        Line(points=self.closing_line_points,
             width=2, dash_length=10, dash_offset=5)

    def point_to_line_distance(self, px, py, x1, y1, x2, y2):
        """–í—ã—á–∏—Å–ª—è–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –ª–∏–Ω–∏–∏"""
        # –ï—Å–ª–∏ –ª–∏–Ω–∏—è –≤—ã—Ä–æ–∂–¥–µ–Ω–∞ –≤ —Ç–æ—á–∫—É
        if x1 == x2 and y1 == y2:
            return math.sqrt((px - x1)**2 + (py - y1)**2)

        # –í–µ–∫—Ç–æ—Ä –ª–∏–Ω–∏–∏
        line_vec_x = x2 - x1
        line_vec_y = y2 - y1

        # –í–µ–∫—Ç–æ—Ä –æ—Ç –Ω–∞—á–∞–ª–∞ –ª–∏–Ω–∏–∏ –¥–æ —Ç–æ—á–∫–∏
        point_vec_x = px - x1
        point_vec_y = py - y1

        # –î–ª–∏–Ω–∞ –ª–∏–Ω–∏–∏
        line_len = math.sqrt(line_vec_x**2 + line_vec_y**2)

        # –ï–¥–∏–Ω–∏—á–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –ª–∏–Ω–∏–∏
        if line_len > 0:
            line_vec_x /= line_len
            line_vec_y /= line_len

        # –ü—Ä–æ–µ–∫—Ü–∏—è –≤–µ–∫—Ç–æ—Ä–∞ —Ç–æ—á–∫–∏ –Ω–∞ –ª–∏–Ω–∏—é
        projection_length = point_vec_x * line_vec_x + point_vec_y * line_vec_y

        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø—Ä–æ–µ–∫—Ü–∏—é –¥–ª–∏–Ω–æ–π –ª–∏–Ω–∏–∏
        projection_length = max(0, min(line_len, projection_length))

        # –ë–ª–∏–∂–∞–π—à–∞—è —Ç–æ—á–∫–∞ –Ω–∞ –ª–∏–Ω–∏–∏
        closest_x = x1 + projection_length * line_vec_x
        closest_y = y1 + projection_length * line_vec_y

        # –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –¥–æ –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏ –Ω–∞ –ª–∏–Ω–∏–∏
        return math.sqrt((px - closest_x)**2 + (py - closest_y)**2)

    def draw_room_fill(self):
        """–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –∫–æ–º–Ω–∞—Ç—ã"""
        if len(self.walls) < 3:
            return

        # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ—á–∫–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –¥–ª—è –∫–æ–Ω—Ç—É—Ä–∞
        points = []
        if self.walls:
            # –ü–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞ –ø–µ—Ä–≤–æ–π —Å—Ç–µ–Ω—ã
            points.append((self.walls[0][0], self.walls[0][1]))
            # –ö–æ–Ω–µ—á–Ω—ã–µ —Ç–æ—á–∫–∏ –≤—Å–µ—Ö —Å—Ç–µ–Ω
            for wall in self.walls:
                points.append((wall[2], wall[3]))
            # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –Ω–µ –∑–∞–º–∫–Ω—É—Ç–∞, –∑–∞–º—ã–∫–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω
            if points[-1] != points[0]:
                points.append(points[0])

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ —Ç–æ—á–µ–∫ –¥–ª—è –∑–∞–ª–∏–≤–∫–∏
        if len(points) < 4:
            return

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–æ—á–∫–∏ –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        screen_points = []
        for x, y in points:
            px = self.cm_to_px(x, y)
            screen_points.extend([px[0], px[1]])

        if len(screen_points) < 8:  # –ú–∏–Ω–∏–º—É–º 4 —Ç–æ—á–∫–∏ –¥–ª—è –ø–æ–ª–∏–≥–æ–Ω–∞
            return

        with self.canvas:
            # –ó–∞–ª–∏–≤–∞–µ–º –ø–æ–ª–∏–≥–æ–Ω —Ü–≤–µ—Ç–æ–º –∫–æ–º–Ω–∞—Ç—ã
            Color(*self.room_color)

            # –°–æ–∑–¥–∞–µ–º Mesh –¥–ª—è –∑–∞–ª–∏–≤–∫–∏ —Å–ª–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º
            vertices = []
            indices = []

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∏–∞–Ω–≥—É–ª—è—Ü–∏—é "–≤–µ–µ—Ä–æ–º" –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –º–∞—Å—Å
            center_x = sum(screen_points[i] for i in range(
                0, len(screen_points), 2)) / (len(screen_points) // 2)
            center_y = sum(screen_points[i] for i in range(
                1, len(screen_points), 2)) / (len(screen_points) // 2)

            # –°–æ–∑–¥–∞–µ–º —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫ –∫–∞–∂–¥–æ–π –ø–∞—Ä–µ —Å–æ—Å–µ–¥–Ω–∏—Ö —Ç–æ—á–µ–∫
            for i in range(0, len(screen_points) - 2, 2):
                # –¶–µ–Ω—Ç—Ä
                vertices.extend([center_x, center_y, 0, 0])
                # –¢–µ–∫—É—â–∞—è —Ç–æ—á–∫–∞
                vertices.extend([screen_points[i], screen_points[i+1], 0, 0])
                # –°–ª–µ–¥—É—é—â–∞—è —Ç–æ—á–∫–∞
                vertices.extend([screen_points[i+2], screen_points[i+3], 0, 0])

            # –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–æ–≤
            indices = list(range(len(vertices) // 4))

            if vertices:
                Mesh(vertices=vertices, indices=indices, mode='triangles')

    def draw_walls(self):
        """–†–∏—Å—É–µ—Ç —Å—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã"""
        if not self.walls:
            return

        Color(*self.wall_color)
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            Line(points=[px1[0], px1[1], px2[0], px2[1]], width=3)

    def draw_current_point(self):
        """–†–∏—Å—É–µ—Ç —Ç–µ–∫—É—â—É—é —Ç–æ—á–∫—É"""
        x, y = self.current_pos_cm
        px_x, px_y = self.cm_to_px(x, y)

        Color(*self.point_color)
        Ellipse(pos=(px_x - 6, px_y - 6), size=(12, 12))

    def save_state(self):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –æ—Ç–º–µ–Ω—ã"""
        state = {
            'walls': [w[:] for w in self.walls],  # –ö–æ–ø–∏—Ä—É–µ–º —Å—Ç–µ–Ω—ã
            'current_pos': self.current_pos_cm[:]  # –ö–æ–ø–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é
        }
        self.undo_stack.append(state)
        # –ü—Ä–∏ –Ω–æ–≤–æ–º –¥–µ–π—Å—Ç–≤–∏–∏ –æ—á–∏—â–∞–µ–º —Å—Ç–µ–∫ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è
        self.redo_stack = []

    def restore_state(self, index):
        """–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏"""
        if 0 <= index < len(self.history):
            state = self.history[index]
            self.walls = [w[:] for w in state['walls']]
            self.current_pos_cm = state['current_pos'][:]
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def undo(self):
        """–û—Ç–º–µ–Ω—è–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ"""
        if len(self.undo_stack) > 1:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ redo
            current_state = self.undo_stack.pop()
            self.redo_stack.append(current_state)

            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            prev_state = self.undo_stack[-1]
            self.walls = [w[:] for w in prev_state['walls']]
            self.current_pos_cm = prev_state['current_pos'][:]

            # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def redo(self):
        """–ü–æ–≤—Ç–æ—Ä—è–µ—Ç –æ—Ç–º–µ–Ω–µ–Ω–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ"""
        if self.redo_stack:
            # –ë–µ—Ä–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–∞
            state = self.redo_stack.pop()
            self.undo_stack.append(state)

            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            self.walls = [w[:] for w in state['walls']]
            self.current_pos_cm = state['current_pos'][:]

            # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def add_wall(self, direction, length_cm):
        """–î–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç–µ–Ω—É –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏"""
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º
        self.save_state()

        # –û—á–∏—â–∞–µ–º –ª–∏–Ω–∏—é-–¥–æ–≤–æ–¥—á–∏–∫ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–π —Å—Ç–µ–Ω—ã
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []

        x1, y1 = self.current_pos_cm

        # –î–ª—è –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –¥–ª–∏–Ω—É
        if direction in ['up_left', 'up_right', 'down_left', 'down_right']:
            # –î–µ–ª–∏–º –¥–ª–∏–Ω—É –Ω–∞ sqrt(2) –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã –¥–∏–∞–≥–æ–Ω–∞–ª–∏
            component_length = length_cm / math.sqrt(2)
        else:
            component_length = length_cm

        if direction == 'up':
            x2, y2 = x1, y1 + component_length
        elif direction == 'down':
            x2, y2 = x1, y1 - component_length
        elif direction == 'left':
            x2, y2 = x1 - component_length, y1
        elif direction == 'right':
            x2, y2 = x1 + component_length, y1
        elif direction == 'up_left':
            x2, y2 = x1 - component_length, y1 + component_length
        elif direction == 'up_right':
            x2, y2 = x1 + component_length, y1 + component_length
        elif direction == 'down_left':
            x2, y2 = x1 - component_length, y1 - component_length
        elif direction == 'down_right':
            x2, y2 = x1 + component_length, y1 - component_length
        else:
            self.undo_stack.pop()  # –û—Ç–º–µ–Ω—è–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            return

        self.walls.append([x1, y1, x2, y2])
        self.current_pos_cm = [x2, y2]
        self.canvas.clear()
        self.draw_editor()
        return (x2, y2)

    def reset(self):
        """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Ä–µ–¥–∞–∫—Ç–æ—Ä"""
        self.current_pos_cm = [0, 0]
        self.walls = []
        self.history = []
        self.history_index = -1
        self.saved_for_redo = []
        self.save_state()
        self.canvas.clear()
        self.draw_editor()

    def on_touch_down(self, touch):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ —Å–µ—Ç–∫—É"""
        if self.collide_point(*touch.pos):
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ —ç—Ç–æ –∫–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏ (scroll)
            if touch.is_mouse_scrolling:
                if touch.button == 'scrolldown':
                    # –£–º–µ–Ω—å—à–∞–µ–º –º–∞—Å—à—Ç–∞–±
                    self.scale = max(0.1, self.scale - 0.05)
                elif touch.button == 'scrollup':
                    # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –º–∞—Å—à—Ç–∞–±
                    self.scale = min(1.0, self.scale + 0.05)

                # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
                self.canvas.clear()
                self.draw_editor()
                return True

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–æ –ª–∏ –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –ª–∏–Ω–∏—é-–¥–æ–≤–æ–¥—á–∏–∫
            if len(self.walls) >= 3 and self.closing_line_points:
                # –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ª–∏–Ω–∏–∏ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
                x1, y1, x2, y2 = self.closing_line_points

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ç–æ—á–∫–∏ –∫–∞—Å–∞–Ω–∏—è –¥–æ –ª–∏–Ω–∏–∏
                distance = self.point_to_line_distance(
                    touch.x, touch.y, x1, y1, x2, y2)

                # –ï—Å–ª–∏ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–Ω—å—à–µ –ø–æ—Ä–æ–≥–∞ (10 –ø–∏–∫—Å–µ–ª–µ–π)
                if distance < 10:
                    # –°–æ–∑–¥–∞–µ–º —Å—Ç–µ–Ω—É, –∑–∞–º—ã–∫–∞—é—â—É—é –∫–æ–º–Ω–∞—Ç—É
                    self.add_closing_wall()
                    return True

            # –ò–Ω–∞—á–µ –Ω–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
            self.dragging = True
            self.last_touch_pos = (touch.x, touch.y)
            return True
        return super().on_touch_down(touch)

    def add_closing_wall(self):
        """–î–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç–µ–Ω—É, –∑–∞–º—ã–∫–∞—é—â—É—é –∫–æ–º–Ω–∞—Ç—É (–ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –ª–∏–Ω–∏—é-–¥–æ–≤–æ–¥—á–∏–∫)"""
        if len(self.walls) < 3 or not self.closing_line_start or not self.closing_line_end:
            return

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –∏–∑–º–µ–Ω–µ–Ω–∏–µ–º
        self.save_state()

        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–µ–Ω—É –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ –∫ –ø–µ—Ä–≤–æ–π
        x1, y1 = self.closing_line_end  # –ö–æ–Ω–µ—Ü –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å—Ç–µ–Ω—ã
        x2, y2 = self.closing_line_start  # –ù–∞—á–∞–ª–æ –ø–µ—Ä–≤–æ–π —Å—Ç–µ–Ω—ã

        self.walls.append([x1, y1, x2, y2])
        self.current_pos_cm = [x2, y2]

        # –û—á–∏—â–∞–µ–º –ª–∏–Ω–∏—é-–¥–æ–≤–æ–¥—á–∏–∫
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []

        # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
        self.canvas.clear()
        self.draw_editor()

    def on_touch_move(self, touch):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –ø–∞–ª—å—Ü–∞/–º—ã—à–∏"""
        if self.dragging and self.last_touch_pos:
            # –í—ã—á–∏—Å–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
            dx = touch.x - self.last_touch_pos[0]
            dy = touch.y - self.last_touch_pos[1]

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
            self.offset_x += dx
            self.offset_y += dy

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
            self.last_touch_pos = (touch.x, touch.y)

            # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º
            self.canvas.clear()
            self.draw_editor()

            return True
        return super().on_touch_move(touch)

    def on_touch_up(self, touch):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è"""
        self.dragging = False
        self.last_touch_pos = None
        return super().on_touch_up(touch)

============================================================
–§–ê–ô–õ: widgets\layout_widget.py
============================================================

from kivy.uix.widget import Widget
from kivy.graphics import Color, Line, Rectangle, Mesh
from kivy.properties import NumericProperty, ObjectProperty, BooleanProperty
from kivy.metrics import dp
from kivy.core.text import Label as CoreLabel
from kivy.graphics import StencilPush
from kivy.clock import Clock
from functools import partial
from kivy.graphics.stencil_instructions import StencilPush, StencilUse, StencilUnUse, StencilPop


class LayoutWidget(Widget):
    """–í–∏–¥–∂–µ—Ç –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–∞—Å–∫–ª–∞–¥–∫–∏ 60√ó60 —Å–º"""

    scale = NumericProperty(0.3)
    offset_x = NumericProperty(0)
    offset_y = NumericProperty(0)
    grid_offset_x = NumericProperty(0)  # –°–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ (0-59 —Å–º)
    grid_offset_y = NumericProperty(0)
    on_grid_move = ObjectProperty(None)  # Callback –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    dragging_enabled = BooleanProperty(True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # –î–∞–Ω–Ω—ã–µ –∫–æ–º–Ω–∞—Ç—ã
        self.walls = []
        self.layout = None
        self.room_bounds = None  # –ì—Ä–∞–Ω–∏—Ü—ã –∫–æ–º–Ω–∞—Ç—ã
        self.is_rotated = False  # –§–ª–∞–≥ –ø–æ–≤–æ—Ä–æ—Ç–∞
        self.rotation_angle = 0  # –£–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞
        self.redraw_scheduled = False
        self.last_redraw_time = 0
        self.dragging_enabled = True
        self.panning = False  # –î–ª—è —Ä–µ–∂–∏–º–∞ –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è
        self.last_pan_pos = None

        # –î–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
        self.dragging = False
        self.last_touch_pos = None

        # –¶–≤–µ—Ç–∞ —Å–æ–≥–ª–∞—Å–Ω–æ —Ä–µ–¥–∞–∫—Ç–æ—Ä—É
        self.bg_color = (0.12, 0.13, 0.13, 1)      # #1e2022 - —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω
        self.wall_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - —Å–≤–µ—Ç–ª—ã–µ —Å—Ç–µ–Ω—ã
        # #52616b - —Å–µ—Ä—ã–π –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ–π –∫–æ–º–Ω–∞—Ç—ã
        self.room_color = (0.32, 0.38, 0.42, 1)
        self.grid_color = (0.79, 0.84, 0.87, 0.7)  # #c9d6df - —Ü–≤–µ—Ç —Å–µ—Ç–∫–∏
        self.full_tile_color = (0.9, 0.9, 0.9, 0.3)  # –¶–≤–µ—Ç —Ü–µ–ª—ã—Ö –ø–ª–∏—Ç–æ–∫
        self.cut_tile_color = (0.7, 0.7, 0.7, 0.3)   # –¶–≤–µ—Ç —Ä–µ–∑–∞–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫
        self.text_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞

        self.bind(size=self._update_canvas)

    def _update_canvas(self, *args):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –∫–∞–Ω–≤–∞—Å –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –≤–∏–¥–∂–µ—Ç–∞"""
        try:
            if hasattr(self, 'room_bounds') and self.room_bounds:
                # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞
                self.center_room()

            if hasattr(self, 'draw_layout'):
                self.draw_layout()
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–∞–Ω–≤–∞—Å–∞: {e}")

    def set_room(self, walls):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã –∏ —Ü–µ–Ω—Ç—Ä–∏—Ä—É–µ—Ç –µ–µ –Ω–∞ —ç–∫—Ä–∞–Ω–µ"""
        self.walls = walls
        if not walls:
            return

        # –ù–∞—Ö–æ–¥–∏–º –≥—Ä–∞–Ω–∏—Ü—ã –∫–æ–º–Ω–∞—Ç—ã
        all_x = []
        all_y = []
        for wall in walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        if not all_x or not all_y:
            return

        self.room_bounds = {
            'min_x': min(all_x), 'max_x': max(all_x),
            'min_y': min(all_y), 'max_y': max(all_y)
        }

        # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–Ω–∞—Ç—É
        self.center_room()

        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –≤ 0 –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –Ω–∞—á–∞–ª–∞
        self.grid_offset_x = 0
        self.grid_offset_y = 0

        self.draw_layout()

    def center_room(self):
        """–¶–µ–Ω—Ç—Ä–∏—Ä—É–µ—Ç –∫–æ–º–Ω–∞—Ç—É –≤ —Ä–∞–±–æ—á–µ–π –æ–±–ª–∞—Å—Ç–∏ —Å —É—á–µ—Ç–æ–º —Ç—É–ª–±–∞—Ä–æ–≤"""
        if not self.room_bounds:
            return

        min_x, max_x = self.room_bounds['min_x'], self.room_bounds['max_x']
        min_y, max_y = self.room_bounds['min_y'], self.room_bounds['max_y']

        room_width = max_x - min_x
        room_height = max_y - min_y

        # –ó–∞—â–∏—Ç–∞ –æ—Ç –Ω—É–ª–µ–≤—ã—Ö —Ä–∞–∑–º–µ—Ä–æ–≤
        if room_width <= 0:
            room_width = 10
        if room_height <= 0:
            room_height = 10

        # –í—ã—á–∏—Å–ª—è–µ–º –º–∞—Å—à—Ç–∞–± —Å —É—á–µ—Ç–æ–º –æ—Ç—Å—Ç—É–ø–æ–≤
        # –£—á–∏—Ç—ã–≤–∞–µ–º, —á—Ç–æ –≤–µ—Ä—Ö–Ω–∏–π —Ç—É–ª–±–∞—Ä = 10%, –Ω–∏–∂–Ω–∏–µ –ø–∞–Ω–µ–ª–∏ = 10% (–∏—Ç–æ–≥–æ 80% –¥–æ—Å—Ç—É–ø–Ω–æ)
        # 12% —Å–≤–µ—Ä—Ö—É (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø –¥–ª—è –≤–µ—Ä—Ö–Ω–µ–≥–æ —Ç—É–ª–±–∞—Ä–∞)
        padding_top = 0.12
        padding_bottom = 0.12  # 8% —Å–Ω–∏–∑—É (–º–µ–Ω—å—à–µ, —á–µ–º —Å–≤–µ—Ä—Ö—É)
        padding_sides = 0.10  # 10% —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã

        available_height = self.height * (1 - padding_top - padding_bottom)
        available_width = self.width * (1 - 2 * padding_sides)

        scale_x = available_width / room_width if room_width > 0 else 0.3
        scale_y = available_height / room_height if room_height > 0 else 0.3

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–± –¥–ª—è –≤–ø–∏—Å—ã–≤–∞–Ω–∏—è
        self.scale = min(scale_x, scale_y)

        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞—Å—à—Ç–∞–±
        self.scale = max(0.1, min(self.scale, 1.0))

        # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–æ–º–Ω–∞—Ç—É —Å —É—á–µ—Ç–æ–º –æ—Ç—Å—Ç—É–ø–æ–≤
        room_center_x = (min_x + max_x) / 2
        room_center_y = (min_y + max_y) / 2

        widget_center_x = self.width / 2
        widget_center_y = self.height / 2

        self.offset_x = widget_center_x - room_center_x * self.scale
        self.offset_y = widget_center_y - room_center_y * self.scale

        # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø–æ Y, —á—Ç–æ–±—ã —É—á–µ—Å—Ç—å —Ä–∞–∑–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É
        bottom_bound = self.offset_y + min_y * self.scale
        top_bound = self.offset_y + max_y * self.scale

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã –æ—Ç –≥—Ä–∞–Ω–∏—Ü
        min_top_padding = self.height * padding_top
        min_bottom_padding = self.height * padding_bottom

        # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≤–µ—Ä—Ö–Ω–∏–π –æ—Ç—Å—Ç—É–ø
        if top_bound > self.height - min_top_padding:
            self.offset_y -= (top_bound - (self.height - min_top_padding))

        # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –Ω–∏–∂–Ω–∏–π –æ—Ç—Å—Ç—É–ø
        if bottom_bound < min_bottom_padding:
            self.offset_y += (min_bottom_padding - bottom_bound)

    def cm_to_px(self, cm_x, cm_y):
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä—ã –≤ –ø–∏–∫—Å–µ–ª–∏"""
        # –ë–ï–ó –ü–û–í–û–†–û–¢–ê - –ø—Ä–æ—Å—Ç–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ —Å–º–µ—â–µ–Ω–∏–µ
        px_x = self.offset_x + cm_x * self.scale
        px_y = self.offset_y + cm_y * self.scale
        return px_x, px_y

    def draw_layout(self):
        self.canvas.clear()

        with self.canvas:
            # –¢–µ–º–Ω—ã–π —Ñ–æ–Ω
            Color(*self.bg_color)
            Rectangle(pos=self.pos, size=self.size)

            # 1. –†–∏—Å—É–µ–º –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–Ω–∞—Ç—ã
            self.draw_room_fill()

            # 2. –†–∏—Å—É–µ–º –ø–ª–∏—Ç–∫–∏ —Å–µ—Ç–∫–∏ 60√ó60
            self.draw_grid_tiles()

            # 3. –†–∏—Å—É–µ–º —Å—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã –ø–æ–≤–µ—Ä—Ö
            self.draw_walls()

            # 4. –†–∏—Å—É–µ–º —Ü–∏—Ñ—Ä—ã –ü–û–°–õ–ï–î–ù–ò–ú–ò, –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
            self.draw_all_cut_dimensions()

    def draw_all_cut_dimensions(self):
        """–†–∏—Å—É–µ—Ç —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è –í–°–ï–• —Ä–µ–∑–∞–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫, –ø–æ–∫–∞–∑—ã–≤–∞—è —Ç–æ–ª—å–∫–æ –æ–±—Ä–µ–∑–∞–Ω–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã"""
        if not self.layout or not self.layout.tiles:
            return

        for tile in self.layout.tiles:
            if tile['type'] != 'cut':
                continue

            # –ë–µ—Ä–µ–º —Ç–æ—á–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–æ–≤
            remaining_x = tile.get('cut_x', 60.0)  # –ü–æ–ª–µ–∑–Ω—ã–π —Ä–∞–∑–º–µ—Ä X
            remaining_y = tile.get('cut_y', 60.0)  # –ü–æ–ª–µ–∑–Ω—ã–π —Ä–∞–∑–º–µ—Ä Y

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–∏–µ —Ä–∞–∑–º–µ—Ä—ã –Ω—É–∂–Ω–æ –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å (—Ç–æ–ª—å–∫–æ –æ–±—Ä–µ–∑–∞–Ω–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã)
            texts = []

            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ X, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –æ–±—Ä–µ–∑–∞–Ω (–º–µ–Ω—å—à–µ 59.5 —Å–º —Å –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å—é)
            if remaining_x < 59.5:  # –° –Ω–µ–±–æ–ª—å—à–æ–π –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç—å—é –¥–ª—è —É—á–µ—Ç–∞ –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
                texts.append(f"{int(round(remaining_x))}")

            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ Y, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω –æ–±—Ä–µ–∑–∞–Ω
            if remaining_y < 59.5:
                texts.append(f"{int(round(remaining_y))}")

            # –ï—Å–ª–∏ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã —Ü–µ–ª—ã–µ (–∏–ª–∏ –ø–æ—á—Ç–∏ —Ü–µ–ª—ã–µ), –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∏—á–µ–≥–æ
            if not texts:
                continue

            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç: –µ—Å–ª–∏ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã –æ–±—Ä–µ–∑–∞–Ω—ã - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±–∞ —Ä–∞–∑–º–µ—Ä–∞
            if len(texts) == 2:
                text = f"{texts[0]}√ó{texts[1]}"
            else:
                text = texts[0]

            # –¶–µ–Ω—Ç—Ä –ø–ª–∏—Ç–∫–∏ –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            center_x = (x1 + x2) / 2
            center_y = (y1 + y2) / 2
            px_center = self.cm_to_px(center_x, center_y)

            # –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç —Å –Ω–µ–±–æ–ª—å—à–∏–º —à—Ä–∏—Ñ—Ç–æ–º
            label = CoreLabel(
                text=text,
                font_size=9,
                color=self.text_color,
                bold=True
            )
            label.refresh()

            # –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –≤ –ø–ª–∏—Ç–∫–µ
            pos_x = px_center[0] - label.texture.size[0] / 2
            pos_y = px_center[1] - label.texture.size[1] / 2

            # –†–∏—Å—É–µ–º –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
            Color(0, 0, 0, 0.3)  # –ß–µ—Ä–Ω—ã–π —Å 30% –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏
            Rectangle(
                pos=(pos_x - 2, pos_y - 1),
                size=(label.texture.size[0] + 4, label.texture.size[1] + 2)
            )

            # –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
            Color(*self.text_color)
            Rectangle(
                texture=label.texture,
                pos=(pos_x, pos_y),
                size=label.texture.size
            )

    def draw_room_fill(self):
        """–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –∫–æ–º–Ω–∞—Ç—ã –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Ñ–æ—Ä–º"""
        if len(self.walls) < 3:
            return

        # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ—á–∫–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        points = []
        if self.walls:
            points.append((self.walls[0][0], self.walls[0][1]))
            for wall in self.walls:
                points.append((wall[2], wall[3]))
            if points[-1] != points[0]:
                points.append(points[0])

        if len(points) < 4:
            return

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–æ—á–∫–∏ –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        screen_points = []
        for x, y in points:
            px = self.cm_to_px(x, y)
            screen_points.extend([px[0], px[1]])

        if len(screen_points) < 8:
            return

        with self.canvas:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º stencil –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–ª–∏–≤–∫–∏
            StencilPush()
            Color(1, 1, 1, 1)

            # –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –¥–ª—è stencil
            Line(points=screen_points, close=True, width=1)

            StencilUse()

            # –ó–∞–ª–∏–≤–∞–µ–º –í–ù–£–¢–†–¨ –∫–æ–Ω—Ç—É—Ä–∞
            Color(*self.room_color)
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª—å—à–∏–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
            min_x = min(screen_points[i]
                        for i in range(0, len(screen_points), 2))
            max_x = max(screen_points[i]
                        for i in range(0, len(screen_points), 2))
            min_y = min(screen_points[i]
                        for i in range(1, len(screen_points), 2))
            max_y = max(screen_points[i]
                        for i in range(1, len(screen_points), 2))
            Rectangle(pos=(min_x, min_y), size=(max_x-min_x, max_y-min_y))

            StencilUnUse()
            StencilPop()

            # –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –ø–æ–≤–µ—Ä—Ö –∑–∞–ª–∏–≤–∫–∏
            Color(*self.wall_color)
            Line(points=screen_points, close=True, width=2)

    def draw_walls(self):
        """–†–∏—Å—É–µ—Ç —Å—Ç–µ–Ω—ã –∫–æ–º–Ω–∞—Ç—ã"""
        if not self.walls:
            return

        Color(*self.wall_color)
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            Line(points=[px1[0], px1[1], px2[0], px2[1]], width=3)

    def draw_grid_tiles(self):
        """–†–∏—Å—É–µ—Ç —Å–µ—Ç–∫—É 60√ó60 –≤ –≤–∏–¥–µ –ø–ª–∏—Ç–æ–∫ (—Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ –∫–æ–º–Ω–∞—Ç—ã)"""
        if not self.layout or not self.layout.tiles:
            return

        # –†–∏—Å—É–µ–º –∑–∞–ª–∏–≤–∫—É –ø–ª–∏—Ç–æ–∫
        for tile in self.layout.tiles:
            # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–ª–∏—Ç–∫–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω–µ –∫–æ–º–Ω–∞—Ç—ã
            if tile['type'] == 'outside':
                continue

            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è —Ä–µ–∑–∞–Ω—ã—Ö –ø–ª–∏—Ç–æ–∫: –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ –æ–±–∞ —Ä–∞–∑–º–µ—Ä–∞ –º–µ–Ω—å—à–µ 1 —Å–º
            if tile['type'] == 'cut':
                cut_x = tile.get('cut_x', 0)
                cut_y = tile.get('cut_y', 0)
                if cut_x < 1.0 and cut_y < 1.0:
                    continue

            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            # –†–∏—Å—É–µ–º –∑–∞–ª–∏–≤–∫—É –ø–ª–∏—Ç–∫–∏
            if tile['type'] == 'full':
                Color(*self.full_tile_color)
                Rectangle(pos=px1, size=(px2[0]-px1[0], px2[1]-px1[1]))
            else:  # cut
                Color(*self.cut_tile_color)
                Rectangle(pos=px1, size=(px2[0]-px1[0], px2[1]-px1[1]))

        # –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä—ã –ø–ª–∏—Ç–æ–∫
        Color(*self.grid_color)
        for tile in self.layout.tiles:
            if tile['type'] == 'outside':
                continue
            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            # –†–∏—Å—É–µ–º –∫–æ–Ω—Ç—É—Ä –ø–ª–∏—Ç–∫–∏
            Line(rectangle=(px1[0], px1[1], px2[0] -
                 px1[0], px2[1] - px1[1]), width=1)

    # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –æ—Ç—Ö–æ–¥–æ–≤:

    def schedule_redraw(self):
        """–ü–ª–∞–Ω–∏—Ä—É–µ—Ç –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π"""
        if not self.redraw_scheduled:
            self.redraw_scheduled = True
            Clock.schedule_once(self.redraw_now, 0.05)  # 20 FPS

    def redraw_now(self, dt):
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É"""
        self.redraw_scheduled = False
        self.draw_layout()

    def move_grid(self, dx_cm, dy_cm):
        """–°–º–µ—â–∞–µ—Ç —Å–µ—Ç–∫—É –Ω–∞ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–º"""
        self.grid_offset_x = (self.grid_offset_x + dx_cm) % 60
        self.grid_offset_y = (self.grid_offset_y + dy_cm) % 60

        # –í—ã–∑—ã–≤–∞–µ–º callback –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        if self.on_grid_move:
            self.on_grid_move(self.grid_offset_x, self.grid_offset_y)

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫—É
        self.schedule_redraw()

    def on_touch_move(self, touch):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏/–ø–∞–ª—å—Ü–∞ —Å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º –ø–æ–∑–∏—Ü–∏–∏"""
        if not self.collide_point(*touch.pos):
            return False

        if hasattr(self, 'panning') and self.panning:
            # –ü–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ
            dx = touch.x - self.last_pan_pos[0]
            dy = touch.y - self.last_pan_pos[1]
            self.offset_x += dx
            self.offset_y += dy
            self.last_pan_pos = (touch.x, touch.y)
            self.draw_layout()
            return True

        if hasattr(self, 'dragging') and self.dragging and self.dragging_enabled:
            # –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Å–µ—Ç–∫–∏ - –ò–°–ü–†–ê–í–õ–ï–ù–û: —É–±–∏—Ä–∞–µ–º –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –∏ –∑–∞–¥–µ—Ä–∂–∫—É
            dx_px = touch.x - self.last_touch_pos[0]
            dy_px = touch.y - self.last_touch_pos[1]

            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å–∞–Ω—Ç–∏–º–µ—Ç—Ä—ã –ë–ï–ó –æ–∫—Ä—É–≥–ª–µ–Ω–∏—è
            dx_cm = dx_px / self.scale
            dy_cm = dy_px / self.scale

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ —Å–µ—Ç–∫–∏ –¢–û–ß–ù–û –Ω–∞ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            self.grid_offset_x += dx_cm
            self.grid_offset_y += dy_cm

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ
            self.last_touch_pos = (touch.x, touch.y)

            # –í—ã–∑—ã–≤–∞–µ–º callback –ù–ï–ú–ï–î–õ–ï–ù–ù–û –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
            if hasattr(self, 'on_grid_move') and callable(self.on_grid_move):
                self.on_grid_move()

            # –ü–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ
            self.draw_layout()

            return True

        return super().on_touch_move(touch)

    def zoom_at_center(self, zoom_in=True):
        """–ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ü–µ–Ω—Ç—Ä–∞ –≤–∏–¥–∂–µ—Ç–∞"""
        # –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Ü–µ–Ω—Ç—Ä –≤–∏–¥–∂–µ—Ç–∞ –≤ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö
        center_world_x = (self.width / 2 - self.offset_x) / self.scale
        center_world_y = (self.height / 2 - self.offset_y) / self.scale

        # –ò–∑–º–µ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–±
        if zoom_in:
            # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–± —É–≤–µ–ª–∏—á–µ–Ω –¥–æ 3.0x
            new_scale = min(3.0, self.scale + 0.05)
        else:
            new_scale = max(0.1, self.scale - 0.05)

        # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã —Ü–µ–Ω—Ç—Ä –æ—Å—Ç–∞–ª—Å—è –Ω–∞ –º–µ—Å—Ç–µ
        new_offset_x = self.width / 2 - center_world_x * new_scale
        new_offset_y = self.height / 2 - center_world_y * new_scale

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
        self.scale = new_scale
        self.offset_x = new_offset_x
        self.offset_y = new_offset_y

        # –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        self.apply_bounds_protection()
        self.canvas.clear()
        if hasattr(self, 'draw_editor'):
            self.draw_editor()
        else:
            self.draw_layout()

    def apply_bounds_protection(self):
        """–ó–∞—â–∏—â–∞–µ—Ç –æ—Ç –≤—ã—Ö–æ–¥–∞ –∫–æ–º–Ω–∞—Ç—ã –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –≤–∏–¥–∂–µ—Ç–∞"""
        if not self.room_bounds:
            return

        min_x = self.room_bounds['min_x']
        max_x = self.room_bounds['max_x']
        min_y = self.room_bounds['min_y']
        max_y = self.room_bounds['max_y']

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –≤–∏–¥–∏–º–æ–π –æ–±–ª–∞—Å—Ç–∏
        visible_min_x = (0 - self.offset_x) / self.scale
        visible_max_x = (self.width - self.offset_x) / self.scale
        visible_min_y = (0 - self.offset_y) / self.scale
        visible_max_y = (self.height - self.offset_y) / self.scale

        # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ª–µ–≤—É—é –≥—Ä–∞–Ω–∏—Ü—É
        if max_x < visible_min_x:
            self.offset_x += (visible_min_x - max_x) * self.scale
        # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –ø—Ä–∞–≤—É—é –≥—Ä–∞–Ω–∏—Ü—É
        if min_x > visible_max_x:
            self.offset_x -= (min_x - visible_max_x) * self.scale
        # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –Ω–∏–∂–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É
        if max_y < visible_min_y:
            self.offset_y += (visible_min_y - max_y) * self.scale
        # –ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –≤–µ—Ä—Ö–Ω—é—é –≥—Ä–∞–Ω–∏—Ü—É
        if min_y > visible_max_y:
            self.offset_y -= (min_y - visible_max_y) * self.scale

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            if touch.is_mouse_scrolling:
                # –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ–≥–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç
                if touch.button == 'scrolldown':
                    self.scale = max(0.1, self.scale - 0.05)
                elif touch.button == 'scrollup':
                    self.scale = min(1.0, self.scale + 0.05)
                self.draw_layout()
                return True

            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–≤–æ–π–Ω–æ–≥–æ —Ç–∞–ø–∞ –¥–ª—è —Å–±—Ä–æ—Å–∞
            if touch.is_double_tap:
                self.center_room()
                self.draw_layout()
                return True

            # –í —Ä–µ–∂–∏–º–µ –ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏—è - –Ω–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
            if not self.dragging_enabled:
                self.panning = True
                self.last_pan_pos = touch.pos
                return True

            # –í —Ä–µ–∂–∏–º–µ —Å–µ—Ç–∫–∏ - –Ω–∞—á–∏–Ω–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ —Å–µ—Ç–∫–∏
            elif self.dragging_enabled:
                self.dragging = True
                self.last_touch_pos = touch.pos

                # –ù–û–í–û–ï: –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏
                # –≠—Ç–æ —Ä–µ—à–∏—Ç –ø—Ä–æ–±–ª–µ–º—É —Å —à–∞–≥–æ–º 5 —Å–º
                if hasattr(self, 'last_touch_time'):
                    current_time = Clock.get_time()
                    if current_time - self.last_touch_time < 0.2:  # –¥–≤–æ–π–Ω–æ–π –∫–ª–∏–∫
                        self.center_room()
                        self.draw_layout()
                        return True
                self.last_touch_time = Clock.get_time()

                return True
            
        return super().on_touch_down(touch)

    def on_touch_up(self, touch):
        self.dragging = False
        self.panning = False
        self.last_touch_pos = None
        self.last_pan_pos = None
        return super().on_touch_up(touch)
