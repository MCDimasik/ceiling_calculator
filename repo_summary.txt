РЕПОЗИТОРИЙ: C:\Users\noize\Documents\ceiling_calculator
================================================================================

СТРУКТУРА ПРОЕКТА:
----------------------------------------
ceiling_calculator/
├── .gitignore
├── buildozer.spec
├── ceiling_calculator.db
├── database.py
├── main.py
├── models.py
├── repo_to_text.py
├── .github/
│   ├── workflows/
│   │   ├── build-apk.yml
├── fonts/
│   ├── DejaVuSans.ttf
├── screens/
│   ├── __init__.py
│   ├── layout_screen.py
│   ├── main_screen.py
│   ├── projects_screen.py
│   ├── room_editor.py
│   ├── rooms_screen.py
├── utils/
│   ├── __init__.py
├── widgets/
│   ├── __init__.py
│   ├── grid_widget.py
│   ├── layout_widget.py

================================================================================


============================================================
ФАЙЛ: .github\workflows\build-apk.yml
============================================================

name: Build Simple Kivy APK

on: workflow_dispatch

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Python 3.8
      uses: actions/setup-python@v5
      with:
        python-version: '3.8'
    
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y git openjdk-11-jdk python3-dev zlib1g-dev
    
    - name: Install Buildozer
      run: |
        pip install buildozer==1.4.0
        pip install cython==0.29.21
    
    - name: Create minimal spec
      run: |
        if [ ! -f buildozer.spec ]; then
          echo "[app]" > buildozer.spec
          echo "title = MyApp" >> buildozer.spec
          echo "package.name = myapp" >> buildozer.spec
          echo "package.domain = org.test" >> buildozer.spec
          echo "source.dir = ." >> buildozer.spec
          echo "source.include_exts = py,png,jpg,kv" >> buildozer.spec
          echo "version = 1.0" >> buildozer.spec
          echo "requirements = python3,kivy==2.0.0" >> buildozer.spec
          echo "orientation = portrait" >> buildozer.spec
          echo "android.permissions = INTERNET" >> buildozer.spec
          echo "android.archs = arm64-v8a" >> buildozer.spec
          echo "android.api = 30" >> buildozer.spec
          echo "android.minapi = 21" >> buildozer.spec
          echo "android.sdk = 30" >> buildozer.spec
          echo "android.ndk = 21.3.6528147" >> buildozer.spec
          echo "debug = 1" >> buildozer.spec
          echo "" >> buildozer.spec
          echo "[buildozer]" >> buildozer.spec
          echo "log_level = 2" >> buildozer.spec
        fi
    
    - name: Accept licenses
      run: |
        mkdir -p ~/.android/licenses
        echo "24333f8a63b6825ea9c5514f83c2829b004d1fee" > ~/.android/licenses/android-sdk-license
    
    - name: Build APK
      run: |
        echo "y" | buildozer android debug
        
        mkdir -p artifacts
        cp bin/*.apk artifacts/app.apk 2>/dev/null || true
    
    - name: Upload APK
      uses: actions/upload-artifact@v4
      with:
        name: app-apk
        path: artifacts/*.apk

============================================================
ФАЙЛ: .gitignore
============================================================



============================================================
ФАЙЛ: buildozer.spec
============================================================

[app]

# (str) Title of your application
title = ceiling Calculator beta

# (str) Package name
package.name = ceiling_calculator_beta

# (str) Package domain (needed for android/ios packaging)
package.domain = org.test

# (str) Source code where the main.py live
source.dir = .

# (list) Source files to include (let empty to include all the files)
source.include_exts = py,png,jpg,kv,atlas

# (list) List of inclusions using pattern matching
#source.include_patterns = assets/*,images/*.png

# (list) Source files to exclude (let empty to not exclude anything)
#source.exclude_exts = spec

# (list) List of directory to exclude (let empty to not exclude anything)
#source.exclude_dirs = tests, bin, venv

# (list) List of exclusions using pattern matching
# Do not prefix with './'
#source.exclude_patterns = license,images/*/*.jpg

# (str) Application versioning (method 1)
version = 0.6

# (str) Application versioning (method 2)
# version.regex = __version__ = ['"](.*)['"]
# version.filename = %(source.dir)s/main.py

# (list) Application requirements
# comma separated e.g. requirements = sqlite3,kivy
requirements = python3,kivy==2.3.0,kivymd==1.2.0,pillow

# (str) Custom source folders for requirements
# Sets custom source for any requirements with recipes
# requirements.source.kivy = ../../kivy

# (str) Presplash of the application
#presplash.filename = %(source.dir)s/data/presplash.png

# (str) Icon of the application
#icon.filename = %(source.dir)s/data/icon.png

# (list) Supported orientations
# Valid options are: landscape, portrait, portrait-reverse or landscape-reverse
orientation = portrait

# (list) List of service to declare
#services = NAME:ENTRYPOINT_TO_PY,NAME2:ENTRYPOINT2_TO_PY

#
# OSX Specific
#

#
# author = © Copyright Info

# change the major version of python used by the app
osx.python_version = 3

# Kivy version to use
osx.kivy_version = 1.9.1

#
# Android specific
#

# (bool) Indicate if the application should be fullscreen or not
fullscreen = 1

# (string) Presplash background color (for android toolchain)
# Supported formats are: #RRGGBB #AARRGGBB or one of the following names:
# red, blue, green, black, white, gray, cyan, magenta, yellow, lightgray,
# darkgray, grey, lightgrey, darkgrey, aqua, fuchsia, lime, maroon, navy,
# olive, purple, silver, teal.
#android.presplash_color = #FFFFFF

# (string) Presplash animation using Lottie format.
# see https://lottiefiles.com/ for examples and https://airbnb.design/lottie/
# for general documentation.
# Lottie files can be created using various tools, like Adobe After Effect or Synfig.
#android.presplash_lottie = "path/to/lottie/file.json"

# (str) Adaptive icon of the application (used if Android API level is 26+ at runtime)
#icon.adaptive_foreground.filename = %(source.dir)s/data/icon_fg.png
#icon.adaptive_background.filename = %(source.dir)s/data/icon_bg.png

# (list) Permissions
# (See https://python-for-android.readthedocs.io/en/latest/buildoptions/#build-options-1 for all the supported syntaxes and properties)
#android.permissions = android.permission.INTERNET, (name=android.permission.WRITE_EXTERNAL_STORAGE;maxSdkVersion=18)

# (list) features (adds uses-feature -tags to manifest)
#android.features = android.hardware.usb.host

# (int) Target Android API, should be as high as possible.
android.api = 31

# (int) Minimum API your APK / AAB will support.
android.minapi = 21

#android.sdk = 20

# (str) Android NDK version to use
android.ndk = 25b

# (int) Android NDK API to use. This is the minimum API your app will support, it should usually match android.minapi.
#android.ndk_api = 21

# (bool) Use --private data storage (True) or --dir public storage (False)
#android.private_storage = True

# (str) Android NDK directory (if empty, it will be automatically downloaded.)
#android.ndk_path =

# (str) Android SDK directory (if empty, it will be automatically downloaded.)
#android.sdk_path =

# (str) ANT directory (if empty, it will be automatically downloaded.)
#android.ant_path =

# (bool) If True, then skip trying to update the Android sdk
# This can be useful to avoid excess Internet downloads or save time
# when an update is due and you just want to test/build your package
# android.skip_update = False

# (bool) If True, then automatically accept SDK license
# agreements. This is intended for automation only. If set to False,
# the default, you will be shown the license when first running
# buildozer.
# android.accept_sdk_license = False

# (str) Android entry point, default is ok for Kivy-based app
#android.entrypoint = org.kivy.android.PythonActivity

# (str) Full name including package path of the Java class that implements Android Activity
# use that parameter together with android.entrypoint to set custom Java class instead of PythonActivity
#android.activity_class_name = org.kivy.android.PythonActivity

# (str) Extra xml to write directly inside the <manifest> element of AndroidManifest.xml
# use that parameter to provide a filename from where to load your custom XML code
#android.extra_manifest_xml = ./src/android/extra_manifest.xml

# (str) Extra xml to write directly inside the <manifest><application> tag of AndroidManifest.xml
# use that parameter to provide a filename from where to load your custom XML arguments:
#android.extra_manifest_application_arguments = ./src/android/extra_manifest_application_arguments.xml

# (str) Full name including package path of the Java class that implements Python Service
# use that parameter to set custom Java class which extends PythonService
#android.service_class_name = org.kivy.android.PythonService

# (str) Android app theme, default is ok for Kivy-based app
# android.apptheme = "@android:style/Theme.NoTitleBar"

# (list) Pattern to whitelist for the whole project
#android.whitelist =

# (str) Path to a custom whitelist file
#android.whitelist_src =

# (str) Path to a custom blacklist file
#android.blacklist_src =

# (list) List of Java .jar files to add to the libs so that pyjnius can access
# their classes. Don't add jars that you do not need, since extra jars can slow
# down the build process. Allows wildcards matching, for example:
# OUYA-ODK/libs/*.jar
#android.add_jars = foo.jar,bar.jar,path/to/more/*.jar

# (list) List of Java files to add to the android project (can be java or a
# directory containing the files)
#android.add_src =

# (list) Android AAR archives to add
#android.add_aars =

# (list) Put these files or directories in the apk assets directory.
# Either form may be used, and assets need not be in 'source.include_exts'.
# 1) android.add_assets = source_asset_relative_path
# 2) android.add_assets = source_asset_path:destination_asset_relative_path
#android.add_assets =

# (list) Put these files or directories in the apk res directory.
# The option may be used in three ways, the value may contain one or zero ':'
# Some examples:
# 1) A file to add to resources, legal resource names contain ['a-z','0-9','_']
# android.add_resources = my_icons/all-inclusive.png:drawable/all_inclusive.png
# 2) A directory, here  'legal_icons' must contain resources of one kind
# android.add_resources = legal_icons:drawable
# 3) A directory, here 'legal_resources' must contain one or more directories, 
# each of a resource kind:  drawable, xml, etc...
# android.add_resources = legal_resources
#android.add_resources =

# (list) Gradle dependencies to add
#android.gradle_dependencies =

# (bool) Enable AndroidX support. Enable when 'android.gradle_dependencies'
# contains an 'androidx' package, or any package from Kotlin source.
# android.enable_androidx requires android.api >= 28
#android.enable_androidx = True

# (list) add java compile options
# this can for example be necessary when importing certain java libraries using the 'android.gradle_dependencies' option
# see https://developer.android.com/studio/write/java8-support for further information
# android.add_compile_options = "sourceCompatibility = 1.8", "targetCompatibility = 1.8"

# (list) Gradle repositories to add {can be necessary for some android.gradle_dependencies}
# please enclose in double quotes 
# e.g. android.gradle_repositories = "maven { url 'https://kotlin.bintray.com/ktor' }"
#android.add_gradle_repositories =

# (list) packaging options to add 
# see https://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.PackagingOptions.html
# can be necessary to solve conflicts in gradle_dependencies
# please enclose in double quotes 
# e.g. android.add_packaging_options = "exclude 'META-INF/common.kotlin_module'", "exclude 'META-INF/*.kotlin_module'"
#android.add_packaging_options =

# (list) Java classes to add as activities to the manifest.
#android.add_activities = com.example.ExampleActivity

# (str) OUYA Console category. Should be one of GAME or APP
# If you leave this blank, OUYA support will not be enabled
#android.ouya.category = GAME

# (str) Filename of OUYA Console icon. It must be a 732x412 png image.
#android.ouya.icon.filename = %(source.dir)s/data/ouya_icon.png

# (str) XML file to include as an intent filters in <activity> tag
#android.manifest.intent_filters =

# (list) Copy these files to src/main/res/xml/ (used for example with intent-filters)
#android.res_xml = PATH_TO_FILE,

# (str) launchMode to set for the main activity
#android.manifest.launch_mode = standard

# (str) screenOrientation to set for the main activity.
# Valid values can be found at https://developer.android.com/guide/topics/manifest/activity-element
#android.manifest.orientation = fullSensor

# (list) Android additional libraries to copy into libs/armeabi
#android.add_libs_armeabi = libs/android/*.so
#android.add_libs_armeabi_v7a = libs/android-v7/*.so
#android.add_libs_arm64_v8a = libs/android-v8/*.so
#android.add_libs_x86 = libs/android-x86/*.so
#android.add_libs_mips = libs/android-mips/*.so

# (bool) Indicate whether the screen should stay on
# Don't forget to add the WAKE_LOCK permission if you set this to True
#android.wakelock = False

# (list) Android application meta-data to set (key=value format)
#android.meta_data =

# (list) Android library project to add (will be added in the
# project.properties automatically.)
#android.library_references =

# (list) Android shared libraries which will be added to AndroidManifest.xml using <uses-library> tag
#android.uses_library =

# (str) Android logcat filters to use
#android.logcat_filters = *:S python:D

# (bool) Android logcat only display log for activity's pid
#android.logcat_pid_only = False

# (str) Android additional adb arguments
#android.adb_args = -H host.docker.internal

# (bool) Copy library instead of making a libpymodules.so
#android.copy_libs = 1

# (list) The Android archs to build for, choices: armeabi-v7a, arm64-v8a, x86, x86_64
# In past, was `android.arch` as we weren't supporting builds for multiple archs at the same time.
android.archs = arm64-v8a

# (int) overrides automatic versionCode computation (used in build.gradle)
# this is not the same as app version and should only be edited if you know what you're doing
# android.numeric_version = 1

# (bool) enables Android auto backup feature (Android API >=23)
android.allow_backup = True

# (str) XML file for custom backup rules (see official auto backup documentation)
# android.backup_rules =

# (str) If you need to insert variables into your AndroidManifest.xml file,
# you can do so with the manifestPlaceholders property.
# This property takes a map of key-value pairs. (via a string)
# Usage example : android.manifest_placeholders = [myCustomUrl:\"org.kivy.customurl\"]
# android.manifest_placeholders = [:]

# (bool) Skip byte compile for .py files
# android.no-byte-compile-python = False

# (str) The format used to package the app for release mode (aab or apk or aar).
# android.release_artifact = aab

# (str) The format used to package the app for debug mode (apk or aar).
# android.debug_artifact = apk

#
# Python for android (p4a) specific
#

# (str) python-for-android URL to use for checkout
#p4a.url =

# (str) python-for-android fork to use in case if p4a.url is not specified, defaults to upstream (kivy)
#p4a.fork = kivy

# (str) python-for-android branch to use, defaults to master
p4a.branch = master

# (str) python-for-android specific commit to use, defaults to HEAD, must be within p4a.branch
#p4a.commit = HEAD

# (str) python-for-android git clone directory (if empty, it will be automatically cloned from github)
#p4a.source_dir =

# (str) The directory in which python-for-android should look for your own build recipes (if any)
#p4a.local_recipes =

# (str) Filename to the hook for p4a
#p4a.hook =

# (str) Bootstrap to use for android builds
# p4a.bootstrap = sdl2

# (int) port number to specify an explicit --port= p4a argument (eg for bootstrap flask)
#p4a.port =

# Control passing the --use-setup-py vs --ignore-setup-py to p4a
# "in the future" --use-setup-py is going to be the default behaviour in p4a, right now it is not
# Setting this to false will pass --ignore-setup-py, true will pass --use-setup-py
# NOTE: this is general setuptools integration, having pyproject.toml is enough, no need to generate
# setup.py if you're using Poetry, but you need to add "toml" to source.include_exts.
#p4a.setup_py = false

# (str) extra command line arguments to pass when invoking pythonforandroid.toolchain
#p4a.extra_args =



#
# iOS specific
#

# (str) Path to a custom kivy-ios folder
#ios.kivy_ios_dir = ../kivy-ios
# Alternately, specify the URL and branch of a git checkout:
ios.kivy_ios_url = https://github.com/kivy/kivy-ios
ios.kivy_ios_branch = master

# Another platform dependency: ios-deploy
# Uncomment to use a custom checkout
#ios.ios_deploy_dir = ../ios_deploy
# Or specify URL and branch
ios.ios_deploy_url = https://github.com/phonegap/ios-deploy
ios.ios_deploy_branch = 1.10.0

# (bool) Whether or not to sign the code
ios.codesign.allowed = false

# (str) Name of the certificate to use for signing the debug version
# Get a list of available identities: buildozer ios list_identities
#ios.codesign.debug = "iPhone Developer: <lastname> <firstname> (<hexstring>)"

# (str) The development team to use for signing the debug version
#ios.codesign.development_team.debug = <hexstring>

# (str) Name of the certificate to use for signing the release version
#ios.codesign.release = %(ios.codesign.debug)s

# (str) The development team to use for signing the release version
#ios.codesign.development_team.release = <hexstring>

# (str) URL pointing to .ipa file to be installed
# This option should be defined along with `display_image_url` and `full_size_image_url` options.
#ios.manifest.app_url =

# (str) URL pointing to an icon (57x57px) to be displayed during download
# This option should be defined along with `app_url` and `full_size_image_url` options.
#ios.manifest.display_image_url =

# (str) URL pointing to a large icon (512x512px) to be used by iTunes
# This option should be defined along with `app_url` and `display_image_url` options.
#ios.manifest.full_size_image_url =


[buildozer]

# (int) Log level (0 = error only, 1 = info, 2 = debug (with command output))
log_level = 2

# (int) Display warning if buildozer is run as root (0 = False, 1 = True)
warn_on_root = 1

# (str) Path to build artifact storage, absolute or relative to spec file
# build_dir = ./.buildozer

# (str) Path to build output (i.e. .apk, .aab, .ipa) storage
# bin_dir = ./bin

#    -----------------------------------------------------------------------------
#    List as sections
#
#    You can define all the "list" as [section:key].
#    Each line will be considered as a option to the list.
#    Let's take [app] / source.exclude_patterns.
#    Instead of doing:
#
#[app]
#source.exclude_patterns = license,data/audio/*.wav,data/images/original/*
#
#    This can be translated into:
#
#[app:source.exclude_patterns]
#license
#data/audio/*.wav
#data/images/original/*
#


#    -----------------------------------------------------------------------------
#    Profiles
#
#    You can extend section / key with a profile
#    For example, you want to deploy a demo version of your application without
#    HD content. You could first change the title to add "(demo)" in the name
#    and extend the excluded directories to remove the HD content.
#
#[app@demo]
#title = My Application (demo)
#
#[app:source.exclude_patterns@demo]
#images/hd/*
#
#    Then, invoke the command line with the "demo" profile:
#
#buildozer --profile demo android debug

============================================================
ФАЙЛ: database.py
============================================================

# database.py
import sqlite3
import json
from datetime import datetime
from models import Project, Room

DB_NAME = "ceiling_calculator.db"


def init_db():
    """Инициализирует базу данных и создает таблицы."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS projects (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL
    )
    """)
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS rooms (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_id INTEGER NOT NULL,
        name TEXT NOT NULL,
        created_at TEXT NOT NULL,
        walls_json TEXT NOT NULL,
        last_position_json TEXT,
        grid_offset_x INTEGER DEFAULT 0,  -- Новое поле
        grid_offset_y INTEGER DEFAULT 0,  -- Новое поле
        FOREIGN KEY (project_id) REFERENCES projects (id)
    )
    """)
    conn.commit()
    conn.close()


def save_project(project):
    """Сохраняет проект (и его комнаты) в базу данных."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        if project.id is None:
            cursor.execute("""
            INSERT INTO projects (name, created_at) VALUES (?, ?)
            """, (project.name, project.created_at.isoformat()))
            project.id = cursor.lastrowid
        else:
            cursor.execute("""
            UPDATE projects SET name = ?, created_at = ?
            WHERE id = ?
            """, (project.name, project.created_at.isoformat(), project.id))

        cursor.execute("DELETE FROM rooms WHERE project_id = ?", (project.id,))

        for room in project.rooms:
            walls_json_str = json.dumps(room.walls)
            last_pos_json_str = json.dumps(room.last_position) if hasattr(
                room, 'last_position') and room.last_position else None
            grid_offset_x = getattr(room, 'grid_offset_x', 0)
            grid_offset_y = getattr(room, 'grid_offset_y', 0)
            cursor.execute("""
            INSERT INTO rooms (project_id, name, created_at, walls_json, last_position_json, grid_offset_x, grid_offset_y)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (project.id, room.name, room.created_at.isoformat(), walls_json_str, last_pos_json_str, grid_offset_x, grid_offset_y))

        conn.commit()
        print(f"Проект '{project.name}' успешно сохранен в базу данных.")
    except sqlite3.Error as e:
        print(f"Ошибка при сохранении проекта в базу данных: {e}")
        conn.rollback()
    finally:
        conn.close()


def load_project(project_id):
    """Загружает проект (и его комнаты) из базы данных по ID."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute(
            "SELECT id, name, created_at FROM projects WHERE id = ?", (project_id,))
        row = cursor.fetchone()
        if row is None:
            return None
        project = Project(row[1])
        project.id = row[0]
        project.created_at = datetime.fromisoformat(row[2])

        cursor.execute(
            "SELECT id, name, created_at, walls_json, last_position_json, grid_offset_x, grid_offset_y FROM rooms WHERE project_id = ?", (project_id,))
        for room_row in cursor.fetchall():
            room = Room(room_row[1])
            room.id = room_row[0]
            room.created_at = datetime.fromisoformat(room_row[2])
            room.walls = json.loads(room_row[3])
            if room_row[4]:
                room.last_position = json.loads(room_row[4])
            # Новое поле
            room.grid_offset_x = room_row[5] if room_row[5] else 0
            # Новое поле
            room.grid_offset_y = room_row[6] if room_row[6] else 0
            project.rooms.append(room)

        print(f"Проект '{project.name}' успешно загружен из базы данных.")
        return project
    except sqlite3.Error as e:
        print(f"Ошибка при загрузке проекта из базы данных: {e}")
        return None
    finally:
        conn.close()


def load_all_projects():
    """Загружает список всех проектов (без комнат)."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute(
            "SELECT id, name, created_at FROM projects ORDER BY created_at DESC")
        rows = cursor.fetchall()
        projects = []
        for row in rows:
            proj = Project(row[1])
            proj.id = row[0]
            proj.created_at = datetime.fromisoformat(row[2])
            projects.append(proj)
        return projects
    except sqlite3.Error as e:
        print(f"Ошибка при загрузке списка проектов: {e}")
        return []
    finally:
        conn.close()


def delete_project(project_id):
    """Удаляет проект и все его комнаты из базы данных."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute("DELETE FROM rooms WHERE project_id = ?", (project_id,))
        cursor.execute("DELETE FROM projects WHERE id = ?", (project_id,))
        conn.commit()
        print(f"Проект с ID {project_id} и его комнаты успешно удалены.")
        return True
    except sqlite3.Error as e:
        print(f"Ошибка при удалении проекта: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()


def delete_room_from_project(project_id, room_id):
    """Удаляет комнату из базы данных, связанной с проектом."""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    try:
        cursor.execute(
            "DELETE FROM rooms WHERE id = ? AND project_id = ?", (room_id, project_id))
        conn.commit()
        if cursor.rowcount > 0:
            print(
                f"Комната с ID {room_id} из проекта с ID {project_id} успешно удалена.")
            return True
        else:
            print(
                f"Комната с ID {room_id} не найдена в проекте с ID {project_id}.")
            return False
    except sqlite3.Error as e:
        print(f"Ошибка при удалении комнаты: {e}")
        conn.rollback()
        return False
    finally:
        conn.close()

============================================================
ФАЙЛ: main.py
============================================================

from kivy.app import App
from kivy.uix.screenmanager import ScreenManager
from kivy.core.window import Window
from kivy.utils import get_color_from_hex, platform  # ← ДОБАВЛЕН импорт platform
# Импортируем экраны
from screens.main_screen import MainScreen
from screens.projects_screen import ProjectsScreen
from screens.rooms_screen import RoomsScreen
from screens.room_editor import RoomEditorScreen
from screens.layout_screen import LayoutScreen
import os

# Это строка для отладки на Windows, на Android ломает рендеринг и координаты касаний, убрать перед сборкой
os.environ['KIVY_GL_BACKEND'] = 'angle_sdl2'

# Устанавливаем размер ТОЛЬКО для десктопа (на Android игнорируется и ломает координаты!)
if platform != 'android':
    Window.size = (320, 640)

Window.clearcolor = (1, 1, 1, 1)  # Белый фон


class CeilingCalculatorApp(App):
    def build(self):
        # ← КРИТИЧНО: настраиваем масштабирование ДО создания виджетов
        if platform == 'android':
            # Гарантируем полноэкранный режим с правильным масштабированием
            Window.softinput_mode = 'below_target'  # Клавиатура не закроет поля ввода
            
        # Создаем менеджер экранов
        sm = ScreenManager()
        sm.current_project = None
        sm.current_room = None

        # Добавляем экраны
        sm.add_widget(MainScreen(name='main'))
        sm.add_widget(ProjectsScreen(name='projects'))
        sm.add_widget(RoomsScreen(name='rooms'))
        sm.add_widget(RoomEditorScreen(name='room_editor'))
        sm.add_widget(LayoutScreen(name='layout'))
        
        # Применяем стиль
        Window.clearcolor = get_color_from_hex('#FFFFFF')
        self.theme_cls = type('Theme', (), {
            'primary_color': get_color_from_hex('#000000'),
            'text_color': get_color_from_hex('#000000')
        })

        return sm


if __name__ == '__main__':
    CeilingCalculatorApp().run()

============================================================
ФАЙЛ: models.py
============================================================

# models.py (изменим класс Room)
import json
from datetime import datetime
import math


class Project:
    """Класс проекта (здания/объекта)"""

    def __init__(self, name):
        self.id = None
        self.name = name
        self.created_at = datetime.now()
        self.rooms = []  # Список объектов Room

    def to_dict(self):
        """Конвертирует проект в словарь"""
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat(),
            'rooms': [room.to_dict() for room in self.rooms]
        }

    @classmethod
    def from_dict(cls, data):
        """Создает проект из словаря"""
        project = cls(data['name'])
        project.id = data['id']
        project.created_at = datetime.fromisoformat(data['created_at'])
        project.rooms = [Room.from_dict(room_data)
                         for room_data in data['rooms']]
        return project


class Room:
    """Класс комнаты"""

    def __init__(self, name):
        self.id = None
        self.name = name
        self.created_at = datetime.now()
        self.walls = []  # Список стен в формате [[x1, y1, x2, y2], ...]
        self.last_position = None  # Последняя позиция курсора в редакторе
        self.grid_offset_x = 0  # Сохранённое смещение сетки (критично!)
        self.grid_offset_y = 0  # Сохранённое смещение сетки (критично!)

    def to_dict(self):
        """Конвертирует комнату в словарь"""
        return {
            'id': self.id,
            'name': self.name,
            'created_at': self.created_at.isoformat(),
            'walls': self.walls,
            'last_position': self.last_position,
            'grid_offset_x': self.grid_offset_x,  # Новое поле
            'grid_offset_y': self.grid_offset_y   # Новое поле
        }

    @classmethod
    def from_dict(cls, data):
        """Создает комнату из словаря"""
        room = cls(data['name'])
        room.id = data['id']
        room.created_at = datetime.fromisoformat(data['created_at'])
        room.walls = data['walls']
        room.last_position = data.get('last_position')
        room.grid_offset_x = data.get('grid_offset_x', 0)  # Новое поле
        room.grid_offset_y = data.get('grid_offset_y', 0)  # Новое поле
        return room


class CeilingLayout:
    """Класс для расчета раскладки потолка 60×60 см"""
    TILE_SIZE = 60  # 60 см

    def __init__(self, room):
        self.room = room
        self.grid_offset_x = room.grid_offset_x if hasattr(
            room, 'grid_offset_x') else 0
        self.grid_offset_y = room.grid_offset_y if hasattr(
            room, 'grid_offset_y') else 0
        self.tiles = []
        self.full_tiles = 0
        self.cut_tiles = 0
        self.waste_percentage = 0
        self.room_polygon = self._build_room_polygon()
        self.room_bounds = self.get_room_bounds()
        self.room_area_sqm = 0.0

    def _build_room_polygon(self):
        """Предварительно строит полигон комнаты один раз"""
        if not self.room.walls:
            return []
        points = []
        for wall in self.room.walls:
            points.append((wall[0], wall[1]))
            points.append((wall[2], wall[3]))
        unique_points = []
        for point in points:
            if point not in unique_points:
                unique_points.append(point)
        if unique_points and unique_points[0] != unique_points[-1]:
            unique_points.append(unique_points[0])
        return unique_points

    def calculate_layout(self):
        """Рассчитывает раскладку для текущего смещения"""
        self.tiles = []
        self.full_tiles = 0
        self.cut_tiles = 0
        if not self.room.walls:
            self.calculate_statistics()
            return

        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        min_x, max_x = min(all_x), max(all_x)
        min_y, max_y = min(all_y), max(all_y)

        search_min_x = min_x - 60
        search_max_x = max_x + 60
        search_min_y = min_y - 60
        search_max_y = max_y + 60

        grid_start_x = math.floor((search_min_x - self.grid_offset_x) /
                                  self.TILE_SIZE) * self.TILE_SIZE + self.grid_offset_x
        grid_start_y = math.floor((search_min_y - self.grid_offset_y) /
                                  self.TILE_SIZE) * self.TILE_SIZE + self.grid_offset_y

        x = grid_start_x
        while x < search_max_x:
            y = grid_start_y
            while y < search_max_y:
                tile_x2 = x + self.TILE_SIZE
                tile_y2 = y + self.TILE_SIZE
                tile_info = self.analyze_tile(x, y, tile_x2, tile_y2)
                if tile_info['type'] != 'outside':
                    self.tiles.append(tile_info)
                    if tile_info['type'] == 'full':
                        self.full_tiles += 1
                    elif tile_info['type'] == 'cut':
                        self.cut_tiles += 1
                y += self.TILE_SIZE
            x += self.TILE_SIZE

        self.calculate_statistics()

    def analyze_tile(self, x1, y1, x2, y2):
        """Анализирует плитку с учетом реальной геометрии комнаты"""
        room_min_x, room_max_x, room_min_y, room_max_y = self.get_room_bounds()

        if x2 <= room_min_x or x1 >= room_max_x or y2 <= room_min_y or y1 >= room_max_y:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]
        corners_inside = sum(
            1 for corner in corners if self.is_point_inside_room(*corner))

        if corners_inside == 4:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'full', 'cut_x': 60, 'cut_y': 60}

        if corners_inside == 0:
            test_points = [
                ((x1 + x2) / 2, (y1 + y2) / 2),
                (x1 + 20, y1 + 20), (x2 - 20, y2 - 20),
                (x1 + 20, y2 - 20), (x2 - 20, y1 + 20)
            ]
            points_inside = sum(
                1 for point in test_points if self.is_point_inside_room(*point))
            if points_inside == 0:
                return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        useful_x, useful_y = self.calculate_cut_dimensions(x1, y1, x2, y2)

        if useful_x < 0.1 and useful_y < 0.1:
            return {'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2, 'type': 'outside', 'cut_x': 0, 'cut_y': 0}

        return {
            'x1': x1, 'y1': y1, 'x2': x2, 'y2': y2,
            'type': 'cut',
            'cut_x': max(0.1, useful_x),
            'cut_y': max(0.1, useful_y)
        }

    def get_room_bounds(self):
        """Возвращает границы комнаты для быстрой проверки"""
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        # ← КРИТИЧНО: обработка пустой комнаты
        if not all_x or not all_y:
            return 0, 0, 0, 0

        return min(all_x), max(all_x), min(all_y), max(all_y)

    def calculate_cut_dimensions(self, x1, y1, x2, y2):
        """Точный расчет полезных размеров плитки"""
        all_x = []
        all_y = []
        for wall in self.room.walls:
            x1_w, y1_w, x2_w, y2_w = wall
            all_x.extend([x1_w, x2_w])
            all_y.extend([y1_w, y2_w])

        if not all_x or not all_y:
            return 0.0, 0.0

        room_min_x = min(all_x)
        room_max_x = max(all_x)
        room_min_y = min(all_y)
        room_max_y = max(all_y)

        is_rectangular = False
        if len(self.room.walls) == 4:
            corners = set()
            for wall in self.room.walls:
                corners.add((wall[0], wall[1]))
                corners.add((wall[2], wall[3]))
            if len(corners) == 4:
                corner_x = sorted(set([p[0] for p in corners]))
                corner_y = sorted(set([p[1] for p in corners]))
                if (len(corner_x) == 2 and len(corner_y) == 2 and
                    room_min_x in corner_x and room_max_x in corner_x and
                        room_min_y in corner_y and room_max_y in corner_y):
                    is_rectangular = True

        if is_rectangular:
            intersect_x1 = max(x1, room_min_x)
            intersect_y1 = max(y1, room_min_y)
            intersect_x2 = min(x2, room_max_x)
            intersect_y2 = min(y2, room_max_y)
            if intersect_x1 >= intersect_x2 or intersect_y1 >= intersect_y2:
                return 0.0, 0.0
            useful_x = round(intersect_x2 - intersect_x1)
            useful_y = round(intersect_y2 - intersect_y1)
            return max(0.0, min(60.0, useful_x)), max(0.0, min(60.0, useful_y))
        else:
            corners = [(x1, y1), (x2, y1), (x2, y2), (x1, y2)]
            corners_inside = [
                p for p in corners if self.is_point_inside_room(*p)]

            if len(corners_inside) == 4:
                return 60.0, 60.0

            center = ((x1 + x2) / 2, (y1 + y2) / 2)
            if not corners_inside and not self.is_point_inside_room(*center):
                return 0.0, 0.0

            intersection_points = []
            for wall in self.room.walls:
                wx1, wy1, wx2, wy2 = wall
                for line in [
                    (x1, y1, x1, y2), (x2, y1, x2, y2),
                    (x1, y1, x2, y1), (x1, y2, x2, y2)
                ]:
                    inter = self.line_intersection(*line, wx1, wy1, wx2, wy2)
                    if inter:
                        intersection_points.append(inter)

            inside_points = corners_inside.copy()
            if intersection_points:
                inside_points.extend(intersection_points)
            else:
                key_points = [
                    (x1 + 20, y1 + 20), (x1 + 40, y1 + 20),
                    (x1 + 20, y1 + 40), (x1 + 40, y1 + 40),
                    (x1 + 30, y1 + 30)
                ]
                for px, py in key_points:
                    if self.is_point_inside_room(px, py):
                        inside_points.append((px, py))

            if not inside_points:
                return 0.0, 0.0

            min_x = min(p[0] for p in inside_points)
            max_x = max(p[0] for p in inside_points)
            min_y = min(p[1] for p in inside_points)
            max_y = max(p[1] for p in inside_points)

            useful_x = max(0.0, min(60.0, round(max_x - min_x)))
            useful_y = max(0.0, min(60.0, round(max_y - min_y)))
            return max(0.1, useful_x), max(0.1, useful_y)

    def line_intersection(self, x1, y1, x2, y2, x3, y3, x4, y4):
        """Находит точку пересечения двух отрезков"""
        denom = (y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)
        if abs(denom) < 0.001:
            return None
        ua = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / denom
        ub = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / denom
        if ua < 0 or ua > 1 or ub < 0 or ub > 1:
            return None
        x = x1 + ua * (x2-x1)
        y = y1 + ua * (y2-y1)
        if (min(x1, x2) - 1 <= x <= max(x1, x2) + 1 and
            min(y1, y2) - 1 <= y <= max(y1, y2) + 1 and
            min(x3, x4) - 1 <= x <= max(x3, x4) + 1 and
                min(y3, y4) - 1 <= y <= max(y3, y4) + 1):
            return (x, y)
        return None

    def point_to_line_distance(self, px, py, x1, y1, x2, y2):
        """Вычисляет расстояние от точки до линии"""
        if x1 == x2 and y1 == y2:
            return math.sqrt((px - x1)**2 + (py - y1)**2)
        line_vec_x = x2 - x1
        line_vec_y = y2 - y1
        point_vec_x = px - x1
        point_vec_y = py - y1
        line_len = math.sqrt(line_vec_x**2 + line_vec_y**2)
        if line_len > 0:
            line_vec_x /= line_len
            line_vec_y /= line_len
        projection_length = point_vec_x * line_vec_x + point_vec_y * line_vec_y
        projection_length = max(0, min(line_len, projection_length))
        closest_x = x1 + projection_length * line_vec_x
        closest_y = y1 + projection_length * line_vec_y
        return math.sqrt((px - closest_x)**2 + (py - closest_y)**2)

    def is_point_inside_room(self, px, py):
        """Проверка точки внутри комнаты (ray casting)"""
        if not self.room_polygon:
            return False
        min_x, max_x, min_y, max_y = self.room_bounds
        if px < min_x - 1 or px > max_x + 1 or py < min_y - 1 or py > max_y + 1:
            return False
        inside = False
        j = len(self.room_polygon) - 1
        for i in range(len(self.room_polygon)):
            xi, yi = self.room_polygon[i]
            xj, yj = self.room_polygon[j]
            if ((yi > py) != (yj > py)) and (px < (xj - xi) * (py - yi) / (yj - yi + 1e-10) + xi):
                inside = not inside
            j = i
        return inside

    def calculate_room_area(self):
        """Точный расчет площади комнаты методом триангуляции для сложных форм"""
        # ← КРИТИЧНО: обработка пустой комнаты
        if not self.room.walls or len(self.room.walls) < 3:
            return 0

        # Собираем точки полигона комнаты
        points = []
        if self.room.walls:
            points.append((self.room.walls[0][0], self.room.walls[0][1]))
            for wall in self.room.walls:
                points.append((wall[2], wall[3]))

        # Замыкаем полигон
        if points[0] != points[-1]:
            points.append(points[0])

        # Метод Гаусса для расчета площади полигона
        area = 0
        n = len(points) - 1
        for i in range(n):
            x1, y1 = points[i]
            x2, y2 = points[i + 1]
            area += x1 * y2 - x2 * y1

        return abs(area) / 2

    def calculate_statistics(self):
        """Рассчитывает статистику раскладки"""
        if not self.room.walls:
            self.waste_percentage = 0
            self.room_area_sqm = 0.0
            return
        # 1. Точно считаем площадь комнаты в см²
        room_area_sqcm = self.calculate_room_area()

        # ← КРИТИЧНО: проверка на нулевую площадь
        if room_area_sqcm <= 0:
            self.room_area_sqm = 0.0
            self.waste_percentage = 0
            return
        # 2. Конвертируем площадь в м²
        self.room_area_sqm = room_area_sqcm / 10000.0

        full_area = self.full_tiles * (self.TILE_SIZE * self.TILE_SIZE)
        cut_area_total = 0
        for tile in self.tiles:
            if tile['type'] == 'cut':
                useful_x = tile.get('cut_x', 0)
                useful_y = tile.get('cut_y', 0)
                useful_area = useful_x * useful_y
                cut_area_total += useful_area
        useful_area_total = full_area + cut_area_total
        total_tiles_area = (self.full_tiles + self.cut_tiles) * \
            (self.TILE_SIZE * self.TILE_SIZE)
        waste_area = total_tiles_area - useful_area_total
        if room_area_sqcm > 0:
            waste_percent = (waste_area / room_area_sqcm) * 100
            self.waste_percentage = round(waste_percent, 1)
        else:
            self.waste_percentage = 0

    def move_grid(self, dx, dy):
        """Смещает сетку"""
        self.grid_offset_x = (self.grid_offset_x + dx) % self.TILE_SIZE
        self.grid_offset_y = (self.grid_offset_y + dy) % self.TILE_SIZE
        self.calculate_layout()

============================================================
ФАЙЛ: repo_to_text.py
============================================================

import os
import mimetypes
from pathlib import Path


def is_binary_file(file_path, sample_size=1024):
    """Проверяет, является ли файл бинарным."""
    try:
        with open(file_path, 'rb') as f:
            sample = f.read(sample_size)
            if b'\0' in sample:  # Простая эвристика: если есть нулевые байты — скорее всего бинарник
                return True
            # Дополнительно: попробуем декодировать как UTF-8
            try:
                sample.decode('utf-8')
                return False
            except UnicodeDecodeError:
                return True
    except Exception:
        return True  # Если не удалось прочитать — считаем бинарным


def should_skip_dir(dir_name):
    """Возвращает True, если директорию нужно пропустить."""
    skip_dirs = {
        '.git', '__pycache__', 'node_modules', 'venv', 'env', '.venv',
        '.idea', '.vscode', '.DS_Store', 'dist', 'build', 'coverage',
        '.pytest_cache', '.mypy_cache', '.tox', '.eggs', '*.egg-info',
        'api_service'
    }
    return dir_name in skip_dirs or dir_name.endswith('.egg-info')


def should_skip_file(file_name):
    """Возвращает True, если файл нужно пропустить."""
    skip_extensions = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.exe', '.dll', '.so', '.dylib',
                       '.zip', '.tar', '.gz', '.rar', '.pdf', '.bin', '.dat', '.log', '.lock', '.txt'}
    ext = Path(file_name).suffix.lower()
    return ext in skip_extensions


def generate_repo_summary(repo_path, output_file="repo_summary.txt"):
    repo_path = Path(repo_path).resolve()
    if not repo_path.exists():
        raise ValueError(f"Путь не существует: {repo_path}")

    with open(output_file, "w", encoding="utf-8") as out_f:
        out_f.write(f"РЕПОЗИТОРИЙ: {repo_path}\n")
        out_f.write("=" * 80 + "\n\n")

        # Сначала соберём дерево структуры
        tree_lines = []
        file_list = []

        for root, dirs, files in os.walk(repo_path):
            # Пропускаем ненужные директории
            dirs[:] = [d for d in dirs if not should_skip_dir(d)]

            level = root.replace(str(repo_path), '').count(os.sep)
            indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
            tree_lines.append(f"{indent}{os.path.basename(root)}/")

            for file in sorted(files):
                if should_skip_file(file):
                    continue
                file_path = Path(root) / file
                rel_path = file_path.relative_to(repo_path)
                file_list.append(file_path)

                file_indent = '│   ' * level + '├── '
                tree_lines.append(f"{file_indent}{file}")

        # Записываем дерево
        out_f.write("СТРУКТУРА ПРОЕКТА:\n")
        out_f.write("-" * 40 + "\n")
        for line in tree_lines:
            out_f.write(line + "\n")
        out_f.write("\n" + "=" * 80 + "\n\n")

        # Теперь записываем содержимое каждого файла
        for file_path in sorted(file_list):
            rel_path = file_path.relative_to(repo_path)
            try:
                if is_binary_file(file_path):
                    continue

                out_f.write(f"\n{'='*60}\n")
                out_f.write(f"ФАЙЛ: {rel_path}\n")
                out_f.write(f"{'='*60}\n\n")

                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    out_f.write(content)
                    if not content.endswith('\n'):
                        out_f.write('\n')

            except Exception as e:
                out_f.write(f"\n[ОШИБКА ПРИ ЧТЕНИИ ФАЙЛА: {e}]\n")

    print(f"✅ Готово! Сводка сохранена в: {output_file}")


# === ОСНОВНОЙ ЗАПУСК ===
if __name__ == "__main__":
    import sys

    if len(sys.argv) < 2:
        print("Использование: python repo_to_text.py <путь_к_репозиторию> [выходной_файл.txt]")
        repo_path = input("Введите путь к репозиторию: ").strip()
    else:
        repo_path = sys.argv[1]

    output_file = sys.argv[2] if len(sys.argv) > 2 else "repo_summary.txt"

    generate_repo_summary(repo_path, output_file)


============================================================
ФАЙЛ: screens\__init__.py
============================================================



============================================================
ФАЙЛ: screens\layout_screen.py
============================================================

# screens/layout_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from widgets.layout_widget import LayoutWidget
from models import CeilingLayout
from database import save_project  # Импортируем функцию сохранения


class LayoutScreen(Screen):
    """Экран раскладки потолка 60×60 см"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.snap_mode = 0
        self.control_mode = 'grid'

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))
        self.selected_corner = None

        # Панель инструментов
        toolbar = self.create_toolbar()

        # ← КРИТИЧНО: Область с раскладкой с фиксированным size_hint
        self.layout_widget = LayoutWidget(size_hint=(1, 1))

        # Панель управления
        control_panel = self.create_control_panel()

        # Панель статистики
        stats_panel = self.create_stats_panel()

        # ← КРИТИЧНО: Собираем в правильный порядок
        main_layout.add_widget(toolbar)
        main_layout.add_widget(self.layout_widget)
        main_layout.add_widget(control_panel)
        main_layout.add_widget(stats_panel)

        # ← КРИТИЧНО: Оборачиваем в FloatLayout для правильного z-ordering
        from kivy.uix.floatlayout import FloatLayout
        overlay = FloatLayout()
        overlay.add_widget(main_layout)
        self.add_widget(overlay)

    def toggle_dimensions(self, instance):
        """Переключает отображение размеров резаных плиток"""
        if not hasattr(self, 'layout_widget'):
            return

        # Инвертируем состояние
        self.layout_widget.show_dimensions = not self.layout_widget.show_dimensions

        # Меняем текст кнопки с переносом
        if self.layout_widget.show_dimensions:
            instance.text = 'Скрыть nразмеры'
            instance.background_color = (0.5, 0.5, 0.5, 1)
        else:
            instance.text = 'Показать nразмеры'
            instance.background_color = (0.3, 0.7, 0.3, 1)

        # Перерисовываем
        self.layout_widget.draw_layout()

    def on_pre_enter(self):
        """Загружаем комнату при входе"""
        from kivy.clock import Clock
        Clock.schedule_once(self.load_room_data, 0.1)

    def load_room_data(self, dt):
        """Загружает данные комнаты с задержкой для правильной инициализации"""
        if not hasattr(self.manager, 'current_room') or not self.manager.current_room:
            print("Ошибка: current_room не установлен")
            return
        current_room = self.manager.current_room
        if current_room:
            print(f"Загрузка комнаты: {current_room.name}")
            print(f"Стены: {len(current_room.walls)}")

            # Устанавливаем стены в виджет
            self.layout_widget.set_room(current_room.walls)

            # Создаем расчет раскладки
            self.ceiling_layout = CeilingLayout(current_room)

            # ← КРИТИЧНО: загружаем сохранённое смещение из комнаты
            self.ceiling_layout.grid_offset_x = getattr(
                current_room, 'grid_offset_x', 0)
            self.ceiling_layout.grid_offset_y = getattr(
                current_room, 'grid_offset_y', 0)
            self.layout_widget.grid_offset_x = self.ceiling_layout.grid_offset_x
            self.layout_widget.grid_offset_y = self.ceiling_layout.grid_offset_y

            # Рассчитываем раскладку
            self.ceiling_layout.calculate_layout()

            # Передаем layout в виджет
            self.layout_widget.layout = self.ceiling_layout

            # Устанавливаем callback для обновления статистики при движении сетки
            self.layout_widget.on_grid_move = self.on_grid_moved

            # Обновляем статистику
            self.update_stats()

            # Явно перерисовываем
            self.layout_widget.draw_layout()

    def on_grid_moved(self):
        """Callback, вызываемый при изменении положения сетки"""
        # Получаем ТОЧНЫЕ значения смещения без округления
        if hasattr(self.layout_widget, 'grid_offset_x') and hasattr(self.layout_widget, 'grid_offset_y'):
            # Берем точные значения для расчета
            exact_offset_x = self.layout_widget.grid_offset_x
            exact_offset_y = self.layout_widget.grid_offset_y

            # Обновляем расчет раскладки с точными значениями
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = exact_offset_x
                self.ceiling_layout.grid_offset_y = exact_offset_y
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
                self.update_stats()  # Обновляем статистику при движении сетки

            # Округляем ТОЛЬКО для отображения в лейбле ПОСЛЕ расчета
            offset_x_display = int(round(exact_offset_x))
            offset_y_display = int(round(exact_offset_y))

            # Обновляем отображение СРАЗУ при любом изменении
            if hasattr(self, 'offset_label'):
                self.offset_label.text = f'Смещение: {offset_x_display}×{offset_y_display} см'

    def create_toolbar(self):
        """Создает панель инструментов с кнопкой режима"""
        toolbar = BoxLayout(
            size_hint=(1, 0.1),
            padding=dp(10),
            spacing=dp(10)
        )

        # Кнопка "Назад"
        btn_back = Button(
            text='Назад',
            font_size=dp(16),
            size_hint=(0.2, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # Заголовок
        title = Label(
            text='Раскладка\n60×60 см',
            font_size=dp(14),
            size_hint=(0.3, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            max_lines=2,
            line_height=1.2
        )
        title.bind(size=title.setter('text_size'))

        # Кнопка режима управления
        self.mode_button = Button(
            text='Сетка',  # Иконка и текст
            font_size=dp(14),
            size_hint=(0.25, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        self.mode_button.bind(on_press=self.toggle_control_mode)

        # Кнопка "Сброс"
        btn_reset = Button(
            text='Сброс',
            font_size=dp(14),
            size_hint=(0.25, 1),
            background_color=(0.9, 0.6, 0.2, 1),
            color=(1, 1, 1, 1)
        )
        btn_reset.bind(on_press=self.reset_view)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(title)
        toolbar.add_widget(self.mode_button)
        toolbar.add_widget(btn_reset)

        return toolbar

    def toggle_control_mode(self, instance):
        """Переключает режим управления"""
        if self.control_mode == 'grid':
            self.control_mode = 'pan_zoom'
            self.mode_button.text = '👆 Панорама'
            self.mode_button.background_color = (0.3, 0.7, 0.3, 1)
            # Отключаем перемещение сетки пальцем
            self.layout_widget.dragging_enabled = False
        else:
            self.control_mode = 'grid'
            self.mode_button.text = 'Сетка'
            self.mode_button.background_color = (0.2, 0.6, 1, 1)
            # Включаем перемещение сетки пальцем
            self.layout_widget.dragging_enabled = True

    def reset_view(self, instance):
        """Сбрасывает вид к первоначальному состоянию"""
        if self.control_mode == 'pan_zoom':
            # Центрируем комнату
            self.layout_widget.center_room()
        else:
            # Сбрасываем сетку
            self.layout_widget.grid_offset_x = 0
            self.layout_widget.grid_offset_y = 0
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = 0
                self.ceiling_layout.grid_offset_y = 0
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
                self.update_stats()
                self.layout_widget.draw_layout()

    def create_control_panel(self):
        """Создает панель управления сеткой с одной строкой кнопок и строкой кнопки переключения размеров"""
        # Основной контейнер с вертикальной ориентацией (2 строки)
        control_panel = BoxLayout(
            orientation='vertical',
            size_hint=(1, 0.1),  # Увеличена высота до 10% экрана
            padding=dp(5),
            spacing=dp(5)
        )

        # === СТРОКА 1: кнопки смещения ===
        row1 = BoxLayout(
            size_hint=(1, 0.5),
            spacing=dp(5)
        )

        # Кнопки смещения сетки с шагом 1 см
        btn_left = Button(
            text='<-',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_left.bind(on_press=lambda x: self.move_grid(-1, 0))
        btn_up = Button(
            text='^',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_up.bind(on_press=lambda x: self.move_grid(0, 1))
        btn_down = Button(
            text='v',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_down.bind(on_press=lambda x: self.move_grid(0, -1))
        btn_right = Button(
            text='->',
            font_size=dp(20),
            size_hint=(0.2, 1),
            background_color=(0.3, 0.3, 0.3, 1)
        )
        btn_right.bind(on_press=lambda x: self.move_grid(1, 0))

        row1.add_widget(btn_left)
        row1.add_widget(btn_up)
        row1.add_widget(btn_down)
        row1.add_widget(btn_right)

        # === СТРОКА 2: кнопка переключения размеров ===
        row2 = BoxLayout(
            size_hint=(1, 0.5),
            padding=(dp(10), 0)
        )

        # Кнопка с переносом текста и увеличенной высотой
        self.toggle_dims_btn = Button(
            text='Скрыть размеры',  # Перенос через \
            font_size=dp(14),
            size_hint=(0.4, 1),
            background_color=(0.5, 0.5, 0.5, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        # Настройка переноса текста
        self.toggle_dims_btn.bind(
            size=lambda instance, size: setattr(
                instance, 'text_size', (size[0] * 0.9, None))
        )
        self.toggle_dims_btn.bind(on_press=self.toggle_dimensions)
        row2.add_widget(self.toggle_dims_btn)

        # Собираем обе строки в панель
        control_panel.add_widget(row1)
        control_panel.add_widget(row2)
        return control_panel

    def create_stats_panel(self):
        """Создает панель статистики"""
        stats_panel = BoxLayout(
            size_hint=(1, 0.05),
            padding=dp(10)
        )
        # Изменяем текст на площадь
        self.stats_label = Label(
            text='Целых: 0 | Резаных: 0 | Площадь: 0.0 м²',
            font_size=dp(14),
            color=(0, 0, 0, 1)
        )
        stats_panel.add_widget(self.stats_label)
        return stats_panel

    def move_grid(self, dx, dy):
        """Смещает сетку на dx, dy сантиметров с немедленным отображением"""
        if hasattr(self.layout_widget, 'grid_offset_x'):
            # Устанавливаем ТОЧНОЕ смещение и округляем до целого
            self.layout_widget.grid_offset_x = round(
                self.layout_widget.grid_offset_x + dx)
            self.layout_widget.grid_offset_y = round(
                self.layout_widget.grid_offset_y + dy)

            # Немедленно обновляем расчет
            if hasattr(self, 'ceiling_layout'):
                self.ceiling_layout.grid_offset_x = self.layout_widget.grid_offset_x
                self.ceiling_layout.grid_offset_y = self.layout_widget.grid_offset_y
                self.ceiling_layout.calculate_layout()
                self.layout_widget.layout = self.ceiling_layout
            # КРИТИЧЕСКИ ВАЖНО: вызываем callback вручную для немедленного обновления
            self.on_grid_moved()
            # Перерисовываем
            self.layout_widget.draw_layout()

    def reset_grid(self, instance):
        """Сбрасывает смещение сетки к (0, 0)"""
        self.layout_widget.grid_offset_x = 0
        self.layout_widget.grid_offset_y = 0
        if self.ceiling_layout:
            self.ceiling_layout.grid_offset_x = 0
            self.ceiling_layout.grid_offset_y = 0
            self.ceiling_layout.calculate_layout()
            self.layout_widget.layout = self.ceiling_layout
        self.update_stats()
        self.layout_widget.draw_layout()

    def update_stats(self):
        """Обновляет статистику раскладки"""
        if self.ceiling_layout:
            stats = self.ceiling_layout
            # Обновляем текст: вместо отходов показываем площадь
            self.stats_label.text = f'Целых: {stats.full_tiles} | Резаных: {stats.cut_tiles} | Площадь: {stats.room_area_sqm:.2f} м²'

    def go_back(self, instance):
        """Возврат в редактор"""
        # Сохраняем текущее смещение сетки в комнату
        if hasattr(self, 'ceiling_layout') and self.manager.current_room:
            self.manager.current_room.grid_offset_x = self.ceiling_layout.grid_offset_x
            self.manager.current_room.grid_offset_y = self.ceiling_layout.grid_offset_y
            from database import save_project
            save_project(self.manager.current_project)

        # ← Возвращаемся всегда в редактор
        self.manager.current = 'room_editor'

    # def go_back(self, instance):
    #     """Возврат — пропускаем редактор если комната имеет стены"""
    #     # Сохраняем текущее смещение сетки в комнату
    #     if hasattr(self, 'ceiling_layout') and self.manager.current_room:
    #         self.manager.current_room.grid_offset_x = self.ceiling_layout.grid_offset_x
    #         self.manager.current_room.grid_offset_y = self.ceiling_layout.grid_offset_y
    #         from database import save_project
    #         save_project(self.manager.current_project)

    #     # ← КРИТИЧНО: Проверяем есть ли стены у комнаты
    #     current_room = self.manager.current_room
    #     if current_room and current_room.walls and len(current_room.walls) >= 3:
    #         # Если комната имеет стены — идем сразу в комнаты
    #         self.manager.current = 'rooms'
    #     else:
    #         # Иначе — в редактор
    #         self.manager.current = 'room_editor'

============================================================
ФАЙЛ: screens\main_screen.py
============================================================

from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.metrics import dp


class MainScreen(Screen):
    """Главный экран с выбором калькулятора"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Основной вертикальный контейнер
        main_layout = BoxLayout(
            orientation='vertical',
            padding=dp(20),
            spacing=dp(20)
        )

        # Заголовок приложения
        title = Label(
            text='Калькулятор потолков',
            font_size=dp(28),
            color=(0, 0, 0, 1),
            size_hint=(1, 0.2),
            bold=True
        )

        # Контейнер для кнопок
        buttons_layout = BoxLayout(
            orientation='vertical',
            spacing=dp(15),
            size_hint=(1, 0.8)
        )

        # Кнопка 1: Расчет раскладки потолка
        btn_calc1 = Button(
            text='Расчет раскладки потолка',
            font_size=dp(18),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            size_hint=(1, 0.45)
        )
        # Изменено: теперь идем в проекты
        btn_calc1.bind(on_press=self.go_to_projects)

        # Кнопка 2: Расчет материалов (заглушка)
        btn_calc2 = Button(
            text='Расчет материалов',
            font_size=dp(18),
            background_color=(0.3, 0.7, 0.3, 1),
            color=(1, 1, 1, 1),
            size_hint=(1, 0.45)
        )
        btn_calc2.bind(on_press=self.show_placeholder)

        # Собираем интерфейс
        buttons_layout.add_widget(btn_calc1)
        buttons_layout.add_widget(btn_calc2)

        main_layout.add_widget(title)
        main_layout.add_widget(buttons_layout)

        self.add_widget(main_layout)

    def go_to_projects(self, instance):  # Переименован метод
        """Переход к экрану проектов"""
        print("Переход к экрану проектов")
        self.manager.current = 'projects'

    def show_placeholder(self, instance):
        """Заглушка для второго калькулятора"""
        instance.text = "В разработке!"
        from kivy.clock import Clock
        Clock.schedule_once(lambda dt: setattr(
            instance, 'text', 'Расчет материалов'), 1)

============================================================
ФАЙЛ: screens\projects_screen.py
============================================================

# screens/projects_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.graphics import Color, Rectangle, Line
from kivy.clock import Clock
from database import init_db, load_all_projects, save_project, delete_project, load_project
# Добавим BoxLayout для компоновки кнопки X
from kivy.uix.boxlayout import BoxLayout
# Используем AnchorLayout для позиционирования X
from kivy.uix.relativelayout import RelativeLayout


class ProjectsScreen(Screen):
    """Экран со списком проектов (плиточный интерфейс)"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Инициализируем БД при запуске приложения
        init_db()

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # Заголовок
        toolbar = self.create_toolbar()

        # Основная область с проектами
        content_area = self.create_content_area()

        main_layout.add_widget(toolbar)
        main_layout.add_widget(content_area)
        self.add_widget(main_layout)
        self.bind(size=self.on_size)

        # Тестовые данные больше не нужны
        self.projects = []
        # Отложенная загрузка проектов из БД
        Clock.schedule_once(lambda dt: self.load_projects(), 0.1)

    def on_size(self, *args):
        """Обновляет размеры плиток при изменении размера окна"""
        if hasattr(self, 'projects_container'):
            Clock.schedule_once(lambda dt: self.update_projects_grid(), 0.1)

    def create_toolbar(self):
        """Создает панель инструментов"""
        toolbar = BoxLayout(
            size_hint=(1, 0.15),
            padding=dp(10),
            spacing=dp(10)
        )

        # Кнопка "Назад" на главный экран
        btn_back = Button(
            text='← Назад',
            font_size=dp(16),
            size_hint=(0.3, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # Заголовок
        title = Label(
            text='Мои проекты',
            font_size=dp(20),
            size_hint=(0.4, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle'
        )
        title.bind(size=title.setter('text_size'))

        # Кнопка "Добавить проект" с переносом текста
        btn_add = Button(
            text='+ Новый\nпроект',  # Перенос на новую строку
            font_size=dp(14),
            size_hint=(0.3, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        btn_add.bind(on_press=self.show_add_project_dialog)

        # Настраиваем перенос текста для кнопки
        def update_btn_text(instance, size):
            instance.text_size = (size[0] - dp(10), None)
        btn_add.bind(size=update_btn_text)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(title)
        toolbar.add_widget(btn_add)

        return toolbar

    def create_content_area(self):
        """Создает область с плитками проектов"""
        # Контейнер для сетки проектов
        self.projects_container = GridLayout(
            cols=2,
            spacing=dp(10),
            padding=dp(10),
            size_hint_y=None
        )
        self.projects_container.bind(
            minimum_height=self.projects_container.setter('height'))

        # Скролл для контейнера
        scroll = ScrollView()
        scroll.add_widget(self.projects_container)

        return scroll

    def load_projects(self):
        """Загружает проекты из базы данных"""
        self.projects = []
        db_projects = load_all_projects()
        if db_projects:
            self.projects = db_projects
        self.update_projects_grid()  # <-- Вызываем напрямую для немедленного обновления

    def update_projects_grid(self):
        """Обновляет сетку проектов"""
        self.projects_container.clear_widgets()

        # Устанавливаем параметры сетки
        self.projects_container.cols = 2
        self.projects_container.spacing = dp(10)
        self.projects_container.padding = dp(10)

        # Добавляем плитки проектов
        for project in self.projects:
            project_tile = self.create_project_tile(project)
            self.projects_container.add_widget(project_tile)

        # Автоматически устанавливаем высоту контейнера на основе содержимого
        self.projects_container.height = self.projects_container.minimum_height

        # Если проектов нет
        if not self.projects:
            empty_label = Label(
                text='Нет проектов\nНажмите "+ Новый проект"',
                font_size=dp(16),
                color=(0.5, 0.5, 0.5, 1),
                halign='center',
                valign='middle',
                size_hint_y=None
            )
            empty_label.bind(size=empty_label.setter('text_size'))
            empty_label.height = self.height * 0.3
            self.projects_container.add_widget(empty_label)
            self.projects_container.height = self.projects_container.minimum_height

    def create_project_tile(self, project):
        """Создает плитку для проекта с кнопкой удаления"""
        container_width = self.projects_container.width if self.projects_container.width > 0 else self.width
        tile_width = (container_width - dp(30)) / \
            2 if container_width > 0 else dp(150)

        tile_layout = RelativeLayout(
            size_hint=(None, None),
            size=(tile_width, tile_width)
        )

        # Расчет общей площади
        from database import load_project
        from models import CeilingLayout
        total_area = 0.0

        full_project = load_project(project.id) if project.id else None
        if full_project:
            for room in full_project.rooms:
                try:
                    if room.walls and len(room.walls) >= 3:
                        temp_layout = CeilingLayout(room)
                        total_area += temp_layout.room_area_sqm if hasattr(
                            temp_layout, 'room_area_sqm') else 0.0
                except Exception as e:
                    print(f"Ошибка расчета площади: {e}")
                    continue

        # ← КРИТИЧНО: правильное форматирование текста
        if total_area > 0:
            button_text = f"{project.name}\n{total_area:.1f} м²"
        else:
            button_text = project.name

        tile_button = Button(
            background_color=(0.95, 0.95, 0.95, 1),
            background_normal='',
            text=button_text,
            font_size=dp(16),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            text_size=(tile_width - dp(20), tile_width -
                       dp(20)),  # ← Оба размера!
            shorten=False,  # ← Отключаем сокращение
            max_lines=2
        )
        tile_button.bind(on_press=lambda instance,
                         p=project: self.open_project(p))

        # Кнопка удаления
        delete_container = BoxLayout(
            size_hint=(None, None),
            size=(dp(25), dp(25)),
            pos_hint={'right': 1, 'top': 1}
        )
        delete_button = Button(
            text='X',
            font_size=dp(12),
            size_hint=(1, 1),
            background_color=(0.8, 0.2, 0.2, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        delete_button.bind(on_press=lambda instance,
                           p_id=project.id: self.confirm_delete_project(p_id))
        delete_container.add_widget(delete_button)

        tile_layout.add_widget(tile_button)
        tile_layout.add_widget(delete_container)
        return tile_layout

    def confirm_delete_project(self, project_id):
        """Показывает диалог подтверждения удаления проекта."""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(10))
        message = Label(text='Вы точно хотите удалить?', font_size=dp(16))

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.3))

        def do_delete(dt):
            success = delete_project(project_id)
            if success:
                # Перезагрузить список проектов
                self.load_projects()
            popup.dismiss()

        def cancel_delete(dt):
            popup.dismiss()

        btn_delete = Button(text='Удалить', background_color=(
            0.8, 0.2, 0.2, 1), color=(1, 1, 1, 1))
        btn_cancel = Button(text='Отмена')

        btn_delete.bind(on_press=do_delete)
        btn_cancel.bind(on_press=cancel_delete)

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_delete)

        content.add_widget(message)
        content.add_widget(btn_layout)

        popup = Popup(title='Подтверждение удаления',
                      content=content,
                      size_hint=(0.6, 0.4))
        popup.open()

    def show_add_project_dialog(self, instance):
        """Показывает диалог добавления проекта"""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(20))

        label = Label(text='Название проекта:', font_size=dp(16))
        name_input = TextInput(
            multiline=False,
            font_size=dp(18),
            size_hint=(1, 0.4)
        )

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.4))

        btn_confirm = Button(
            text='Создать',
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        btn_cancel = Button(text='Отмена')

        def create_project(inst):
            name = name_input.text.strip()
            if name:
                from models import Project
                project = Project(name)
                # Сохраняем проект в БД
                save_project(project)
                # Перезагружаем проекты из БД для получения актуальных данных
                self.projects = load_all_projects()
                # Обновляем сетку
                self.update_projects_grid()
                popup.dismiss()

        btn_confirm.bind(on_press=create_project)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)

        content.add_widget(label)
        content.add_widget(name_input)
        content.add_widget(btn_layout)

        popup = Popup(
            title='Новый проект',
            content=content,
            size_hint=(0.8, 0.4)
        )
        popup.open()

    def open_project(self, project):
        """Открывает проект (переход к экрану комнат)"""
        # Сохраняем текущий проект в менеджере экранов
        self.manager.current_project = project
        # Переходим к экрану комнат
        self.manager.current = 'rooms'

    def go_back(self, instance):
        """Возврат на главный экран"""
        self.manager.current = 'main'

============================================================
ФАЙЛ: screens\room_editor.py
============================================================

# screens/room_editor.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.uix.floatlayout import FloatLayout
from widgets.grid_widget import GridWidget
from database import save_project


class RoomEditorScreen(Screen):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Основной контейнер
        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # Панель инструментов (8% высоты)
        toolbar = self.create_toolbar()

        # Область рисования (занимает всё доступное место)
        self.grid_widget = GridWidget(size_hint=(1, 1))
        self.grid_widget.scale = 0.5

        # Панель информации (7% высоты)
        info_panel = self.create_info_panel()

        # Собираем основной layout
        main_layout.add_widget(toolbar)
        main_layout.add_widget(self.grid_widget)
        main_layout.add_widget(info_panel)

        # Контейнер для масштабирования (поверх основного)
        scale_panel = self.create_scale_panel()

        # FloatLayout для наложения scale_panel поверх
        overlay = FloatLayout()
        overlay.add_widget(main_layout)
        overlay.add_widget(scale_panel)

        self.add_widget(overlay)
        self.update_info()

    def on_pre_enter(self):
        """Вызывается перед входом на экран - загружаем комнату"""
        current_room = self.manager.current_room
        if current_room:
            self.grid_widget.walls = current_room.walls.copy()
            if current_room.walls:
                last_wall = current_room.walls[-1]
                self.grid_widget.current_pos_cm = [last_wall[2], last_wall[3]]
                if hasattr(current_room, 'last_position') and current_room.last_position:
                    self.grid_widget.current_pos_cm = current_room.last_position
            else:
                self.grid_widget.current_pos_cm = [0, 0]
            self.grid_widget.canvas.clear()
            self.grid_widget.draw_editor()
            self.update_info()

    def create_toolbar(self):
        toolbar = BoxLayout(size_hint=(1, 0.08), spacing=dp(5), padding=dp(5))
        self.arrows_container = BoxLayout(size_hint=(0.4, 1))
        self.create_arrow_buttons()
        undo_redo_container = BoxLayout(
            orientation='vertical', size_hint=(0.2, 1), spacing=dp(2))
        self.btn_undo = Button(text='Назад', font_size=dp(
            14), size_hint=(1, 0.5), background_color=(0.8, 0.8, 0.8, 1))
        self.btn_undo.bind(on_press=self.undo_action)
        self.btn_redo = Button(text='Вперед', font_size=dp(
            14), size_hint=(1, 0.5), background_color=(0.8, 0.8, 0.8, 1))
        self.btn_redo.bind(on_press=self.redo_action)
        undo_redo_container.add_widget(self.btn_undo)
        undo_redo_container.add_widget(self.btn_redo)
        actions_container = BoxLayout(
            orientation='vertical', size_hint=(0.4, 1), spacing=dp(2))
        btn_layout = Button(
            text='Раскладка', font_size=dp(14), size_hint=(1, 0.5))
        btn_layout.bind(on_press=self.show_layout)
        btn_exit = Button(text='Выход', font_size=dp(14), size_hint=(1, 0.5))
        btn_exit.bind(on_press=self.exit_editor)
        actions_container.add_widget(btn_layout)
        actions_container.add_widget(btn_exit)
        toolbar.add_widget(self.arrows_container)
        toolbar.add_widget(undo_redo_container)
        toolbar.add_widget(actions_container)
        return toolbar

    def create_scale_panel(self):
        scale_panel = BoxLayout(orientation='vertical', size_hint=(None, None), size=(
            dp(60), dp(120)), pos_hint={'right': 1, 'top': 0.85}, spacing=dp(5), padding=dp(5))
        btn_zoom_in = Button(text='+', font_size=dp(24), size_hint=(1, 0.5))
        btn_zoom_in.bind(on_press=self.zoom_in)
        btn_zoom_out = Button(text='-', font_size=dp(24), size_hint=(1, 0.5))
        btn_zoom_out.bind(on_press=self.zoom_out)
        scale_panel.add_widget(btn_zoom_in)
        scale_panel.add_widget(btn_zoom_out)
        return scale_panel

    def create_info_panel(self):
        info_panel = BoxLayout(size_hint=(1, 0.07), padding=dp(10))
        self.info_label = Label(
            text='Точка: (0, 0) см | Стены: 0 | Площадь: —',
            font_size=dp(12),
            color=(0, 0, 0, 1)
        )
        info_panel.add_widget(self.info_label)
        return info_panel

    def create_arrow_buttons(self):
        grid = GridLayout(cols=3, rows=3, spacing=dp(2))
        arrows = [
            ('↖', 'up_left'), ('^', 'up'), ('↗', 'up_right'),
            ('<-', 'left'), ('•', 'center'), ('->', 'right'),
            ('↙', 'down_left'), ('v', 'down'), ('↘', 'down_right')
        ]
        for symbol, direction in arrows:
            if direction == 'center':
                btn = Button(text=symbol, font_size=dp(
                    20), background_color=(0.8, 0.8, 0.8, 1), disabled=True)
            else:
                btn = Button(text=symbol, font_size=dp(
                    20), on_press=lambda instance, d=direction: self.start_add_wall(d))
            grid.add_widget(btn)
        self.arrows_container.clear_widgets()
        self.arrows_container.add_widget(grid)

    def start_add_wall(self, direction):
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(10))
        label = Label(text=f"Длина стены (см) в направлении {direction}:")
        length_input = TextInput(
            multiline=False, input_filter='int', text='100')
        btn_layout = BoxLayout(spacing=dp(10))
        btn_confirm = Button(text='Подтвердить')
        btn_cancel = Button(text='Отмена')

        def confirm(instance):
            try:
                length = int(length_input.text)
                if length > 0:
                    self.grid_widget.add_wall(direction, length)
                    self.update_info()
                    popup.dismiss()
            except ValueError:
                pass
        btn_confirm.bind(on_press=confirm)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())
        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)
        content.add_widget(label)
        content.add_widget(length_input)
        content.add_widget(btn_layout)
        popup = Popup(title='Ввод длины стены',
                      content=content, size_hint=(0.8, 0.3))
        popup.open()

    def update_info(self):
        """Обновляет информационную панель с площадью"""
        x, y = self.grid_widget.current_pos_cm
        walls_count = len(self.grid_widget.walls)

        # Расчет площади только если комната замкнута (3+ стены)
        room_area = 0.0
        if walls_count >= 3:
            try:
                from models import CeilingLayout, Room
                temp_room = Room("temp")
                temp_room.walls = self.grid_widget.walls.copy()
                temp_layout = CeilingLayout(temp_room)
                room_area = temp_layout.room_area_sqm if hasattr(
                    temp_layout, 'room_area_sqm') else 0.0
            except Exception as e:
                print(f"Ошибка расчета площади: {e}")
                room_area = 0.0

        if room_area > 0:
            self.info_label.text = f'Точка: ({int(x)}, {int(y)}) см | Стены: {walls_count} | Площадь: {room_area:.1f} м²'
        else:
            self.info_label.text = f'Точка: ({int(x)}, {int(y)}) см | Стены: {walls_count} | Площадь: —'

    def undo_action(self, instance):
        if self.grid_widget.undo():
            self.update_info()
            self.btn_redo.disabled = False
            self.btn_redo.background_color = (0.2, 0.6, 1, 1)

    def redo_action(self, instance):
        if self.grid_widget.redo():
            self.update_info()

    def zoom_in(self, instance):
        self.grid_widget.scale = min(1.0, self.grid_widget.scale + 0.1)
        self.grid_widget.canvas.clear()
        self.grid_widget.draw_editor()
        self.update_info()

    def zoom_out(self, instance):
        self.grid_widget.scale = max(0.1, self.grid_widget.scale - 0.1)
        self.grid_widget.canvas.clear()
        self.grid_widget.draw_editor()
        self.update_info()

    def show_layout(self, instance):
        current_room = self.manager.current_room
        if current_room:
            current_room.walls = self.grid_widget.walls.copy()
            current_room.last_position = self.grid_widget.current_pos_cm.copy()
            save_project(self.manager.current_project)
        self.manager.current = 'layout'

    def exit_editor(self, instance):
        current_room = self.manager.current_room
        if current_room:
            current_room.walls = self.grid_widget.walls.copy()
            current_room.last_position = self.grid_widget.current_pos_cm.copy()
            save_project(self.manager.current_project)
        self.manager.current = 'rooms'

============================================================
ФАЙЛ: screens\rooms_screen.py
============================================================

# screens/rooms_screen.py
from kivy.uix.screenmanager import Screen
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.popup import Popup
from kivy.uix.textinput import TextInput
from kivy.metrics import dp
from kivy.graphics import Color, Rectangle, Line
from kivy.clock import Clock
# Импортируем delete_room_from_project и load_project
from database import save_project, delete_room_from_project, load_project
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.relativelayout import RelativeLayout


class RoomsScreen(Screen):
    """Экран со списком комнат в проекте"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.title_label = None

        main_layout = BoxLayout(orientation='vertical', spacing=dp(2))

        # Панель инструментов
        toolbar = self.create_toolbar()

        # Основная область с комнатами
        content_area = self.create_content_area()

        main_layout.add_widget(toolbar)
        main_layout.add_widget(content_area)
        self.add_widget(main_layout)
        self.bind(size=self.on_size)

    def on_size(self, *args):
        """Обновляет размеры плиток при изменении размера окна"""
        if hasattr(self, 'rooms_container') and len(self.rooms_container.children) > 0:
            # Пересчитываем размеры плиток при изменении размера окна
            Clock.schedule_once(lambda dt: self.update_rooms_grid(), 0.1)

    def on_pre_enter(self):
        """Вызывается перед входом на экран - перезагружаем проект и обновляем сетку."""
        if hasattr(self.manager, 'current_project') and self.manager.current_project:
            project_id = self.manager.current_project.id
            if project_id:
                loaded_project = load_project(project_id)
                if loaded_project:
                    self.manager.current_project = loaded_project
        # Убираем отложенное обновление здесь, так как оно может создавать гонку состояний
        self.update_rooms_grid()  # <-- Вызываем напрямую, а не через Clock

    def create_toolbar(self):
        """Создает панель инструментов"""
        toolbar = BoxLayout(
            size_hint=(1, 0.15),
            padding=dp(10),
            spacing=dp(10)
        )

        # Кнопка "Назад" к проектам
        btn_back = Button(
            text='← Назад',
            font_size=dp(16),
            size_hint=(0.3, 1),
            background_color=(0.8, 0.8, 0.8, 1)
        )
        btn_back.bind(on_press=self.go_back)

        # Заголовок (будет обновляться)
        self.title_label = Label(
            text='Комнаты',
            font_size=dp(18),
            size_hint=(0.4, 1),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle'
        )
        self.title_label.bind(size=self.title_label.setter('text_size'))

        # Кнопка "Добавить комнату" с переносом текста
        btn_add = Button(
            text='+ Новая\nкомната',  # Перенос на новую строку
            font_size=dp(14),
            size_hint=(0.3, 1),
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        btn_add.bind(on_press=self.show_add_room_dialog)

        # Настраиваем перенос текста для кнопки
        def update_btn_text(instance, size):
            instance.text_size = (size[0] - dp(10), None)
        btn_add.bind(size=update_btn_text)

        toolbar.add_widget(btn_back)
        toolbar.add_widget(self.title_label)
        toolbar.add_widget(btn_add)

        return toolbar

    def create_content_area(self):
        """Создает область с плитками комнат"""
        # Контейнер для сетки комнат
        self.rooms_container = GridLayout(
            cols=2,
            spacing=dp(10),
            padding=dp(10),
            size_hint_y=None
        )
        self.rooms_container.bind(
            minimum_height=self.rooms_container.setter('height'))

        # Скролл для контейнера
        scroll = ScrollView()
        scroll.add_widget(self.rooms_container)

        return scroll

    def update_rooms_grid(self):
        """Обновляет сетку комнат"""
        self.rooms_container.clear_widgets()
        project = self.manager.current_project
        
        if project:
            # Расчет общей площади для тулбара
            from models import CeilingLayout
            total_area = 0.0
            for room in project.rooms:
                try:
                    if room.walls and len(room.walls) >= 3:
                        temp_layout = CeilingLayout(room)
                        total_area += temp_layout.room_area_sqm if hasattr(temp_layout, 'room_area_sqm') else 0.0
                except Exception as e:
                    print(f"Ошибка расчета площади: {e}")
                    continue
            
            # ← КРИТИЧНО: правильное форматирование заголовка
            if total_area > 0:
                self.title_label.text = f'Комнаты:\n{project.name}\n{total_area:.1f} м²'
            else:
                self.title_label.text = f'Комнаты:\n{project.name}'
            
            self.title_label.font_size = dp(14)
            self.title_label.halign = 'center'
            self.title_label.valign = 'middle'
            self.title_label.max_lines = 3
            self.title_label.text_size = (self.title_label.width, self.title_label.height * 3)
            
            # Параметры сетки
            self.rooms_container.cols = 2
            self.rooms_container.spacing = dp(10)
            self.rooms_container.padding = dp(10)
            
            # Добавляем плитки комнат
            for room in project.rooms:
                room_tile = self.create_room_tile(room)
                self.rooms_container.add_widget(room_tile)
            
            self.rooms_container.height = self.rooms_container.minimum_height
            
            # Если комнат нет
            if not project.rooms:
                empty_label = Label(
                    text='Нет комнат\nНажмите "+ Новая комната"',
                    font_size=dp(16),
                    color=(0.5, 0.5, 0.5, 1),
                    halign='center',
                    valign='middle',
                    size_hint_y=None
                )
                empty_label.bind(size=empty_label.setter('text_size'))
                empty_label.height = self.height * 0.3
                self.rooms_container.add_widget(empty_label)
                self.rooms_container.height = self.rooms_container.minimum_height

    def create_room_tile(self, room):
        """Создает плитку для комнаты с кнопкой удаления"""
        container_width = self.rooms_container.width if self.rooms_container.width > 0 else self.width
        tile_width = (container_width - dp(30)) / 2 if container_width > 0 else dp(150)
        
        tile_layout = RelativeLayout(
            size_hint=(None, None),
            size=(tile_width, tile_width)
        )
        
        # ← КРИТИЧНО: безопасный расчет площади комнаты
        from models import CeilingLayout
        room_area = 0.0
        if room.walls and len(room.walls) >= 3:
            try:
                temp_layout = CeilingLayout(room)
                room_area = temp_layout.room_area_sqm if hasattr(temp_layout, 'room_area_sqm') else 0.0
            except Exception as e:
                print(f"Ошибка расчета площади: {e}")
                room_area = 0.0
        
        # ← КРИТИЧНО: правильное форматирование текста
        if room_area > 0:
            button_text = f"{room.name}\n{room_area:.1f} м²"
        else:
            button_text = room.name
        
        tile_button = Button(
            background_color=(0.95, 0.95, 0.95, 1),
            background_normal='',
            text=button_text,
            font_size=dp(16),
            color=(0, 0, 0, 1),
            halign='center',
            valign='middle',
            text_size=(tile_width - dp(20), tile_width - dp(20)),  # ← Оба размера!
            shorten=False,
            max_lines=2
        )
        tile_button.bind(on_press=lambda instance, r=room: self.open_room_editor(r))
        
        # Кнопка удаления
        delete_container = BoxLayout(
            size_hint=(None, None),
            size=(dp(25), dp(25)),
            pos_hint={'right': 1, 'top': 1}
        )
        delete_button = Button(
            text='X',
            font_size=dp(12),
            size_hint=(1, 1),
            background_color=(0.8, 0.2, 0.2, 1),
            color=(1, 1, 1, 1),
            halign='center',
            valign='middle'
        )
        delete_button.bind(on_press=lambda instance, r_id=room.id: self.confirm_delete_room(r_id))
        delete_container.add_widget(delete_button)
        
        tile_layout.add_widget(tile_button)
        tile_layout.add_widget(delete_container)
        return tile_layout

    def open_room_editor(self, room):
        """Открывает редактор комнаты"""
        self.manager.current_room = room
        # ← КРИТИЧНО: если комната уже имеет стены, пропускаем редактор
        if room.walls and len(room.walls) >= 3:
            self.manager.current = 'layout'
        else:
            self.manager.current = 'room_editor'

    def confirm_delete_room(self, room_id):
        """Показывает диалог подтверждения удаления комнаты."""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(10))
        message = Label(text='Вы точно хотите удалить?', font_size=dp(16))

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.3))

        def do_delete(dt):
            # Найдем комнату в списке объектов и удалим её
            room_to_remove = None
            for r in self.manager.current_project.rooms:
                if r.id == room_id:
                    room_to_remove = r
                    break
            if room_to_remove:
                self.manager.current_project.rooms.remove(room_to_remove)
                # Сохраняем проект (это удалит комнату из БД)
                save_project(self.manager.current_project)

                # КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ: перезагружаем проект из БД для актуализации данных
                if self.manager.current_project.id:
                    updated_project = load_project(
                        self.manager.current_project.id)
                    if updated_project:
                        self.manager.current_project = updated_project

                print(
                    f"Комната с ID {room_id} удалена из проекта и сохранена в БД.")
                # Обновляем сетку
                self.update_rooms_grid()
                popup.dismiss()  # <-- ВАЖНО: добавлено закрытие popup
            else:
                print(
                    f"Комната с ID {room_id} не найдена в локальном списке проекта для удаления.")
                popup.dismiss()  # <-- ВАЖНО: добавлено закрытие popup

        def cancel_delete(dt):
            popup.dismiss()

        btn_delete = Button(text='Удалить', background_color=(
            0.8, 0.2, 0.2, 1), color=(1, 1, 1, 1))
        btn_cancel = Button(text='Отмена')

        btn_delete.bind(on_press=do_delete)
        btn_cancel.bind(on_press=cancel_delete)

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_delete)

        content.add_widget(message)
        content.add_widget(btn_layout)

        popup = Popup(title='Подтверждение удаления',
                      content=content,
                      size_hint=(0.6, 0.4))
        popup.open()

    def show_add_room_dialog(self, instance):
        """Показывает диалог добавления комнаты"""
        content = BoxLayout(orientation='vertical',
                            spacing=dp(10), padding=dp(20))

        label = Label(text='Название комнаты:', font_size=dp(16))
        name_input = TextInput(
            multiline=False,
            font_size=dp(18),
            size_hint=(1, 0.4)
        )

        btn_layout = BoxLayout(spacing=dp(10), size_hint=(1, 0.4))

        btn_confirm = Button(
            text='Создать',
            background_color=(0.2, 0.6, 1, 1),
            color=(1, 1, 1, 1)
        )
        btn_cancel = Button(text='Отмена')

        def create_room(inst):
            name = name_input.text.strip()
            if name:
                from models import Room
                room = Room(name)
                # Добавляем комнату в текущий проект
                self.manager.current_project.rooms.append(room)
                # Сохраняем проект в БД после добавления комнаты
                save_project(self.manager.current_project)

                # КРИТИЧЕСКОЕ ИЗМЕНЕНИЕ: перезагружаем проект из БД, чтобы получить актуальные ID комнат
                if self.manager.current_project.id:
                    updated_project = load_project(
                        self.manager.current_project.id)
                    if updated_project:
                        self.manager.current_project = updated_project

                # Обновляем сетку
                self.update_rooms_grid()
                popup.dismiss()

        btn_confirm.bind(on_press=create_room)
        btn_cancel.bind(on_press=lambda x: popup.dismiss())

        btn_layout.add_widget(btn_cancel)
        btn_layout.add_widget(btn_confirm)

        content.add_widget(label)
        content.add_widget(name_input)
        content.add_widget(btn_layout)

        popup = Popup(
            title='Новая комната',
            content=content,
            size_hint=(0.8, 0.4)
        )
        popup.open()

    def go_back(self, instance):
        """Возврат к проектам"""
        # Сохраняем проект при выходе с экрана комнат (если нужно)
        # save_project(self.manager.current_project)
        self.manager.current = 'projects'

============================================================
ФАЙЛ: utils\__init__.py
============================================================



============================================================
ФАЙЛ: widgets\__init__.py
============================================================



============================================================
ФАЙЛ: widgets\grid_widget.py
============================================================

from kivy.uix.widget import Widget
from kivy.graphics import Color, Line, Rectangle, Ellipse, Mesh
from kivy.properties import NumericProperty, ListProperty
from kivy.metrics import dp
import math


class GridWidget(Widget):
    """Виджет для отображения масштабируемой сетки"""

    scale = NumericProperty(0.2)
    offset_x = NumericProperty(0)
    offset_y = NumericProperty(0)

    # Добавляем свойство для хранения точек комнаты
    room_points = ListProperty([])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Текущая позиция (в сантиметрах)
        self.current_pos_cm = [0, 0]

        # Список стен
        self.walls = []

        # История для отмены
        self.undo_stack = []
        self.redo_stack = []

        # Для перетаскивания (panning)
        self.dragging = False
        self.last_touch_pos = None

        self.touches = {}  # Словарь для отслеживания касаний: {touch.id: touch}
        self.pinch_start_distance = None
        self.pinch_start_scale = None
        self.pinch_center = None

        # Для обработки клика на линию-доводчик
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []

        # Цвета согласно ТЗ
        self.bg_color = (0.12, 0.13, 0.13, 1)      # #1e2022 - темный фон
        self.wall_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - светлые стены
        self.point_color = (0.94, 0.96, 0.98, 1)   # #f0f5f9 - светлая точка
        # #52616b - серый для заполненной комнаты
        self.room_color = (0.32, 0.38, 0.42, 1)
        # #c9d6df - цвет линии соединения
        self.closing_line_color = (0.79, 0.84, 0.87, 1)

        # Центрируем камеру на точке (0,0)
        self.center_camera()

        # Сначала рисуем
        self.draw_editor()

        # Привязываем обновление при изменении размера
        self.bind(size=self._update_canvas)

    def center_camera(self):
        """Центрирует камеру на точке (0,0)"""
        if self.width > 0 and self.height > 0:
            self.offset_x = self.width / 2
            self.offset_y = self.height / 2

    def _update_canvas(self, *args):
        # Центрируем камеру при первом изменении размера
        if self.offset_x == 0 and self.offset_y == 0:
            self.center_camera()
        self.canvas.clear()
        self.draw_editor()

    def cm_to_px(self, cm_x, cm_y):
        """Конвертирует сантиметры в пиксели"""
        px_x = self.offset_x + cm_x * self.scale
        px_y = self.offset_y + cm_y * self.scale
        return px_x, px_y

    def draw_editor(self):
        """Рисует редактор комнаты"""
        self.canvas.clear()

        with self.canvas:
            # Темный фон
            Color(*self.bg_color)
            Rectangle(pos=self.pos, size=self.size)

            # Рисуем заполненную область комнаты (если есть стены)
            if len(self.walls) >= 3:
                self.draw_room_fill()

            # Рисуем стены
            self.draw_walls()

            # Рисуем размеры стен
            self.draw_wall_dimensions()

            # Рисуем текущую точку
            self.draw_current_point()

            # Рисуем линию, соединяющую первую и последнюю точку
            if len(self.walls) >= 3:
                self.draw_closing_line()

    def draw_closing_line(self):
        """Рисует линию, соединяющую первую и последнюю точку"""
        if len(self.walls) < 3:
            return

        # Берем первую точку первой стены и последнюю точку последней стены
        first_wall = self.walls[0]
        last_wall = self.walls[-1]

        # Первая точка: начало первой стены
        x1, y1 = first_wall[0], first_wall[1]
        # Последняя точка: конец последней стены
        x2, y2 = last_wall[2], last_wall[3]

        # Проверяем, не совпадают ли точки (если комната уже замкнута)
        if abs(x1 - x2) < 0.1 and abs(y1 - y2) < 0.1:
            return

        # Сохраняем координаты линии-доводчика для обработки кликов
        self.closing_line_start = (x1, y1)
        self.closing_line_end = (x2, y2)

        # Преобразуем в пиксели для отрисовки
        px1 = self.cm_to_px(x1, y1)
        px2 = self.cm_to_px(x2, y2)

        # Сохраняем точки линии в пикселях
        self.closing_line_points = [px1[0], px1[1], px2[0], px2[1]]

        # Цвет для линии соединения
        Color(*self.closing_line_color)

        # Рисуем пунктирную линию
        Line(points=self.closing_line_points,
             width=2, dash_length=10, dash_offset=5)

    def point_to_line_distance(self, px, py, x1, y1, x2, y2):
        """Вычисляет расстояние от точки до линии"""
        # Если линия вырождена в точку
        if x1 == x2 and y1 == y2:
            return math.sqrt((px - x1)**2 + (py - y1)**2)

        # Вектор линии
        line_vec_x = x2 - x1
        line_vec_y = y2 - y1

        # Вектор от начала линии до точки
        point_vec_x = px - x1
        point_vec_y = py - y1

        # Длина линии
        line_len = math.sqrt(line_vec_x**2 + line_vec_y**2)

        # Единичный вектор линии
        if line_len > 0:
            line_vec_x /= line_len
            line_vec_y /= line_len

        # Проекция вектора точки на линию
        projection_length = point_vec_x * line_vec_x + point_vec_y * line_vec_y

        # Ограничиваем проекцию длиной линии
        projection_length = max(0, min(line_len, projection_length))

        # Ближайшая точка на линии
        closest_x = x1 + projection_length * line_vec_x
        closest_y = y1 + projection_length * line_vec_y

        # Расстояние от точки до ближайшей точки на линии
        return math.sqrt((px - closest_x)**2 + (py - closest_y)**2)

    def draw_room_fill(self):
        """Правильная заливка внутренней области комнаты"""
        if len(self.walls) < 3:
            return

        # Собираем точки в правильном порядке для контура
        points = []
        if self.walls:
            # Первая точка первой стены
            points.append((self.walls[0][0], self.walls[0][1]))
            # Конечные точки всех стен
            for wall in self.walls:
                points.append((wall[2], wall[3]))
            # Если комната не замкнута, замыкаем полигон
            if points[-1] != points[0]:
                points.append(points[0])

        # Проверяем, достаточно ли точек для заливки
        if len(points) < 4:
            return

        # Преобразуем точки в экранные координаты
        screen_points = []
        for x, y in points:
            px = self.cm_to_px(x, y)
            screen_points.extend([px[0], px[1]])

        if len(screen_points) < 8:  # Минимум 4 точки для полигона
            return

        with self.canvas:
            # Заливаем полигон цветом комнаты
            Color(*self.room_color)

            # Создаем Mesh для заливки сложных форм
            vertices = []
            indices = []

            # Используем триангуляцию "веером" от центра масс
            center_x = sum(screen_points[i] for i in range(
                0, len(screen_points), 2)) / (len(screen_points) // 2)
            center_y = sum(screen_points[i] for i in range(
                1, len(screen_points), 2)) / (len(screen_points) // 2)

            # Создаем треугольники от центра к каждой паре соседних точек
            for i in range(0, len(screen_points) - 2, 2):
                # Центр
                vertices.extend([center_x, center_y, 0, 0])
                # Текущая точка
                vertices.extend([screen_points[i], screen_points[i+1], 0, 0])
                # Следующая точка
                vertices.extend([screen_points[i+2], screen_points[i+3], 0, 0])

            # Создаем индексы для треугольников
            indices = list(range(len(vertices) // 4))

            if vertices:
                Mesh(vertices=vertices, indices=indices, mode='triangles')

    def draw_walls(self):
        """Рисует стены комнаты"""
        if not self.walls:
            return

        Color(*self.wall_color)
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            Line(points=[px1[0], px1[1], px2[0], px2[1]], width=3)

    def draw_current_point(self):
        """Рисует текущую точку"""
        x, y = self.current_pos_cm
        px_x, px_y = self.cm_to_px(x, y)

        Color(*self.point_color)
        Ellipse(pos=(px_x - 6, px_y - 6), size=(12, 12))

    def save_state(self):
        """Сохраняет текущее состояние для отмены"""
        state = {
            'walls': [w[:] for w in self.walls],  # Копируем стены
            'current_pos': self.current_pos_cm[:]  # Копируем позицию
        }
        self.undo_stack.append(state)
        # При новом действии очищаем стек повторения
        self.redo_stack = []

    def restore_state(self, index):
        """Восстанавливает состояние из истории"""
        if 0 <= index < len(self.history):
            state = self.history[index]
            self.walls = [w[:] for w in state['walls']]
            self.current_pos_cm = state['current_pos'][:]
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def undo(self):
        """Отменяет последнее действие"""
        if len(self.undo_stack) > 1:
            # Сохраняем текущее состояние для возможного redo
            current_state = self.undo_stack.pop()
            self.redo_stack.append(current_state)

            # Восстанавливаем предыдущее состояние
            prev_state = self.undo_stack[-1]
            self.walls = [w[:] for w in prev_state['walls']]
            self.current_pos_cm = prev_state['current_pos'][:]

            # Перерисовываем
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def redo(self):
        """Повторяет отмененное действие"""
        if self.redo_stack:
            # Берем состояние для повтора
            state = self.redo_stack.pop()
            self.undo_stack.append(state)

            # Восстанавливаем состояние
            self.walls = [w[:] for w in state['walls']]
            self.current_pos_cm = state['current_pos'][:]

            # Перерисовываем
            self.canvas.clear()
            self.draw_editor()
            return True
        return False

    def add_wall(self, direction, length_cm):
        """Добавляет стену в указанном направлении"""
        # Сохраняем текущее состояние перед изменением
        self.save_state()

        # Очищаем линию-доводчик при добавлении новой стены
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []

        x1, y1 = self.current_pos_cm

        # Для диагональных направлений корректируем длину
        if direction in ['up_left', 'up_right', 'down_left', 'down_right']:
            # Делим длину на sqrt(2) для сохранения заданной длины диагонали
            component_length = length_cm / math.sqrt(2)
        else:
            component_length = length_cm

        if direction == 'up':
            x2, y2 = x1, y1 + component_length
        elif direction == 'down':
            x2, y2 = x1, y1 - component_length
        elif direction == 'left':
            x2, y2 = x1 - component_length, y1
        elif direction == 'right':
            x2, y2 = x1 + component_length, y1
        elif direction == 'up_left':
            x2, y2 = x1 - component_length, y1 + component_length
        elif direction == 'up_right':
            x2, y2 = x1 + component_length, y1 + component_length
        elif direction == 'down_left':
            x2, y2 = x1 - component_length, y1 - component_length
        elif direction == 'down_right':
            x2, y2 = x1 + component_length, y1 - component_length
        else:
            self.undo_stack.pop()  # Отменяем сохранение состояния
            return

        self.walls.append([x1, y1, x2, y2])
        self.current_pos_cm = [x2, y2]
        self.canvas.clear()
        self.draw_editor()
        return (x2, y2)

    def reset(self):
        """Сбрасывает редактор"""
        self.current_pos_cm = [0, 0]
        self.walls = []
        self.history = []
        self.history_index = -1
        self.saved_for_redo = []
        self.save_state()
        self.canvas.clear()
        self.draw_editor()

    def add_closing_wall(self):
        """Добавляет стену, замыкающую комнату (при нажатии на линию-доводчик)"""
        if len(self.walls) < 3 or not self.closing_line_start or not self.closing_line_end:
            return

        # Сохраняем текущее состояние перед изменением
        self.save_state()

        # Добавляем стену от последней точки к первой
        x1, y1 = self.closing_line_end  # Конец последней стены
        x2, y2 = self.closing_line_start  # Начало первой стены

        self.walls.append([x1, y1, x2, y2])
        self.current_pos_cm = [x2, y2]

        # Очищаем линию-доводчик
        self.closing_line_start = None
        self.closing_line_end = None
        self.closing_line_points = []

        # Перерисовываем
        self.canvas.clear()
        self.draw_editor()

    def get_distance(self, touch1, touch2):
        """Расстояние между двумя точками касания"""
        return ((touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2) ** 0.5

    def get_center(self, touch1, touch2):
        """Центр между двумя точками касания"""
        return ((touch1.x + touch2.x) / 2, (touch1.y + touch2.y) / 2)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            if self.is_touch_on_closing_line(touch):
                self.add_closing_wall()
                return True  # Обработка завершена

            # Колесо мыши (оставляем для десктопа)
            if touch.is_mouse_scrolling:
                if touch.button == 'scrolldown':
                    self.scale = max(0.1, self.scale - 0.05)
                elif touch.button == 'scrollup':
                    # Увеличен макс. масштаб до 3.0
                    self.scale = min(3.0, self.scale + 0.05)
                self.canvas.clear()
                self.draw_editor()
                return True

            # Начало пинч-жеста (2 пальца)
            self.touches[touch.id] = touch
            if len(self.touches) == 2:
                touches = list(self.touches.values())
                self.pinch_start_distance = self.get_distance(
                    touches[0], touches[1])
                self.pinch_start_scale = self.scale
                self.pinch_center = self.get_center(touches[0], touches[1])
                return True

            # Одиночное касание — панорамирование
            self.dragging = True
            self.last_touch_pos = (touch.x, touch.y)
            return True
        return super().on_touch_down(touch)

    def is_touch_on_closing_line(self, touch, tolerance=dp(10)):
        """Проверяет, находится ли касание рядом с линией-доводчиком."""
        if not self.closing_line_points or len(self.closing_line_points) != 4:
            return False

        x1, y1, x2, y2 = self.closing_line_points
        px, py = touch.pos

        # Вычисляем расстояние от точки до линии
        dist = self.point_to_line_distance(px, py, x1, y1, x2, y2)
        return dist < tolerance

    def on_touch_move(self, touch):
        if touch.id in self.touches and len(self.touches) == 2:
            # Пинч-масштабирование
            touches = list(self.touches.values())
            current_distance = self.get_distance(touches[0], touches[1])

            if self.pinch_start_distance:
                scale_factor = current_distance / self.pinch_start_distance
                new_scale = self.pinch_start_scale * scale_factor
                # Ограничение масштаба
                new_scale = max(0.1, min(3.0, new_scale))

                # Пересчитываем смещение относительно центра жеста
                if self.pinch_center:
                    old_center_x = (
                        self.pinch_center[0] - self.offset_x) / self.scale
                    old_center_y = (
                        self.pinch_center[1] - self.offset_y) / self.scale

                    self.scale = new_scale
                    self.offset_x = self.pinch_center[0] - \
                        old_center_x * self.scale
                    self.offset_y = self.pinch_center[1] - \
                        old_center_y * self.scale

                self.canvas.clear()
                self.draw_editor()
                return True

        # Обработка панорамирования (один палец)
        if self.dragging and self.last_touch_pos:
            dx = touch.x - self.last_touch_pos[0]
            dy = touch.y - self.last_touch_pos[1]
            self.offset_x += dx
            self.offset_y += dy
            self.last_touch_pos = (touch.x, touch.y)
            self.canvas.clear()
            self.draw_editor()
            return True

        return super().on_touch_move(touch)

    def on_touch_up(self, touch):
        self.touches.pop(touch.id, None)
        self.pinch_start_distance = None
        self.pinch_center = None
        self.dragging = False
        self.last_touch_pos = None
        return super().on_touch_up(touch)

    def format_dimension(self, length_cm):
        """Форматирует размер с пробелом как разделителем тысяч"""
        return f"{int(length_cm):,}".replace(",", " ")

    def draw_wall_dimensions(self):
        """Рисует размеры стен над линиями"""
        if not self.walls:
            return

        from kivy.core.text import Label as CoreLabel
        from kivy.graphics import Color, Rectangle

        for wall in self.walls:
            x1, y1, x2, y2 = wall
            length = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            dx = x2 - x1
            dy = y2 - y1
            length_wall = math.sqrt(dx**2 + dy**2)

            if length_wall > 0:
                nx = -dy / length_wall
                ny = dx / length_wall
                offset = 10
                text_x = mid_x + nx * offset
                text_y = mid_y + ny * offset
                px_x, px_y = self.cm_to_px(text_x, text_y)
                text = self.format_dimension(length) + " см"

                label = CoreLabel(text=text, font_size=dp(12),
                                  color=(0, 0, 0, 1))
                label.refresh()

                padding = 2
                Color(1, 1, 1, 0.7)
                Rectangle(
                    pos=(px_x - label.texture.size[0]/2 - padding,
                         px_y - label.texture.size[1]/2 - padding),
                    size=(label.texture.size[0] + padding*2,
                          label.texture.size[1] + padding*2)
                )

                Color(0, 0, 0, 1)
                Rectangle(
                    texture=label.texture,
                    pos=(px_x - label.texture.size[0]/2,
                         px_y - label.texture.size[1]/2),
                    size=label.texture.size
                )

============================================================
ФАЙЛ: widgets\layout_widget.py
============================================================

from kivy.uix.widget import Widget
from kivy.graphics import Color, Line, Rectangle, Mesh
from kivy.properties import NumericProperty, ObjectProperty, BooleanProperty
from kivy.metrics import dp
from kivy.core.text import Label as CoreLabel
from kivy.graphics import StencilPush
from kivy.clock import Clock
from functools import partial
from kivy.graphics.stencil_instructions import StencilPush, StencilUse, StencilUnUse, StencilPop


class LayoutWidget(Widget):
    """Виджет для отображения раскладки 60×60 см"""

    scale = NumericProperty(0.3)
    offset_x = NumericProperty(0)
    offset_y = NumericProperty(0)
    grid_offset_x = NumericProperty(0)  # Смещение сетки (0-59 см)
    grid_offset_y = NumericProperty(0)
    on_grid_move = ObjectProperty(None)  # Callback для обновления статистики
    dragging_enabled = BooleanProperty(True)
    show_dimensions = BooleanProperty(True)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Данные комнаты
        self.walls = []
        self.layout = None
        self.room_bounds = None  # Границы комнаты
        self.is_rotated = False  # Флаг поворота
        self.rotation_angle = 0  # Угол поворота
        self.redraw_scheduled = False
        self.last_redraw_time = 0
        self.dragging_enabled = True
        self.panning = False  # Для режима панорамирования
        self.last_pan_pos = None

        # Для перетаскивания
        self.dragging = False
        self.last_touch_pos = None

        self.touches = {}
        self.pinch_start_distance = None
        self.pinch_start_scale = None
        self.pinch_center = None

        # Цвета согласно редактору
        self.bg_color = (0.12, 0.13, 0.13, 1)      # #1e2022 - темный фон
        self.wall_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - светлые стены
        # #52616b - серый для заполненной комнаты
        self.room_color = (0.32, 0.38, 0.42, 1)
        self.grid_color = (0.79, 0.84, 0.87, 0.7)  # #c9d6df - цвет сетки
        self.full_tile_color = (0.9, 0.9, 0.9, 0.3)  # Цвет целых плиток
        self.cut_tile_color = (0.7, 0.7, 0.7, 0.3)   # Цвет резаных плиток
        self.text_color = (0.94, 0.96, 0.98, 1)    # #f0f5f9 - цвет текста

        self.bind(size=self._update_canvas)

    def _update_canvas(self, *args):
        """Обновляет канвас при изменении размера виджета"""
        try:
            if hasattr(self, 'room_bounds') and self.room_bounds:
                # Пересчитываем позицию при изменении размера
                self.center_room()

            if hasattr(self, 'draw_layout'):
                self.draw_layout()
        except Exception as e:
            print(f"Ошибка при обновлении канваса: {e}")

    def set_room(self, walls):
        """Устанавливает стены комнаты и центрирует ее на экране"""
        self.walls = walls
        if not walls:
            return

        # Находим границы комнаты
        all_x = []
        all_y = []
        for wall in walls:
            x1, y1, x2, y2 = wall
            all_x.extend([x1, x2])
            all_y.extend([y1, y2])

        if not all_x or not all_y:
            return

        self.room_bounds = {
            'min_x': min(all_x), 'max_x': max(all_x),
            'min_y': min(all_y), 'max_y': max(all_y)
        }

        # Центрируем комнату
        self.center_room()

        # Сбрасываем смещение сетки в 0 для правильного начала
        self.grid_offset_x = 0
        self.grid_offset_y = 0

        self.draw_layout()

    def center_room(self):
        """Центрирует комнату в рабочей области с учетом тулбаров"""
        if not self.room_bounds:
            return

        min_x, max_x = self.room_bounds['min_x'], self.room_bounds['max_x']
        min_y, max_y = self.room_bounds['min_y'], self.room_bounds['max_y']

        room_width = max_x - min_x
        room_height = max_y - min_y

        # Защита от нулевых размеров
        if room_width <= 0:
            room_width = 10
        if room_height <= 0:
            room_height = 10

        # Вычисляем масштаб с учетом отступов
        # Учитываем, что верхний тулбар = 10%, нижние панели = 10% (итого 80% доступно)
        # 12% сверху (дополнительный отступ для верхнего тулбара)
        padding_top = 0.12
        padding_bottom = 0.12  # 8% снизу (меньше, чем сверху)
        padding_sides = 0.10  # 10% с каждой стороны

        available_height = self.height * (1 - padding_top - padding_bottom)
        available_width = self.width * (1 - 2 * padding_sides)

        scale_x = available_width / room_width if room_width > 0 else 0.3
        scale_y = available_height / room_height if room_height > 0 else 0.3

        # Используем минимальный масштаб для вписывания
        self.scale = min(scale_x, scale_y)

        # Ограничиваем масштаб
        self.scale = max(0.1, min(self.scale, 1.0))

        # Центрируем комнату с учетом отступов
        room_center_x = (min_x + max_x) / 2
        room_center_y = (min_y + max_y) / 2

        widget_center_x = self.width / 2
        widget_center_y = self.height / 2

        self.offset_x = widget_center_x - room_center_x * self.scale
        self.offset_y = widget_center_y - room_center_y * self.scale

        # Корректируем по Y, чтобы учесть разные отступы сверху и снизу
        bottom_bound = self.offset_y + min_y * self.scale
        top_bound = self.offset_y + max_y * self.scale

        # Устанавливаем минимальные отступы от границ
        min_top_padding = self.height * padding_top
        min_bottom_padding = self.height * padding_bottom

        # Если комната выходит за верхний отступ
        if top_bound > self.height - min_top_padding:
            self.offset_y -= (top_bound - (self.height - min_top_padding))

        # Если комната выходит за нижний отступ
        if bottom_bound < min_bottom_padding:
            self.offset_y += (min_bottom_padding - bottom_bound)

    def cm_to_px(self, cm_x, cm_y):
        """Конвертирует сантиметры в пиксели"""
        # БЕЗ ПОВОРОТА - просто масштабирование и смещение
        px_x = self.offset_x + cm_x * self.scale
        px_y = self.offset_y + cm_y * self.scale
        return px_x, px_y

    def draw_layout(self):
        self.canvas.clear()

        with self.canvas:
            # Темный фон
            Color(*self.bg_color)
            Rectangle(pos=self.pos, size=self.size)

            # 1. Рисуем заполнение комнаты
            self.draw_room_fill()

            # 2. Рисуем плитки сетки 60×60
            self.draw_grid_tiles()

            # 3. Рисуем стены комнаты поверх
            self.draw_walls()

            # 4. Рисуем цифры ТОЛЬКО если включено
            if self.show_dimensions:
                self.draw_all_cut_dimensions()

    def draw_all_cut_dimensions(self):
        """Рисуем размеры резаных плиток с центрированием и адаптивным масштабированием"""
        if not self.layout or not self.layout.tiles:
            return

        for tile in self.layout.tiles:
            if tile['type'] != 'cut':
                continue

            remaining_x = tile.get('cut_x', 60.0)
            remaining_y = tile.get('cut_y', 60.0)

            # Показываем только обрезанные стороны
            texts = []
            if remaining_x < 59.5:
                texts.append(f"{int(round(remaining_x))}")
            if remaining_y < 59.5:
                texts.append(f"{int(round(remaining_y))}")
            if not texts:
                continue

            text = f"{texts[0]}×{texts[1]}" if len(texts) == 2 else texts[0]

            # Центр плитки
            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            center_x = (x1 + x2) / 2
            center_y = (y1 + y2) / 2
            px_center = self.cm_to_px(center_x, center_y)

            # 🔑 КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: адаптивный размер шрифта в зависимости от длины текста
            tile_height_px = 60 * self.scale  # Высота плитки в пикселях

            # Для одиночных цифр — крупнее (70% высоты плитки)
            # Для двойных цифр ("45×36") — мельче (50% высоты плитки)
            # Это даёт визуально одинаковое заполнение пространства
            if '×' in text:
                font_scale = 0.30  # Двойные цифры — меньше шрифт
            else:
                font_scale = 0.50  # Одиночные цифры — крупнее

            font_size = tile_height_px * font_scale

            # Ограничиваем для читаемости и предотвращения перекрытия
            # 8px минимум, 30px максимум
            font_size = max(8, min(30, font_size))

            # Создаём текст
            label = CoreLabel(
                text=text,
                font_size=font_size,  # ← ЧИСЛО, не строка!
                color=self.text_color,
                bold=True
            )
            label.refresh()

            # Центрируем текст
            pos_x = px_center[0] - label.texture.size[0] / 2
            pos_y = px_center[1] - label.texture.size[1] / 2

            # 🔑 УМЕНЬШЕННЫЕ отступы фона (5% вместо 8%) — чтобы не выходил за границы плитки
            padding_x = label.texture.size[0] * 0.05
            padding_y = label.texture.size[1] * 0.05

            # Полупрозрачный фон с минимальными отступами
            Color(0, 0, 0, 0.3)
            Rectangle(
                pos=(pos_x - padding_x, pos_y - padding_y),
                size=(label.texture.size[0] + padding_x * 2,
                      label.texture.size[1] + padding_y * 2)
            )

            # Текст поверх фона
            Color(*self.text_color)
            Rectangle(
                texture=label.texture,
                pos=(pos_x, pos_y),
                size=label.texture.size
            )

    def draw_room_fill(self):
        """Правильная заливка внутренней области комнаты для сложных форм"""
        if len(self.walls) < 3:
            return

        # Собираем точки в правильном порядке
        points = []
        if self.walls:
            points.append((self.walls[0][0], self.walls[0][1]))
            for wall in self.walls:
                points.append((wall[2], wall[3]))
            if points[-1] != points[0]:
                points.append(points[0])

        if len(points) < 4:
            return

        # Преобразуем точки в экранные координаты
        screen_points = []
        for x, y in points:
            px = self.cm_to_px(x, y)
            screen_points.extend([px[0], px[1]])

        if len(screen_points) < 8:
            return

        with self.canvas:
            # Используем stencil для правильной заливки
            StencilPush()
            Color(1, 1, 1, 1)

            # Рисуем контур для stencil
            Line(points=screen_points, close=True, width=1)

            StencilUse()

            # Заливаем ВНУТРЬ контура
            Color(*self.room_color)
            # Используем больший прямоугольник для гарантии заполнения
            min_x = min(screen_points[i]
                        for i in range(0, len(screen_points), 2))
            max_x = max(screen_points[i]
                        for i in range(0, len(screen_points), 2))
            min_y = min(screen_points[i]
                        for i in range(1, len(screen_points), 2))
            max_y = max(screen_points[i]
                        for i in range(1, len(screen_points), 2))
            Rectangle(pos=(min_x, min_y), size=(max_x-min_x, max_y-min_y))

            StencilUnUse()
            StencilPop()

            # Рисуем контур поверх заливки
            Color(*self.wall_color)
            Line(points=screen_points, close=True, width=2)

    def draw_walls(self):
        """Рисует стены комнаты"""
        if not self.walls:
            return

        Color(*self.wall_color)
        for wall in self.walls:
            x1, y1, x2, y2 = wall
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            Line(points=[px1[0], px1[1], px2[0], px2[1]], width=3)

    def draw_grid_tiles(self):
        """Рисует сетку 60×60 в виде плиток (только внутри комнаты)"""
        if not self.layout or not self.layout.tiles:
            return

        # Рисуем заливку плиток
        for tile in self.layout.tiles:
            # Пропускаем плитки полностью вне комнаты
            if tile['type'] == 'outside':
                continue

            # Дополнительная проверка для резаных плиток: пропускаем если оба размера меньше 1 см
            if tile['type'] == 'cut':
                cut_x = tile.get('cut_x', 0)
                cut_y = tile.get('cut_y', 0)
                if cut_x < 1.0 and cut_y < 1.0:
                    continue

            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            # Рисуем заливку плитки
            if tile['type'] == 'full':
                Color(*self.full_tile_color)
                Rectangle(pos=px1, size=(px2[0]-px1[0], px2[1]-px1[1]))
            else:  # cut
                Color(*self.cut_tile_color)
                Rectangle(pos=px1, size=(px2[0]-px1[0], px2[1]-px1[1]))

        # Рисуем контуры плиток
        Color(*self.grid_color)
        for tile in self.layout.tiles:
            if tile['type'] == 'outside':
                continue
            x1, y1, x2, y2 = tile['x1'], tile['y1'], tile['x2'], tile['y2']
            px1 = self.cm_to_px(x1, y1)
            px2 = self.cm_to_px(x2, y2)

            # Рисуем контур плитки
            Line(rectangle=(px1[0], px1[1], px2[0] -
                 px1[0], px2[1] - px1[1]), width=1)

    # Добавляем новый метод для расчета процента отходов:

    def schedule_redraw(self):
        """Планирует перерисовку с задержкой"""
        if not self.redraw_scheduled:
            self.redraw_scheduled = True
            Clock.schedule_once(self.redraw_now, 0.05)  # 20 FPS

    def redraw_now(self, dt):
        """Выполняет перерисовку"""
        self.redraw_scheduled = False
        self.draw_layout()

    def move_grid(self, dx_cm, dy_cm):
        """Смещает сетку на указанное количество см"""
        self.grid_offset_x = (self.grid_offset_x + dx_cm) % 60
        self.grid_offset_y = (self.grid_offset_y + dy_cm) % 60

        # Вызываем callback для обновления статистики
        if self.on_grid_move:
            self.on_grid_move(self.grid_offset_x, self.grid_offset_y)

        # Используем оптимизированную перерисовку
        self.schedule_redraw()

    def zoom_at_center(self, zoom_in=True):
        """Масштабирует относительно центра виджета"""
        # Запоминаем центр виджета в мировых координатах
        center_world_x = (self.width / 2 - self.offset_x) / self.scale
        center_world_y = (self.height / 2 - self.offset_y) / self.scale

        # Изменяем масштаб
        if zoom_in:
            # Максимальный масштаб увеличен до 3.0x
            new_scale = min(3.0, self.scale + 0.05)
        else:
            new_scale = max(0.1, self.scale - 0.05)

        # Пересчитываем смещение, чтобы центр остался на месте
        new_offset_x = self.width / 2 - center_world_x * new_scale
        new_offset_y = self.height / 2 - center_world_y * new_scale

        # Применяем изменения
        self.scale = new_scale
        self.offset_x = new_offset_x
        self.offset_y = new_offset_y

        # Обновляем отображение
        self.apply_bounds_protection()
        self.canvas.clear()
        if hasattr(self, 'draw_editor'):
            self.draw_editor()
        else:
            self.draw_layout()

    def apply_bounds_protection(self):
        """Защищает от выхода комнаты за границы виджета"""
        if not self.room_bounds:
            return

        min_x = self.room_bounds['min_x']
        max_x = self.room_bounds['max_x']
        min_y = self.room_bounds['min_y']
        max_y = self.room_bounds['max_y']

        # Рассчитываем границы видимой области
        visible_min_x = (0 - self.offset_x) / self.scale
        visible_max_x = (self.width - self.offset_x) / self.scale
        visible_min_y = (0 - self.offset_y) / self.scale
        visible_max_y = (self.height - self.offset_y) / self.scale

        # Если комната выходит за левую границу
        if max_x < visible_min_x:
            self.offset_x += (visible_min_x - max_x) * self.scale
        # Если комната выходит за правую границу
        if min_x > visible_max_x:
            self.offset_x -= (min_x - visible_max_x) * self.scale
        # Если комната выходит за нижнюю границу
        if max_y < visible_min_y:
            self.offset_y += (visible_min_y - max_y) * self.scale
        # Если комната выходит за верхнюю границу
        if min_y > visible_max_y:
            self.offset_y -= (min_y - visible_max_y) * self.scale

    def get_distance(self, touch1, touch2):
        return ((touch1.x - touch2.x) ** 2 + (touch1.y - touch2.y) ** 2) ** 0.5

    def get_center(self, touch1, touch2):
        return ((touch1.x + touch2.x) / 2, (touch1.y + touch2.y) / 2)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            # Колесо мыши (оставляем для десктопа)
            if touch.is_mouse_scrolling:
                if touch.button == 'scrolldown':
                    self.scale = max(0.1, self.scale - 0.05)
                elif touch.button == 'scrollup':
                    self.scale = min(1.0, self.scale + 0.05)
                self.draw_layout()
                return True

            # Начало пинча
            self.touches[touch.id] = touch
            if len(self.touches) == 2:
                touches = list(self.touches.values())
                self.pinch_start_distance = self.get_distance(
                    touches[0], touches[1])
                self.pinch_start_scale = self.scale
                self.pinch_center = self.get_center(touches[0], touches[1])
                return True

            # Одиночное касание — перетаскивание или перемещение сетки
            if self.dragging_enabled:
                self.dragging = True
                self.last_touch_pos = touch.pos
            else:
                self.panning = True
                self.last_pan_pos = touch.pos
            return True

        return super().on_touch_down(touch)

    def on_touch_move(self, touch):
        if touch.id in self.touches and len(self.touches) == 2:
            # Пинч-масштабирование
            touches = list(self.touches.values())
            current_distance = self.get_distance(touches[0], touches[1])
            if self.pinch_start_distance:
                scale_factor = current_distance / self.pinch_start_distance
                new_scale = self.pinch_start_scale * scale_factor
                new_scale = max(0.1, min(2.0, new_scale))
                if self.pinch_center:
                    old_center_x = (
                        self.pinch_center[0] - self.offset_x) / self.scale
                    old_center_y = (
                        self.pinch_center[1] - self.offset_y) / self.scale
                    self.scale = new_scale
                    self.offset_x = self.pinch_center[0] - \
                        old_center_x * self.scale
                    self.offset_y = self.pinch_center[1] - \
                        old_center_y * self.scale
                    self.draw_layout()
            return True

        # Обработка перетаскивания (один палец)
        if self.dragging and self.dragging_enabled:
            dx_px = touch.x - self.last_touch_pos[0]
            dy_px = touch.y - self.last_touch_pos[1]
            # --- ИЗМЕНЕНИЕ ---
            # Округляем смещение до целых сантиметров перед добавлением
            dx_cm = round(dx_px / self.scale)
            dy_cm = round(dy_px / self.scale)
            # ---
            self.grid_offset_x += dx_cm
            self.grid_offset_y += dy_cm
            self.last_touch_pos = touch.pos
            if self.on_grid_move:
                self.on_grid_move()  # Вызов callback для обновления
            self.draw_layout()
            return True

        if self.panning and not self.dragging_enabled:
            dx = touch.x - self.last_pan_pos[0]
            dy = touch.y - self.last_pan_pos[1]
            self.offset_x += dx
            self.offset_y += dy
            self.last_pan_pos = touch.pos
            self.draw_layout()
            return True

        return super().on_touch_move(touch)

    def on_touch_up(self, touch):
        self.touches.pop(touch.id, None)
        self.pinch_start_distance = None
        self.pinch_center = None
        self.dragging = False
        self.panning = False
        self.last_touch_pos = None
        self.last_pan_pos = None
        return super().on_touch_up(touch)
